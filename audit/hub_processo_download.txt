================================================================================
PROCESS AUDIT: hub_processo_download.txt
DATE: 2026-01-08 15:23:52
FILE COUNT: 19
================================================================================

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\DownloadWorker.kt ----------
package com.joaomagdaleno.music_hub.download

import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC
import android.os.Build
import androidx.annotation.OptIn
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.media3.common.util.NotificationUtil
import androidx.media3.common.util.NotificationUtil.createNotificationChannel
import androidx.media3.common.util.UnstableApi
import androidx.work.CoroutineWorker
import androidx.work.ForegroundInfo
import androidx.work.WorkerParameters
import com.joaomagdaleno.music_hub.MainActivity.Companion.getMainActivity
import com.joaomagdaleno.music_hub.R
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch

class DownloadWorker(
    private val context: Context,
    params: WorkerParameters,
    downloader: Downloader,
) : CoroutineWorker(context, params) {

    private val manager = downloader.taskManager
    override suspend fun doWork(): Result {
        setForeground(createNotification(0))
        val job = manager.scope.launch {
            manager.taskFlow.collectLatest {
                if (it.isEmpty()) removeNotification()
                else if (isActive) setForeground(createNotification(it.size))
            }
        }
        manager.awaitCompletion()
        job.cancel()
        return Result.success()
    }

    @OptIn(UnstableApi::class)
    private fun createNotification(
        tracks: Int,
    ): ForegroundInfo {
        createNotificationChannel(
            context, PROGRESS_CHANNEL_ID, R.string.download_progress, 0,
            NotificationUtil.IMPORTANCE_DEFAULT
        )
        val notificationBuilder = NotificationCompat.Builder(context, PROGRESS_CHANNEL_ID)
        val intent = getMainIntent(context)

        val tracksTitle = runCatching {
            context.resources.getQuantityString(R.plurals.number_songs, tracks, tracks)
        }.getOrNull() ?: context.getString(R.string.n_songs, tracks)

        return ForegroundInfo(
            NOTIF_ID,
            notificationBuilder
                .setSmallIcon(R.drawable.ic_downloading)
                .setContentTitle(context.getString(R.string.downloading_x, tracksTitle))
                .setContentIntent(intent)
                .setProgress(100, 0, true)
                .setOnlyAlertOnce(true)
                .setOngoing(true)
                .build(),
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) 0
            else FOREGROUND_SERVICE_TYPE_DATA_SYNC
        )
    }

    private fun removeNotification() {
        NotificationManagerCompat.from(context).cancel(NOTIF_ID)
    }

    companion object {
        private const val NOTIF_ID = 0
        private const val PROGRESS_CHANNEL_ID = "download_progress_channel"

        fun getMainIntent(context: Context) = PendingIntent.getActivity(
            context,
            0,
            Intent(context, context.getMainActivity()).apply {
                putExtra("fromDownload", true)
            },
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT,
        )!!
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\Downloader.kt ----------
package com.joaomagdaleno.music_hub.download

import androidx.work.Constraints
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import com.joaomagdaleno.music_hub.common.clients.DownloadClient
import com.joaomagdaleno.music_hub.common.clients.TrackClient
import com.joaomagdaleno.music_hub.common.models.DownloadContext
import com.joaomagdaleno.music_hub.common.models.Progress
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.db.DownloadDatabase
import com.joaomagdaleno.music_hub.download.db.models.ContextEntity
import com.joaomagdaleno.music_hub.download.db.models.DownloadEntity
import com.joaomagdaleno.music_hub.download.db.models.TaskType
import com.joaomagdaleno.music_hub.download.exceptions.DownloaderExtensionNotFoundException
import com.joaomagdaleno.music_hub.download.tasks.TaskManager
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getAs
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtensionOrThrow
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.isClient
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.EXTENSION_ID
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.withExtensionId
import com.joaomagdaleno.music_hub.utils.Serializer.toJson
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import kotlinx.coroutines.plus
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.io.File
import java.util.WeakHashMap

class Downloader(
    val app: App,
    val extensionLoader: ExtensionLoader,
    database: DownloadDatabase,
) {
    val unified = extensionLoader.unified.value

    suspend fun downloadExtension() = extensionLoader.misc.value
        .find { it.isClient<DownloadClient>() && it.isEnabled }
        ?: throw DownloaderExtensionNotFoundException()

    val scope = CoroutineScope(Dispatchers.IO) + CoroutineName("Downloader")

    val dao = database.downloadDao()
    val downloadFlow = dao.getDownloadsFlow()
    private val contextFlow = dao.getContextFlow()
    private val downloadInfoFlow = downloadFlow.combine(contextFlow) { downloads, contexts ->
        downloads.map { download ->
            val context = contexts.find { download.contextId == it.id }
            Info(download, context, listOf())
        }
    }

    val taskManager = TaskManager(this)

    fun add(
        downloads: List<DownloadContext>
    ) = scope.launch {
        val concurrentDownloads = downloadExtension()
            .getAs<DownloadClient, Int> { concurrentDownloads }
            .getOrNull()?.takeIf { it > 0 } ?: 2
        taskManager.setConcurrency(concurrentDownloads)
        val contexts = downloads.mapNotNull { it.context }.distinctBy { it.id }.associate {
            it.id to dao.insertContextEntity(ContextEntity(0, it.id, it.toJson()))
        }
        downloads.forEach {
            dao.insertDownloadEntity(
                DownloadEntity(
                    0,
                    it.track.extras[EXTENSION_ID] ?: it.extensionId,
                    it.track.id,
                    contexts[it.context?.id],
                    it.sortOrder,
                    it.track.toJson(),
                    TaskType.Loading,
                )
            )
        }
        ensureWorker()
    }

    private val workManager by lazy { WorkManager.getInstance(app.context) }
    private fun ensureWorker() {
        val request = OneTimeWorkRequestBuilder<DownloadWorker>()
            .setConstraints(Constraints(NetworkType.CONNECTED, requiresStorageNotLow = true))
            .addTag(TAG)
            .build()
        workManager.enqueueUniqueWork(TAG, ExistingWorkPolicy.KEEP, request)
    }

    @Suppress("IDENTITY_SENSITIVE_OPERATIONS_WITH_VALUE_TYPE")
    private val servers = WeakHashMap<Long, Streamable.Media.Server>()
    @Suppress("IDENTITY_SENSITIVE_OPERATIONS_WITH_VALUE_TYPE")
    private val mutexes = WeakHashMap<Long, Mutex>()

    suspend fun getServer(
        trackId: Long, download: DownloadEntity
    ): Streamable.Media.Server = mutexes.getOrPut(trackId) { Mutex() }.withLock {
        servers.getOrPut(trackId) {
            val extensionId = download.extensionId
            val extension = extensionLoader.music.getExtensionOrThrow(extensionId)
            val streamable = download.track.getOrThrow()
                .streamables.find { it.id == download.streamableId }!!
            extension.getAs<TrackClient, Streamable.Media.Server> {
                val media =
                    loadStreamableMedia(streamable, true) as Streamable.Media.Server
                media.sources.ifEmpty {
                    throw Exception("${trackId}: No sources found")
                }
                media
            }.getOrThrow()
        }
    }

    fun cancel(trackId: Long) {
        taskManager.remove(trackId)
        scope.launch {
            val entity = dao.getDownloadEntity(trackId) ?: return@launch
            dao.deleteDownloadEntity(entity)
            entity.exceptionFile?.let {
                val file = File(it)
                if (file.exists()) file.delete()
            }
            servers.remove(trackId)
            mutexes.remove(trackId)
        }
    }

    fun restart(trackId: Long) {
        taskManager.remove(trackId)
        scope.launch {
            val download = dao.getDownloadEntity(trackId) ?: return@launch
            dao.insertDownloadEntity(
                download.copy(exceptionFile = null, finalFile = null, fullyDownloaded = false)
            )
            download.exceptionFile?.let {
                val file = File(it)
                if (file.exists()) file.delete()
            }
            servers.remove(trackId)
            mutexes.remove(trackId)
            ensureWorker()
        }
    }

    fun cancelAll() {
        taskManager.removeAll()
        scope.launch {
            val downloads = downloadFlow.first().filter { it.finalFile == null }
            downloads.forEach { download ->
                dao.deleteDownloadEntity(download)
                servers.remove(download.id)
                mutexes.remove(download.id)
            }
        }
    }

    fun deleteDownload(id: String) {
        scope.launch {
            val downloads = downloadFlow.first().filter { it.trackId == id }
            downloads.forEach { download ->
                dao.deleteDownloadEntity(download)
            }
        }
    }

    fun deleteContext(id: String) {
        scope.launch {
            val contexts = contextFlow.first().filter { it.itemId == id }
            contexts.forEach { context ->
                dao.deleteContextEntity(context)
                val downloads = downloadFlow.first().filter {
                    it.contextId == context.id
                }
                downloads.forEach { download ->
                    dao.deleteDownloadEntity(download)
                }
            }
        }
    }

    data class Info(
        val download: DownloadEntity,
        val context: ContextEntity?,
        val workers: List<Pair<TaskType, Progress>>
    )

    val flow = downloadInfoFlow.combine(taskManager.progressFlow) { downloads, info ->
        downloads.map { (dl, context) ->
            val workers = info.filter { it.first.trackId == dl.id }.map { (a, b) -> a.type to b }
            Info(dl, context, workers)
        }.sortedByDescending { it.workers.size }
    }.stateIn(scope, SharingStarted.Eagerly, listOf())

    init {
        scope.launch {
            downloadInfoFlow.map { info ->
                info.filter { it.download.fullyDownloaded }.groupBy {
                    it.context?.id
                }.flatMap { (id, infos) ->
                    if (id == null) infos.mapNotNull {
                        it.download.track.getOrNull()
                            ?.withExtensionId(it.download.extensionId, false)
                    }
                    else listOfNotNull(infos.first().runCatching {
                        unified.db.getPlaylist(context?.mediaItem!!.getOrThrow())
                    }.getOrNull())
                }
            }.collect(unified.downloadFeed)
        }
    }

    companion object {
        private const val TAG = "Downloader"
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\db\DownloadDao.kt ----------
package com.joaomagdaleno.music_hub.download.db

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy.Companion.REPLACE
import androidx.room.Query
import com.joaomagdaleno.music_hub.download.db.models.ContextEntity
import com.joaomagdaleno.music_hub.download.db.models.DownloadEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface DownloadDao {
    @Insert(onConflict = REPLACE)
    suspend fun insertContextEntity(context: ContextEntity): Long

    @Insert(onConflict = REPLACE)
    suspend fun insertDownloadEntity(download: DownloadEntity): Long

    @Query("SELECT * FROM DownloadEntity WHERE id = :trackId")
    suspend fun getDownloadEntity(trackId: Long): DownloadEntity?

    @Query("SELECT * FROM ContextEntity WHERE id = :contextId")
    suspend fun getContextEntity(contextId: Long?): ContextEntity?

    @Query("SELECT * FROM DownloadEntity")
    fun getDownloadsFlow(): Flow<List<DownloadEntity>>

    @Query("SELECT * FROM ContextEntity")
    fun getContextFlow(): Flow<List<ContextEntity>>

    @Delete
    fun deleteDownloadEntity(download: DownloadEntity)

    @Delete
    fun deleteContextEntity(context: ContextEntity)

    @Query("SELECT * FROM DownloadEntity WHERE contextId = :id")
    fun getDownloadsForContext(id: Long?): List<DownloadEntity>
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\db\DownloadDatabase.kt ----------
package com.joaomagdaleno.music_hub.download.db

import android.app.Application
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import com.joaomagdaleno.music_hub.download.db.models.ContextEntity
import com.joaomagdaleno.music_hub.download.db.models.DownloadEntity

@Database(
    entities = [
        ContextEntity::class,
        DownloadEntity::class,
    ],
    version = 8,
    exportSchema = false
)
abstract class DownloadDatabase : RoomDatabase() {
    abstract fun downloadDao(): DownloadDao

    companion object {
        private const val DATABASE_NAME = "download-db"
        fun create(app: Application) = Room.databaseBuilder(
                app, DownloadDatabase::class.java, DATABASE_NAME
            ).fallbackToDestructiveMigration(true).build()
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\db\models\ContextEntity.kt ----------
package com.joaomagdaleno.music_hub.download.db.models

import androidx.room.Entity
import androidx.room.PrimaryKey
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.utils.Serializer.toData

@Entity
data class ContextEntity(
    @PrimaryKey(true)
    val id: Long,
    val itemId: String,
    val data: String,
) {
    val mediaItem by lazy { data.toData<EchoMediaItem>() }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\db\models\DownloadEntity.kt ----------
package com.joaomagdaleno.music_hub.download.db.models

import androidx.room.Entity
import androidx.room.PrimaryKey
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.ui.common.ExceptionUtils
import com.joaomagdaleno.music_hub.utils.Serializer.toData
import kotlinx.serialization.Serializable
import java.io.File

@Entity
@Serializable
data class DownloadEntity(
    @PrimaryKey(true)
    val id: Long,
    val extensionId: String,
    val trackId: String,
    val contextId: Long?,
    val sortOrder: Int? = null,
    val data: String,
    val task: TaskType,
    val loaded: Boolean = false,
    val folderPath: String? = null,
    val streamableId: String? = null,
    val indexesData: String? = null,
    val toMergeFilesData: String? = null,
    val toTagFile: String? = null,
    val finalFile: String? = null,
    val exceptionFile: String? = null,
    val fullyDownloaded: Boolean = false,
) {
    val track by lazy { data.toData<Track>() }
    val indexes by lazy { indexesData?.toData<List<Int>>()?.getOrNull().orEmpty() }
    val toMergeFiles by lazy { toMergeFilesData?.toData<List<String>>()?.getOrNull().orEmpty() }
    val exception by lazy {
        runCatching {
            exceptionFile?.let { File(it) }?.readText()?.toData<ExceptionUtils.Data>()?.getOrThrow()
        }.getOrNull()
    }
    val isFinal by lazy { finalFile != null || exceptionFile != null }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\db\models\TaskType.kt ----------
package com.joaomagdaleno.music_hub.download.db.models

enum class TaskType {
    Loading, Downloading, Merging, Tagging, Saving
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\exceptions\DownloadException.kt ----------
package com.joaomagdaleno.music_hub.download.exceptions

import com.joaomagdaleno.music_hub.download.db.models.DownloadEntity
import com.joaomagdaleno.music_hub.download.db.models.TaskType

data class DownloadException(
    val type: TaskType,
    val downloadEntity: DownloadEntity,
    override val cause: Throwable
) : Exception()

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\exceptions\DownloaderExtensionNotFoundException.kt ----------
package com.joaomagdaleno.music_hub.download.exceptions

class DownloaderExtensionNotFoundException : Exception()

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\tasks\BaseTask.kt ----------
package com.joaomagdaleno.music_hub.download.tasks

import android.Manifest.permission.POST_NOTIFICATIONS
import android.content.Context
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.graphics.drawable.Drawable
import androidx.annotation.OptIn
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat.checkSelfPermission
import androidx.core.graphics.drawable.toBitmap
import androidx.media3.common.util.NotificationUtil
import androidx.media3.common.util.NotificationUtil.createNotificationChannel
import androidx.media3.common.util.UnstableApi
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.clients.DownloadClient
import com.joaomagdaleno.music_hub.common.models.DownloadContext
import com.joaomagdaleno.music_hub.common.models.Progress
import com.joaomagdaleno.music_hub.download.DownloadWorker.Companion.getMainIntent
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.download.db.models.TaskType
import com.joaomagdaleno.music_hub.download.exceptions.DownloadException
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getAs
import com.joaomagdaleno.music_hub.ui.common.ExceptionUtils.toData
import com.joaomagdaleno.music_hub.utils.CoroutineUtils.throttleLatest
import com.joaomagdaleno.music_hub.utils.Serializer.toJson
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.withContext
import java.io.File

abstract class BaseTask(
    private val context: Context,
    val downloader: Downloader,
    open val trackId: Long,
) {
    abstract val type: TaskType
    val progressFlow = MutableStateFlow(Progress())
    val throttledProgressFlow = progressFlow.throttleLatest(500L)
    val running = MutableStateFlow(false)
    suspend fun <T> withDownloadExtension(block: suspend DownloadClient.() -> T) =
        downloader.downloadExtension().getAs<DownloadClient, T> { block() }.getOrThrow()

    val dao = downloader.dao

    suspend fun doWork() = withContext(Dispatchers.IO) {
        running.value = true
        val result = runCatching { work(trackId) }
        val throwable = result.exceptionOrNull()
        val download = dao.getDownloadEntity(trackId)
        if (throwable != null && download != null) {
            val exception = DownloadException(type, download, throwable)
            val exceptionFile = context.exceptionDir().resolve("$trackId.json")
            exceptionFile.writeText(exception.toData(context).toJson())
            dao.insertDownloadEntity(download.copy(exceptionFile = exceptionFile.absolutePath))
        }
        running.value = false
        result
    }

    suspend fun getDownload() = dao.getDownloadEntity(trackId)!!

    suspend fun getDownloadContext() = run {
        val download = getDownload()
        val contextEntity = download.contextId?.let { dao.getContextEntity(it) }
        DownloadContext(
            download.extensionId,
            download.track.getOrThrow(),
            download.sortOrder,
            contextEntity?.mediaItem?.getOrThrow()
        )
    }

    abstract suspend fun work(trackId: Long)

    companion object {
        fun Context.getTitle(type: TaskType, title: String) = when (type) {
            TaskType.Loading -> getString(R.string.loading_x, title)
            TaskType.Downloading -> getString(R.string.downloading_x, title)
            TaskType.Merging -> getString(R.string.merging_x, title)
            TaskType.Tagging -> getString(R.string.tagging_x, title)
            TaskType.Saving -> getString(R.string.saving_x, title)
        }

        private const val DOWNLOAD_CHANNEL_ID = "download_channel"

        fun Context.exceptionDir() = File(filesDir, "download_exceptions").apply { mkdirs() }
    }


    @OptIn(UnstableApi::class)
    fun createCompleteNotification(
        context: Context,
        title: String,
        drawable: Drawable?,
    ) {
        createNotificationChannel(
            context, DOWNLOAD_CHANNEL_ID, R.string.download_complete, 0,
            NotificationUtil.IMPORTANCE_DEFAULT
        )
        val notificationBuilder = NotificationCompat.Builder(context, DOWNLOAD_CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_downloading)
            .setContentTitle(context.getString(R.string.download_complete))
            .setContentText(title)
            .setStyle(
                NotificationCompat.BigPictureStyle().bigLargeIcon(drawable?.toBitmap())
            )
            .setContentIntent(getMainIntent(context))
            .setAutoCancel(true)

        if (checkSelfPermission(context, POST_NOTIFICATIONS) != PERMISSION_GRANTED) return
        NotificationManagerCompat.from(context).notify(
            title.hashCode(),
            notificationBuilder.build()
        )
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\tasks\DownloadingTask.kt ----------
package com.joaomagdaleno.music_hub.download.tasks

import android.content.Context
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.download.db.models.TaskType
import com.joaomagdaleno.music_hub.utils.Serializer.toJson

class DownloadingTask(
    context: Context,
    downloader: Downloader,
    override val trackId: Long,
    val index: Int,
) : BaseTask(context, downloader, trackId) {

    override val type = TaskType.Downloading
    override suspend fun work(trackId: Long) {
        var download = getDownload()
        val server = downloader.getServer(trackId, download)
        val source = server.sources[index]
        val downloadContext = getDownloadContext()
        val file = withDownloadExtension { download(progressFlow, downloadContext, source) }
        download = getDownload()
        download =
            download.copy(toMergeFilesData = (download.toMergeFiles + file.toString()).toJson())
        dao.insertDownloadEntity(download)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\tasks\LoadingTask.kt ----------
package com.joaomagdaleno.music_hub.download.tasks

import android.content.Context
import com.joaomagdaleno.music_hub.common.clients.TrackClient
import com.joaomagdaleno.music_hub.common.models.Progress
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.download.db.models.TaskType
import com.joaomagdaleno.music_hub.download.tasks.TaskManager.Companion.toQueueItem
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getAs
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtensionOrThrow
import com.joaomagdaleno.music_hub.utils.Serializer.toJson

class LoadingTask(
    private val context: Context,
    downloader: Downloader,
    override val trackId: Long,
) : BaseTask(context, downloader, trackId) {

    override val type = TaskType.Loading

    private val manager = downloader.taskManager
    private val extensionsList = downloader.extensionLoader.music

    private val totalSize = 3L

    override suspend fun work(trackId: Long) {
        progressFlow.value = Progress(totalSize, 0)
        var download = dao.getDownloadEntity(trackId)!!
        val extension = extensionsList.getExtensionOrThrow(download.extensionId)
        if (!download.loaded) {
            val track = extension.getAs<TrackClient, Track> {
                loadTrack(download.track.getOrThrow(), true)
            }.getOrThrow()
            track.servers.ifEmpty { throw Exception("${track.title}: No servers found") }
            download = download.copy(data = track.toJson(), loaded = true)
            dao.insertDownloadEntity(download)
        }

        progressFlow.value = Progress(totalSize, 1)
        val downloadContext = getDownloadContext()
        if (download.streamableId == null) {
            val selected = withDownloadExtension { selectServer(downloadContext) }
            download = download.copy(streamableId = selected.id)
            dao.insertDownloadEntity(download)
        }
        progressFlow.value = Progress(totalSize, 2)

        val server = downloader.getServer(trackId, download)

        val indexes = download.indexes.ifEmpty {
            val sources = withDownloadExtension { selectSources(downloadContext, server) }
            sources.map { server.sources.indexOf(it) }
        }
        if (indexes.isEmpty()) throw Exception("No files to download")
        download = download.copy(indexesData = indexes.toJson())
        dao.insertDownloadEntity(download)

        progressFlow.value = Progress(totalSize, 3)

        val requests = indexes.map { index ->
            DownloadingTask(context, downloader, trackId, index)
        }.toQueueItem()
        val mergeRequest = MergingTask(context, downloader, trackId).toQueueItem()
        val taggingRequest = TaggingTask(context, downloader, trackId).toQueueItem()
        val saveToUnified = SaveToUnifiedTask(context, downloader, trackId).toQueueItem()

        manager.enqueue(trackId, listOf(requests, mergeRequest, taggingRequest, saveToUnified))
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\tasks\MergingTask.kt ----------
package com.joaomagdaleno.music_hub.download.tasks

import android.content.Context
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.download.db.models.TaskType
import java.io.File

class MergingTask(
    context: Context,
    downloader: Downloader,
    override val trackId: Long,
) : BaseTask(context, downloader, trackId) {
    override val type = TaskType.Merging

    override suspend fun work(trackId: Long) {
        val downloadContext = getDownloadContext()
        val download = getDownload()
        val file = withDownloadExtension {
            merge(progressFlow, downloadContext, download.toMergeFiles.map { File(it) })
        }
        dao.insertDownloadEntity(download.copy(toTagFile = file.toString()))
    }

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\tasks\SaveToUnifiedTask.kt ----------
package com.joaomagdaleno.music_hub.download.tasks

import android.content.Context
import com.joaomagdaleno.music_hub.common.clients.PlaylistEditClient
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.loadAll
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.download.db.models.TaskType
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getAs
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtensionOrThrow
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.withExtensionId
import com.joaomagdaleno.music_hub.utils.Serializer.toJson
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadDrawable

class SaveToUnifiedTask(
    private val app: Context,
    downloader: Downloader,
    override val trackId: Long,
) : BaseTask(app, downloader, trackId) {

    override val type = TaskType.Saving

    override suspend fun work(trackId: Long) {
        val old = getDownload()
        if (old.finalFile == null) return

        val download = old.copy(
            data = old.track.getOrThrow().withExtensionId(old.extensionId, false).toJson(),
        )
        dao.insertDownloadEntity(download)

        val downloadContext = getDownloadContext()
        val context = downloadContext.context
        val allDownloads = dao.getDownloadsForContext(download.contextId)

        val unifiedExtension =
            downloader.extensionLoader.music.getExtensionOrThrow(UnifiedExtension.metadata.id)

        if (context != null) unifiedExtension.getAs<PlaylistEditClient, Unit> {
            val db = (this as UnifiedExtension).db
            val playlist = db.getOrCreate(app, context)
            val tracks = loadTracks(playlist).loadAll()
            if (allDownloads.all { it.finalFile != null }) {
                removeTracksFromPlaylist(playlist, tracks, tracks.indices.toList())
                val sorted = allDownloads.sortedBy { it.sortOrder }
                addTracksToPlaylist(playlist, listOf(), 0, sorted.map { it.track.getOrThrow() })
            } else addTracksToPlaylist(
                playlist, tracks, tracks.size, listOf(download.track.getOrThrow())
            )
        }.getOrThrow()

        dao.insertDownloadEntity(download.copy(fullyDownloaded = true))

        val item = if (context == null) download.track.getOrThrow() else {
            if (allDownloads.all { it.finalFile != null }) context else null
        } ?: return
        createCompleteNotification(app, item.title, item.cover.loadDrawable(app))
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\tasks\TaggingTask.kt ----------
package com.joaomagdaleno.music_hub.download.tasks

import android.content.Context
import android.media.MediaScannerConnection
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.download.db.models.TaskType
import java.io.File

class TaggingTask(
    private val app: Context,
    downloader: Downloader,
    override val trackId: Long,
) : BaseTask(app, downloader, trackId) {

    override val type = TaskType.Tagging

    override suspend fun work(trackId: Long) {
        val downloadContext = getDownloadContext()
        val download = getDownload()
        val file = withDownloadExtension {
            tag(progressFlow, downloadContext, File(download.toTagFile!!))
        }
        dao.insertDownloadEntity(download.copy(finalFile = file.toString()))
        MediaScannerConnection.scanFile(
            app, arrayOf(file.toString()), null, null
        )
    }

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\download\tasks\TaskManager.kt ----------
package com.joaomagdaleno.music_hub.download.tasks

import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.download.db.models.TaskType
import kotlinx.coroutines.Job
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.channelFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit

class TaskManager(private val downloader: Downloader) {
    val scope = downloader.scope
    private val downloadFlow = downloader.downloadFlow
    private val context = downloader.app.context

    val taskFlow = MutableStateFlow(listOf<TaskItem>())
    private var taskSemaphores = TaskType.entries.associateWith { Semaphore(2) }
    fun setConcurrency(limit: Int) {
        taskSemaphores = TaskType.entries.associateWith { Semaphore(limit) }
    }

    val progressFlow = channelFlow {
        taskFlow.map { items ->
            items.flatMap { it.queue }.flatMap { it.tasks }
        }.collectLatest { tasks ->
            if (tasks.isEmpty()) send(emptyArray())
            else combine(tasks.map { it.running }) { _ ->
                tasks.filter { it.running.value }.map { task ->
                    task.throttledProgressFlow.map { task to it }
                }
            }.collectLatest { progressFlows ->
                if (progressFlows.isEmpty()) send(emptyArray())
                else combine(progressFlows) { it }.collectLatest { send(it) }
            }
        }
    }.stateIn(scope, SharingStarted.Eagerly, arrayOf())

    data class TaskItem(val trackId: Long, val queue: List<QueueItem>, val job: Job)
    data class QueueItem(val tasks: List<BaseTask>)

    companion object {
        fun BaseTask.toQueueItem() = QueueItem(listOf(this))
        fun List<BaseTask>.toQueueItem() = QueueItem(this)
    }

    fun enqueue(trackId: Long, items: List<QueueItem>) {
        val list = taskFlow.value.toMutableList()
        list.add(TaskItem(trackId, items, scope.launch {
            runCatching {
                items.onEach { item ->
                    val results = item.tasks.map { worker ->
                        scope.async {
                            taskSemaphores[worker.type]!!.withPermit { worker.doWork() }
                        }
                    }.awaitAll()
                    results.onEach { it.getOrThrow() }
                }
            }
            val new = taskFlow.value.toMutableList()
            new.removeAll { it.queue == items }
            taskFlow.value = new
        }))
        taskFlow.value = list
    }

    private fun enqueueLoadingWork(trackId: Long) {
        val loadingWorker = LoadingTask(context, downloader, trackId)
        enqueue(trackId, listOf(QueueItem(listOf(loadingWorker))))
    }

    suspend fun awaitCompletion() {
        downloadFlow.map { entities -> entities.filter { !it.isFinal } }.first { entities ->
            val works = taskFlow.value.map { it.trackId }
            val notStarted = entities.filter { !works.contains(it.id) }
            notStarted.forEach { enqueueLoadingWork(it.id) }
            entities.isEmpty()
        }
    }

    fun remove(trackId: Long) {
        val list = taskFlow.value.toMutableList()
        val works = list.filter { it.trackId == trackId }
        works.forEach { it.job.cancel() }
        list.removeAll(works)
        taskFlow.value = list
    }

    fun removeAll() {
        taskFlow.value.forEach { it.job.cancel() }
        taskFlow.value = listOf()
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\download\DownloadFragment.kt ----------
package com.joaomagdaleno.music_hub.ui.download

import android.os.Bundle
import android.view.View
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.paging.LoadState
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.Feed
import com.joaomagdaleno.music_hub.databinding.FragmentDownloadBinding
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.getFeed
import com.joaomagdaleno.music_hub.ui.common.ExceptionFragment
import com.joaomagdaleno.music_hub.ui.common.ExceptionUtils
import com.joaomagdaleno.music_hub.ui.common.FragmentUtils.openFragment
import com.joaomagdaleno.music_hub.ui.common.GridAdapter
import com.joaomagdaleno.music_hub.ui.common.GridAdapter.Companion.configureGridLayout
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyBackPressCallback
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyContentInsets
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyFabInsets
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyInsets
import com.joaomagdaleno.music_hub.ui.download.DownloadsAdapter.Companion.toItems
import com.joaomagdaleno.music_hub.ui.feed.FeedAdapter.Companion.getFeedAdapter
import com.joaomagdaleno.music_hub.ui.feed.FeedAdapter.Companion.getTouchHelper
import com.joaomagdaleno.music_hub.ui.feed.FeedClickListener.Companion.getFeedListener
import com.joaomagdaleno.music_hub.ui.feed.FeedData
import com.joaomagdaleno.music_hub.ui.feed.FeedViewModel
import com.joaomagdaleno.music_hub.ui.media.LineAdapter
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.setupTransition
import com.joaomagdaleno.music_hub.utils.ui.FastScrollerHelper
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.configureAppBar
import org.koin.androidx.viewmodel.ext.android.viewModel

class DownloadFragment : Fragment(R.layout.fragment_download) {

    private val vm by viewModel<DownloadViewModel>()
    private val downloadsAdapter by lazy {
        DownloadsAdapter(object : DownloadsAdapter.Listener {
            override fun onCancel(trackId: Long) = vm.cancel(trackId)
            override fun onRestart(trackId: Long) = vm.restart(trackId)
            override fun onExceptionClicked(data: ExceptionUtils.Data) = requireActivity()
                .openFragment<ExceptionFragment>(null, ExceptionFragment.getBundle(data))
        })
    }

    private val feedViewModel by viewModel<FeedViewModel>()
    private val feedData by lazy {
        val flow = vm.downloader.unified.downloadFeed
        feedViewModel.getFeedData(
            "downloads", Feed.Buttons(), false, flow
        ) {
            val feed = requireContext().getFeed(flow.value)
            FeedData.State(UnifiedExtension.metadata.id, null, feed)
        }
    }

    private val feedListener by lazy { getFeedListener() }
    private val feedAdapter by lazy {
        getFeedAdapter(feedData, feedListener)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val binding = FragmentDownloadBinding.bind(view)
        setupTransition(view)
        applyBackPressCallback()
        binding.appBarLayout.configureAppBar { offset ->
            binding.toolbarOutline.alpha = offset
            binding.iconContainer.alpha = 1 - offset
        }
        binding.toolBar.setNavigationOnClickListener {
            parentFragmentManager.popBackStack()
        }
        applyInsets {
            binding.recyclerView.applyContentInsets(it, 20, 8, 72)
            binding.fabContainer.applyFabInsets(it, systemInsets.value)
        }
        FastScrollerHelper.applyTo(binding.recyclerView)
        val lineAdapter = LineAdapter()
        binding.fabCancel.setOnClickListener {
            vm.cancelAll()
        }
        binding.recyclerView.itemAnimator = null
        getTouchHelper(feedListener).attachToRecyclerView(binding.recyclerView)
        configureGridLayout(
            binding.recyclerView,
            GridAdapter.Concat(
                downloadsAdapter,
                lineAdapter,
                feedAdapter.withLoading(this)
            )
        )
        observe(vm.flow) { infos ->
            binding.fabCancel.isVisible = infos.any { it.download.finalFile == null }
            lineAdapter.loadState = if (infos.isNotEmpty()) LoadState.Loading
            else LoadState.NotLoading(false)
            downloadsAdapter.submitList(infos.toItems(vm.extensions.music.value))
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\download\DownloadViewModel.kt ----------
package com.joaomagdaleno.music_hub.ui.download

import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.clients.DownloadClient
import com.joaomagdaleno.music_hub.common.models.DownloadContext
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Message
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getIf
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.isClient
import com.joaomagdaleno.music_hub.ui.common.FragmentUtils.openFragment
import com.joaomagdaleno.music_hub.ui.extensions.add.ExtensionsAddBottomSheet
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.SharingStarted.Companion.Eagerly
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.mapLatest
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class DownloadViewModel(
    app: App,
    extensionLoader: ExtensionLoader,
    val downloader: Downloader,
) : ViewModel() {

    private val app = app.context
    private val messageFlow = app.messageFlow
    private val throwableFlow = app.throwFlow

    @OptIn(ExperimentalCoroutinesApi::class)
    val downloadExtensions = extensionLoader.misc.mapLatest { list ->
        list.filter { it.isEnabled && it.isClient<DownloadClient>() }
    }.stateIn(viewModelScope, Eagerly, null)

    val extensions = extensionLoader

    val flow = downloader.flow

    fun addToDownload(
        activity: FragmentActivity,
        extensionId: String,
        item: EchoMediaItem,
        context: EchoMediaItem?,
    ) = viewModelScope.launch(Dispatchers.IO) {
        with(activity) {
            messageFlow.emit(Message(getString(R.string.downloading_x, item.title)))
            val downloadExt = downloadExtensions.first { it != null }?.firstOrNull()
                ?: return@with messageFlow.emit(
                    Message(
                        app.getString(R.string.no_download_extension),
                        Message.Action(getString(R.string.add_extension)) {
                            ExtensionsAddBottomSheet().show(supportFragmentManager, null)
                        }
                    )
                )

            val downloads =
                downloadExt.getIf<DownloadClient, List<DownloadContext>>(throwableFlow) {
                    getDownloadTracks(extensionId, item, context)
                } ?: return@with

            if (downloads.isEmpty()) return@with messageFlow.emit(
                Message(app.getString(R.string.nothing_to_download_in_x, item.title))
            )

            downloader.add(downloads)
            messageFlow.emit(
                Message(
                    getString(R.string.download_started),
                    Message.Action(getString(R.string.view)) {
                        openFragment<DownloadFragment>()
                    }
                )
            )
        }
    }

    fun cancel(trackId: Long) {
        downloader.cancel(trackId)
    }

    fun restart(trackId: Long) {
        downloader.restart(trackId)
    }

    fun cancelAll() {
        downloader.cancelAll()
    }

    fun deleteDownload(item: EchoMediaItem) {
        when (item) {
            is Track -> downloader.deleteDownload(item.id)
            else -> downloader.deleteContext(item.id)
        }
        viewModelScope.launch {
            messageFlow.emit(
                Message(app.getString(R.string.removed_x_from_downloads, item.title))
            )
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\download\DownloadsAdapter.kt ----------
package com.joaomagdaleno.music_hub.ui.download

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.recyclerview.widget.DiffUtil
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.models.Progress
import com.joaomagdaleno.music_hub.databinding.ItemDownloadBinding
import com.joaomagdaleno.music_hub.databinding.ItemDownloadTaskBinding
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.download.db.models.ContextEntity
import com.joaomagdaleno.music_hub.download.db.models.DownloadEntity
import com.joaomagdaleno.music_hub.download.db.models.TaskType
import com.joaomagdaleno.music_hub.download.tasks.BaseTask.Companion.getTitle
import com.joaomagdaleno.music_hub.ui.common.ExceptionUtils
import com.joaomagdaleno.music_hub.ui.common.GridAdapter
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadAsCircle
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadInto
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimListAdapter
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimViewHolder

class DownloadsAdapter(
    private val listener: Listener,
) : ScrollAnimListAdapter<DownloadsAdapter.Item, DownloadsAdapter.ViewHolder>(
    object : DiffUtil.ItemCallback<Item>() {
        override fun areContentsTheSame(oldItem: Item, newItem: Item) = oldItem == newItem
        override fun areItemsTheSame(oldItem: Item, newItem: Item): Boolean {
            return when (oldItem) {
                is Download -> if (newItem !is Download) false
                else oldItem.downloadEntity.id == newItem.downloadEntity.id

                is Task -> if (newItem !is Task) false
                else oldItem.id == newItem.id
            }
        }
    }
), GridAdapter {

    interface Listener {
        fun onExceptionClicked(data: ExceptionUtils.Data)
        fun onCancel(trackId: Long)
        fun onRestart(trackId: Long)
    }

    sealed class ViewHolder(itemView: View) : ScrollAnimViewHolder(itemView)

    class DownloadViewHolder(
        parent: ViewGroup,
        private val listener: Listener,
        private val binding: ItemDownloadBinding = ItemDownloadBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        ),
    ) : ViewHolder(binding.root) {
        init {
            binding.imageView.clipToOutline = true
        }

        fun bind(item: Download) {
            val entity = item.downloadEntity
            binding.apply {
                val track = entity.track.getOrNull()
                title.text = track?.title
                track?.cover.loadInto(imageView, R.drawable.art_music)
                item.extension?.metadata?.icon?.loadAsCircle(
                    extensionIcon, R.drawable.ic_extension
                ) {
                    extensionIcon.setImageDrawable(it)
                }
                val sub = item.context?.mediaItem?.getOrNull()?.title
                subtitle.text = sub
                subtitle.isVisible = !sub.isNullOrEmpty()

                exception.text = entity.exception?.title
                exception.isVisible = exception.text.isNotEmpty()

                remove.setOnClickListener {
                    listener.onCancel(entity.id)
                }

                retry.isVisible = entity.exception != null
                retry.setOnClickListener {
                    listener.onRestart(entity.id)
                }
                root.setOnClickListener {
                    val data = entity.exception ?: return@setOnClickListener
                    listener.onExceptionClicked(data)
                }
            }
        }
    }

    class TaskViewHolder(
        parent: ViewGroup,
        private val binding: ItemDownloadTaskBinding = ItemDownloadTaskBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        ),
    ) : ViewHolder(binding.root) {
        fun bind(item: Task) = binding.apply {
            progressBar.isIndeterminate = item.progress.size == 0L
            progressBar.max = item.progress.size.toInt()
            progressBar.progress = item.progress.progress.toInt()
            subtitle.text = item.progress.toText()
            title.text = root.context.run {
                getTitle(item.taskType, getString(R.string.download))
            }
        }
    }


    sealed interface Item
    data class Download(
        val context: ContextEntity?,
        val downloadEntity: DownloadEntity,
        val extension: Extension<*>?,
    ) : Item

    data class Task(val taskType: TaskType, val progress: Progress, val id: Long) : Item

    override fun getItemViewType(position: Int): Int {
        return when (getItem(position)) {
            is Download -> 0
            is Task -> 1
        }
    }

    override val adapter = this
    override fun getSpanSize(position: Int, width: Int, count: Int) = 2.coerceAtLeast(count)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) = when (viewType) {
        0 -> DownloadViewHolder(parent, listener)
        1 -> TaskViewHolder(parent)
        else -> throw IllegalArgumentException("Invalid view type")
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        super.onBindViewHolder(holder, position)
        when (holder) {
            is DownloadViewHolder -> {
                val item = getItem(position) as Download
                holder.bind(item)
            }

            is TaskViewHolder -> {
                val item = getItem(position) as Task
                holder.bind(item)
            }
        }
    }


    companion object {
        fun List<Downloader.Info>.toItems(extensions: List<Extension<*>>) = filter {
            it.download.finalFile == null
        }.flatMap { info ->
            val download = info.download
            val extension = extensions.find { it.id == download.extensionId }
            listOf(Download(info.context, download, extension)) + info.workers.map {
                Task(it.first, it.second, download.id)
            }
        }

        private val SPEED_UNITS = arrayOf("", "KB", "MB", "GB")
        fun Progress.toText() = buildString {
            if (size > 0) append("%.2f%%  ".format(progress.toFloat() / size * 100))
            append(
                if (size > 0) "${convertBytes(progress)} / ${convertBytes(size)}"
                else convertBytes(progress)
            )
            if (speed > 0) append("  ${convertBytes(speed)}/s")
        }

        private fun convertBytes(bytes: Long): String {
            var value = bytes.toFloat()
            var unitIndex = 0

            while (value >= 500 && unitIndex < SPEED_UNITS.size - 1) {
                value /= 1024
                unitIndex++
            }
            return "%.2f %s".format(value, SPEED_UNITS[unitIndex])
        }
    }
}

