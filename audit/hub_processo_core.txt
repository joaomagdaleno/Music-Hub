================================================================================
PROCESS AUDIT: hub_processo_core.txt
DATE: 2026-01-08 15:23:52
FILE COUNT: 79
================================================================================

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\MainActivity.kt ----------
package com.joaomagdaleno.music_hub

import android.content.Context
import android.graphics.Color.TRANSPARENT
import android.os.Bundle
import androidx.activity.SystemBarStyle
import androidx.activity.enableEdgeToEdge
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.app.AppCompatDelegate
import androidx.core.content.ContextCompat
import androidx.fragment.app.add
import androidx.fragment.app.commit
import com.google.android.material.color.DynamicColors
import com.google.android.material.color.DynamicColorsOptions
import com.google.android.material.navigation.NavigationBarView
import com.joaomagdaleno.music_hub.databinding.ActivityMainBinding
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.ui.common.ExceptionUtils.setupExceptionHandler
import com.joaomagdaleno.music_hub.ui.common.FragmentUtils.setupIntents
import com.joaomagdaleno.music_hub.ui.common.SnackBarHandler.Companion.setupSnackBar
import com.joaomagdaleno.music_hub.ui.common.UiViewModel
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.setupNavBarAndInsets
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.setupPlayerBehavior
import com.joaomagdaleno.music_hub.ui.extensions.ExtensionsViewModel.Companion.configureExtensionsUpdater
import com.joaomagdaleno.music_hub.ui.main.MainFragment
import com.joaomagdaleno.music_hub.ui.player.PlayerFragment
import com.joaomagdaleno.music_hub.ui.player.PlayerFragment.Companion.PLAYER_COLOR
import com.joaomagdaleno.music_hub.utils.ContextUtils.getSettings
import com.joaomagdaleno.music_hub.utils.PermsUtils.checkAppPermissions
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.isNightMode
import org.koin.android.ext.android.inject
import org.koin.androidx.viewmodel.ext.android.viewModel

open class MainActivity : AppCompatActivity() {

    class Back : MainActivity()

    val binding by lazy { ActivityMainBinding.inflate(layoutInflater) }
    private val uiViewModel by viewModel<UiViewModel>()
    private val extensionLoader by inject<ExtensionLoader>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setTheme(getAppTheme())
        DynamicColors.applyToActivityIfAvailable(
            this, applyUiChanges(this, uiViewModel)
        )

        setContentView(binding.root)

        enableEdgeToEdge(
            SystemBarStyle.auto(TRANSPARENT, TRANSPARENT),
            if (isNightMode()) SystemBarStyle.dark(TRANSPARENT)
            else SystemBarStyle.light(TRANSPARENT, TRANSPARENT)
        )

        setupNavBarAndInsets(uiViewModel, binding.root, binding.navView as NavigationBarView)
        setupPlayerBehavior(uiViewModel, binding.playerFragmentContainer)
        setupExceptionHandler(setupSnackBar(uiViewModel, binding.root))
        checkAppPermissions { extensionLoader.setPermGranted() }
        configureExtensionsUpdater()
        supportFragmentManager.commit {
            if (savedInstanceState != null) return@commit
            add<MainFragment>(R.id.navHostFragment, "main")
            add<PlayerFragment>(R.id.playerFragmentContainer, "player")
        }
        setupIntents(uiViewModel)
    }

    companion object {
        const val THEME_KEY = "theme"
        const val AMOLED_KEY = "amoled"
        const val BIG_COVER = "big_cover"
        const val CUSTOM_THEME_KEY = "custom_theme"
        const val COLOR_KEY = "color"

        fun Context.getAppTheme(): Int {
            val settings = getSettings()
            val bigCover = settings.getBoolean(BIG_COVER, false)
            val amoled = settings.getBoolean(AMOLED_KEY, false)
            return when {
                amoled && bigCover -> R.style.AmoledBigCover
                amoled -> R.style.Amoled
                bigCover -> R.style.BigCover
                else -> R.style.Default
            }
        }

        fun Context.defaultColor() =
            ContextCompat.getColor(this, R.color.app_color)

        fun Context.isAmoled() = getSettings().getBoolean(AMOLED_KEY, false)

        fun applyUiChanges(context: Context, uiViewModel: UiViewModel): DynamicColorsOptions {
            val settings = context.getSettings()
            val mode = when (settings.getString(THEME_KEY, "system")) {
                "light" -> AppCompatDelegate.MODE_NIGHT_NO
                "dark" -> AppCompatDelegate.MODE_NIGHT_YES
                else -> AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM
            }
            AppCompatDelegate.setDefaultNightMode(mode)

            val custom = settings.getBoolean(CUSTOM_THEME_KEY, true)
            val color = if (custom) settings.getInt(COLOR_KEY, context.defaultColor()) else null
            val playerColor = settings.getBoolean(PLAYER_COLOR, false)
            val customColor = uiViewModel.playerColors.value?.accent?.takeIf { playerColor }

            val builder = DynamicColorsOptions.Builder()
            (customColor ?: color)?.let { builder.setContentBasedSource(it) }
            return builder.build()
        }

        const val BACK_ANIM = "back_anim"
        fun Context.getMainActivity() = if (getSettings().getBoolean(BACK_ANIM, false))
            Back::class.java else MainActivity::class.java
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\MainApplication.kt ----------
package com.joaomagdaleno.music_hub

import android.app.Application
import android.content.Context
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.os.Build
import android.os.Looper
import androidx.appcompat.app.AppCompatDelegate
import androidx.core.content.edit
import androidx.core.os.LocaleListCompat
import coil3.ImageLoader
import coil3.PlatformContext
import coil3.SingletonImageLoader
import coil3.disk.DiskCache
import coil3.disk.directory
import coil3.memory.MemoryCache
import coil3.request.allowHardware
import coil3.request.crossfade
import com.joaomagdaleno.music_hub.di.DI
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.utils.AppShortcuts.configureAppShortcuts
import com.joaomagdaleno.music_hub.utils.CoroutineUtils
import org.koin.android.ext.android.inject
import org.koin.android.ext.koin.androidContext
import org.koin.androidx.workmanager.koin.workManagerFactory
import org.koin.androix.startup.KoinStartup
import org.koin.core.annotation.KoinExperimentalAPI
import org.koin.dsl.koinConfiguration

@OptIn(KoinExperimentalAPI::class)
class MainApplication : Application(), KoinStartup, SingletonImageLoader.Factory {

    override fun onKoinStartup() = koinConfiguration {
        androidContext(this@MainApplication)
        modules(DI.appModule)
        workManagerFactory()
    }

    private val settings by inject<SharedPreferences>()
    private val extensionLoader by inject<ExtensionLoader>()

    override fun onCreate() {
        super.onCreate()
        CoroutineUtils.setDebug()
        applyLocale(settings)
        configureAppShortcuts(extensionLoader)
    }

    override fun newImageLoader(context: PlatformContext): ImageLoader {
        return ImageLoader.Builder(context)
            .memoryCache {
                MemoryCache.Builder()
                    .maxSizePercent(context, 0.25)
                    .build()
            }
            .diskCache {
                DiskCache.Builder()
                    .directory(cacheDir.resolve("image-cache"))
                    .maxSizeBytes(1024 * 1024 * 100) // 100MB
                    .build()
            }
            .allowHardware(false)
            .crossfade(true)
            .build()
    }

    override fun getPackageName(): String {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) runCatching {
            val stackTrace = Looper.getMainLooper().thread.stackTrace
            val isChromiumCall = stackTrace.any { trace ->
                trace.className.equals(CLASS_NAME, ignoreCase = true)
                        && FUNCTION_SET.any { trace.methodName.equals(it, ignoreCase = true) }
            }
            if (isChromiumCall) return spoofedPackageName(applicationContext)
        }
        return super.getPackageName()
    }

    private fun spoofedPackageName(context: Context): String {
        return runCatching {
            context.packageManager.getPackageInfo(CHROME_PACKAGE, PackageManager.GET_META_DATA)
            CHROME_PACKAGE
        }.getOrElse {
            SYSTEM_SETTINGS_PACKAGE
        }
    }

    companion object {
        private const val CHROME_PACKAGE = "com.android.chrome"
        private const val SYSTEM_SETTINGS_PACKAGE = "com.android.settings"
        private const val CLASS_NAME = "org.chromium.base.BuildInfo"
        private val FUNCTION_SET = setOf("getAll", "getPackageName", "<init>")

        fun getCurrentLanguage(sharedPref: SharedPreferences) =
            sharedPref.getString("language", null) ?: "system"

        fun setCurrentLanguage(sharedPref: SharedPreferences, locale: String?) {
            sharedPref.edit { putString("language", locale) }
            applyLocale(sharedPref)
        }

        fun applyLocale(sharedPref: SharedPreferences) {
            val value = sharedPref.getString("language", null) ?: "system"
            val locale = if (value == "system") LocaleListCompat.getEmptyLocaleList()
            else LocaleListCompat.forLanguageTags(value)
            AppCompatDelegate.setApplicationLocales(locale)
        }

        val languages = mapOf(
            "ar" to "العربية",
            "as" to "Assamese",
            "be" to "Беларуская",
            "bn" to "বাংলা",
            "ca" to "Català",
            "de" to "Deutsch",
            "es" to "Español",
            "fa" to "فارسی",
            "fr" to "Français",
            "en" to "English",
            "hi" to "हिन्दी",
            "hng" to "Hinglish",
            "hu" to "Magyar",
            "in" to "Bahasa Indonesia",
            "it" to "Italiano",
            "iw" to "עברית",
            "ja" to "日本語",
            "ko" to "한국어",
            "lv" to "Latviski",
            "ms" to "Bahasa Melayu",
            "pl" to "Polski",
            "pt" to "Português",
            "pt-rBR" to "Português (Brasil)",
            "ru" to "Русский",
            "sa" to "संस्कृतम्",
            "si" to "සිංහල",
            "sk" to "Slovenčina",
            "sr" to "Српски",
            "ta" to "தமிழ்",
            "th" to "ไทย",
            "tl" to "Filipino",
            "tr" to "Türkçe",
            "uk" to "Українська",
            "vi" to "Tiếng Việt",
            "zh-rCN" to "中文 (简体)",
            "zh-rTW" to "中文 (繁體)"
        )
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\di\App.kt ----------
package com.joaomagdaleno.music_hub.di

import android.app.Application
import android.content.Context.CONNECTIVITY_SERVICE
import android.content.SharedPreferences
import android.net.ConnectivityManager
import android.net.Network
import com.mayakapps.kache.FileKache
import com.mayakapps.kache.KacheStrategy
import com.joaomagdaleno.music_hub.common.models.Message
import com.joaomagdaleno.music_hub.common.models.NetworkConnection
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.CoroutineStart
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch

data class App(
    val context: Application,
    val settings: SharedPreferences,
) {
    val throwFlow = MutableSharedFlow<Throwable>()
    val messageFlow = MutableSharedFlow<Message>()
    val scope = CoroutineScope(Dispatchers.IO)

    private suspend fun getCache() = FileKache(
        context.cacheDir.resolve("kache").toString(),
        50 * 1024 * 1024
    ) {
        strategy = KacheStrategy.LRU
    }

    val fileCache = scope.async(Dispatchers.IO, CoroutineStart.LAZY) {
        runCatching { getCache() }.getOrElse {
            context.cacheDir.resolve("kache").deleteRecursively()
            getCache()
        }
    }

    private val _networkFlow = MutableStateFlow(NetworkConnection.NotConnected)
    val networkFlow = _networkFlow.asStateFlow()
    val isUnmetered get() = networkFlow.value == NetworkConnection.Unmetered

    init {
        scope.launch {
            throwFlow.collectLatest {
                it.printStackTrace()
            }
        }
        val connectivityManager =
            context.getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager
        val networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                val isMetered = connectivityManager.isActiveNetworkMetered
                _networkFlow.value = if (isMetered) NetworkConnection.Metered
                else NetworkConnection.Unmetered
            }

            override fun onLost(network: Network) {
                _networkFlow.value = NetworkConnection.NotConnected
            }
        }
        connectivityManager.registerDefaultNetworkCallback(networkCallback)
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\di\DI.kt ----------
package com.joaomagdaleno.music_hub.di

import com.joaomagdaleno.music_hub.download.DownloadWorker
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.download.db.DownloadDatabase
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.builtin.internal.InternalDownloadSource
import com.joaomagdaleno.music_hub.extensions.builtin.internal.InternalMusicSource
import com.joaomagdaleno.music_hub.playback.PlayerService
import com.joaomagdaleno.music_hub.playback.PlayerState
import com.joaomagdaleno.music_hub.ui.common.SnackBarHandler
import com.joaomagdaleno.music_hub.ui.common.UiViewModel
import com.joaomagdaleno.music_hub.ui.download.DownloadViewModel
import com.joaomagdaleno.music_hub.ui.extensions.ExtensionInfoViewModel
import com.joaomagdaleno.music_hub.ui.extensions.ExtensionsViewModel
import com.joaomagdaleno.music_hub.ui.extensions.add.AddViewModel
import com.joaomagdaleno.music_hub.ui.extensions.login.LoginUserListViewModel
import com.joaomagdaleno.music_hub.ui.extensions.login.LoginViewModel
import com.joaomagdaleno.music_hub.ui.feed.FeedViewModel
import com.joaomagdaleno.music_hub.ui.main.search.SearchViewModel
import com.joaomagdaleno.music_hub.ui.media.MediaViewModel
import com.joaomagdaleno.music_hub.ui.player.PlayerViewModel
import com.joaomagdaleno.music_hub.ui.player.more.info.TrackInfoViewModel
import com.joaomagdaleno.music_hub.ui.player.more.lyrics.LyricsViewModel
import com.joaomagdaleno.music_hub.ui.playlist.create.CreatePlaylistViewModel
import com.joaomagdaleno.music_hub.ui.playlist.delete.DeletePlaylistViewModel
import com.joaomagdaleno.music_hub.ui.playlist.edit.EditPlaylistViewModel
import com.joaomagdaleno.music_hub.ui.playlist.save.SaveToPlaylistViewModel
import com.joaomagdaleno.music_hub.utils.ContextUtils.getSettings
import org.koin.android.ext.koin.androidApplication
import org.koin.androidx.workmanager.dsl.workerOf
import org.koin.core.module.dsl.singleOf
import org.koin.core.module.dsl.viewModelOf
import org.koin.dsl.module

object DI {

    private val baseModule = module {
        single { androidApplication().getSettings() }
        singleOf(::App)
        singleOf(::InternalMusicSource)
        single { InternalDownloadSource(androidApplication()) }
    }

    private val extensionModule = module {
        includes(baseModule)
        singleOf(::ExtensionLoader)
    }

    private val downloadModule = module {
        includes(extensionModule)
        singleOf(DownloadDatabase::create)
        singleOf(::Downloader)
        workerOf(::DownloadWorker)
    }

    private val playerModule = module {
        includes(extensionModule)
        singleOf(PlayerService::getCache)
        single { PlayerState() }
    }

    private val uiModules = module {
        singleOf(::SnackBarHandler)
        viewModelOf(::UiViewModel)

        viewModelOf(::PlayerViewModel)
        viewModelOf(::LyricsViewModel)
        viewModelOf(::TrackInfoViewModel)

        viewModelOf(::ExtensionsViewModel)
        viewModelOf(::ExtensionInfoViewModel)
        viewModelOf(::LoginUserListViewModel)
        viewModelOf(::AddViewModel)
        viewModelOf(::LoginViewModel)

        viewModelOf(::FeedViewModel)
        viewModelOf(::SearchViewModel)
        viewModelOf(::MediaViewModel)

        viewModelOf(::CreatePlaylistViewModel)
        viewModelOf(::DeletePlaylistViewModel)
        viewModelOf(::SaveToPlaylistViewModel)
        viewModelOf(::EditPlaylistViewModel)

        viewModelOf(::DownloadViewModel)
    }

    val appModule = module {
        includes(baseModule)
        includes(extensionModule)
        includes(playerModule)
        includes(downloadModule)
        includes(uiModules)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\ExtensionLoader.kt ----------
package com.joaomagdaleno.music_hub.extensions

import androidx.annotation.OptIn
import androidx.core.content.edit
import androidx.media3.common.util.UnstableApi
import androidx.media3.datasource.cache.SimpleCache
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.LyricsExtension
import com.joaomagdaleno.music_hub.common.MiscExtension
import com.joaomagdaleno.music_hub.common.MusicExtension
import com.joaomagdaleno.music_hub.common.TrackerExtension
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.clients.LoginClient
import com.joaomagdaleno.music_hub.common.helpers.Injectable
import com.joaomagdaleno.music_hub.common.helpers.WebViewClient
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.Metadata
import com.joaomagdaleno.music_hub.common.providers.GlobalSettingsProvider
import com.joaomagdaleno.music_hub.common.providers.LyricsExtensionsProvider
import com.joaomagdaleno.music_hub.common.providers.MessageFlowProvider
import com.joaomagdaleno.music_hub.common.providers.MetadataProvider
import com.joaomagdaleno.music_hub.common.providers.MiscExtensionsProvider
import com.joaomagdaleno.music_hub.common.providers.MusicExtensionsProvider
import com.joaomagdaleno.music_hub.common.providers.NetworkConnectionProvider
import com.joaomagdaleno.music_hub.common.providers.TrackerExtensionsProvider
import com.joaomagdaleno.music_hub.common.providers.WebViewClientProvider
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.get
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getOrThrow
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.inject
import com.joaomagdaleno.music_hub.extensions.builtin.internal.InternalDownloadSource
import com.joaomagdaleno.music_hub.extensions.builtin.internal.InternalMusicSource
import com.joaomagdaleno.music_hub.extensions.builtin.offline.OfflineExtension
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension
import com.joaomagdaleno.music_hub.extensions.db.ExtensionDatabase
import com.joaomagdaleno.music_hub.extensions.db.models.CurrentUser
import com.joaomagdaleno.music_hub.extensions.exceptions.AppException.Companion.toAppException
import com.joaomagdaleno.music_hub.extensions.exceptions.RequiredExtensionsMissingException
import com.joaomagdaleno.music_hub.extensions.repo.CombinedRepository
import com.joaomagdaleno.music_hub.extensions.repo.ExtensionParser
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import java.io.File

@OptIn(UnstableApi::class)
class ExtensionLoader(
    val app: App,
    val cache: SimpleCache,
    val internalSource: InternalMusicSource,
    val internalDownloadSource: InternalDownloadSource,
) {
    val parser = ExtensionParser(app.context)
    val scope = CoroutineScope(Dispatchers.IO)
    val db = ExtensionDatabase.create(app.context)

    private var permGrantedFlow = false
    fun setPermGranted() {
        if (permGrantedFlow) return
        permGrantedFlow = true
        val id = current.value?.id
        if (id == OfflineExtension.metadata.id || id == UnifiedExtension.metadata.id) {
            current.value = null
            scope.launch {
                delay(1)
                setCurrentExtension()
            }
        }
    }

    val unified = lazy { UnifiedExtension(app, cache) }
    val fileIgnoreFlow = MutableSharedFlow<File?>()
    private val repository = CombinedRepository(
        scope, app.context, fileIgnoreFlow, parser,
        UnifiedExtension.metadata to unified,
        InternalMusicSource.metadata to lazy { internalSource },
        InternalDownloadSource.metadata to lazy { internalDownloadSource },
        OfflineExtension.metadata to lazy { OfflineExtension(app.context) },
//        TestExtension.metadata to lazy { TestExtension() },
//        DownloadExtension.metadata to lazy { DownloadExtension(app.context) }
//        TrackerTestExtension.metadata to Injectable { TrackerTestExtension() },
    )

    private val settings = app.settings
    val priorityMap = ExtensionType.entries.associateWith {
        val key = it.priorityKey()
        val list = settings.getString(key, null).orEmpty().split(',')
        MutableStateFlow(list)
    }

    val current = MutableStateFlow<MusicExtension?>(null)
    private fun setCurrentExtension() {
        val last = settings.getString(LAST_EXTENSION_KEY, null) ?: InternalMusicSource.INTERNAL_ID
        val list = music.value
        val extension = list.find { it.id == last && it.isEnabled }
            ?: list.find { it.id == InternalMusicSource.INTERNAL_ID && it.isEnabled }
            ?: list.firstOrNull { it.isEnabled }
            ?: return
        setupMusicExtension(extension, false)
    }

    fun setupMusicExtension(extension: MusicExtension, manual: Boolean) {
        if (manual) settings.edit { putString(LAST_EXTENSION_KEY, extension.id) }
        current.value = extension
        scope.launch {
            extension.get { onExtensionSelected() }.getOrThrow(app.throwFlow)
        }
    }

    private val injected = repository.flow.map { list ->
        list?.groupBy { it.getOrNull()?.first?.run { type to id } }?.map { entry ->
            entry.value.minBy { it.getOrNull()?.first?.importType?.ordinal ?: Int.MAX_VALUE }
        }.orEmpty()
    }.combine(db.extensionEnabledFlow) { list, enabledList ->
        val enabledMap = enabledList.associate { (it.type to it.id) to it.enabled }
        list.map { result ->
            result.mapCatching { (metadata, injectable) ->
                val key = metadata.run { type to id }
                val isEnabled = enabledMap[key] ?: metadata.isEnabled
                metadata.copy(isEnabled = isEnabled) to injectable
            }
        }
    }.map { list ->
        list.map { result ->
            result.map {
                it.first to it.second.injected(it.first)
            }
        }
    }.combine(db.currentUsersFlow) { list, users ->
        list.onEach { result ->
            scope.launch(Dispatchers.IO) {
                val (metadata, injectable) = result.getOrNull() ?: return@launch
                runCatching {
                    injectable.injectOrRun("user") {
                        if (this !is LoginClient) return@injectOrRun
                        val newCurr = users.getUser(metadata)
                        val user = newCurr?.let { db.getUser(it) }
                        setLoginUser(user)
                    }
                }.onFailure {
                    app.throwFlow.emit(it.toAppException(metadata))
                }
            }
        }
    }

    val webViewClientFactory = WebViewClientFactory(app.context)
    private fun createWebClient(metadata: Metadata): WebViewClient {
        if (metadata.type != ExtensionType.MUSIC)
            throw Exception("Webview client is not available for ${metadata.type} Extensions")
        return webViewClientFactory.createFor(metadata)
    }

    private fun Lazy<ExtensionClient>.injected(
        metadata: Metadata,
    ) = Injectable(::value, mutableListOf({
        if (this is MetadataProvider) setMetadata(metadata)
        if (this is MessageFlowProvider) setMessageFlow(app.messageFlow)
        if (this is GlobalSettingsProvider)
            setGlobalSettings(ExtensionUtils.getGlobalSettings(app.context))
        setSettings(ExtensionUtils.getSettings(app.context, metadata))
        if (this is WebViewClientProvider) setWebViewClient(createWebClient(metadata))
        onInitialize()
        onExtensionSelected()
    }))

    private fun <T : Extension<*>> mapped(
        type: ExtensionType, transform: (Metadata, Injectable<ExtensionClient>) -> T,
    ) = injected.map { list ->
        list.mapNotNull {
            val (meta, injectable) = it.getOrNull() ?: return@mapNotNull null
            if (meta.type != type) return@mapNotNull null
            transform(meta, injectable)
        }
    }.combine(priorityMap[type]!!) { list, _ ->
        list.sorted(type) { it.id }
    }.stateIn(scope, SharingStarted.Lazily, emptyList())

    val music = mapped(ExtensionType.MUSIC) { m, i -> MusicExtension(m, i) }
    val tracker = mapped(ExtensionType.TRACKER) { m, i -> TrackerExtension(m, i.casted()) }
    val lyrics = mapped(ExtensionType.LYRICS) { m, i -> LyricsExtension(m, i.casted()) }
    val misc = mapped(ExtensionType.MISC) { m, i -> MiscExtension(m, i) }
    val all = combine(music, tracker, lyrics, misc) { music, tracker, lyrics, misc ->
        music + tracker + lyrics + misc
    }.stateIn(scope, SharingStarted.Lazily, emptyList())

    init {
        scope.launch {
            all.collect { list ->
                list.forEach {
                    if (!it.isEnabled) return@forEach
                    it.inject("providers", app.throwFlow) { injectProviders(this) }
                }
            }
        }
        scope.launch {
            music.collectLatest { setCurrentExtension() }
        }
        scope.launch {
            app.networkFlow.combine(all) { a, b -> a to b }.collect { (conn, all) ->
                all.forEach {
                    if (!it.isEnabled) return@forEach
                    it.inject("network", app.throwFlow) {
                        if (this !is NetworkConnectionProvider) return@inject
                        setNetworkConnection(conn)
                    }
                }
            }
        }
    }

    private fun <T> List<T>.sorted(type: ExtensionType, id: (T) -> String): List<T> {
        val priority = priorityMap[type]!!.value
        return sortedBy { priority.indexOf(id(it)) }
    }

    fun getFlow(type: ExtensionType) = when (type) {
        ExtensionType.MUSIC -> music
        ExtensionType.TRACKER -> tracker
        ExtensionType.LYRICS -> lyrics
        ExtensionType.MISC -> misc
    }

    private fun injectProviders(client: ExtensionClient) {
        (client as? MusicExtensionsProvider)?.run {
            inject(requiredMusicExtensions, music.value) { setMusicExtensions(it) }
        }
        (client as? TrackerExtensionsProvider)?.run {
            inject(requiredTrackerExtensions, tracker.value) { setTrackerExtensions(it) }
        }
        (client as? LyricsExtensionsProvider)?.run {
            inject(requiredLyricsExtensions, lyrics.value) { setLyricsExtensions(it) }
        }
        (client as? MiscExtensionsProvider)?.run {
            inject(requiredMiscExtensions, misc.value) { setMiscExtensions(it) }
        }
    }

    companion object {
        private fun <T, R : Extension<*>> T.inject(
            required: List<String>,
            extensions: List<R>,
            set: T.(List<R>) -> Unit,
        ) {
            if (required.isEmpty()) set(extensions)
            else {
                val filtered = extensions.filter { it.metadata.id in required }
                if (filtered.size == required.size) set(filtered)
                else throw RequiredExtensionsMissingException(required)
            }
        }

        fun List<CurrentUser>.getUser(ext: Metadata): CurrentUser? {
            val curr = find { it.type == ext.type && it.extId == ext.id }
            return curr
        }

        fun ExtensionType.priorityKey() = "priority_${this.feature}"

        const val LAST_EXTENSION_KEY = "last_extension"
    }

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\ExtensionUtils.kt ----------
package com.joaomagdaleno.music_hub.extensions

import android.content.Context
import android.content.SharedPreferences
import androidx.core.content.edit
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.helpers.ClientException
import com.joaomagdaleno.music_hub.common.models.Metadata
import com.joaomagdaleno.music_hub.common.settings.Settings
import com.joaomagdaleno.music_hub.extensions.exceptions.AppException.Companion.toAppException
import com.joaomagdaleno.music_hub.extensions.exceptions.ExtensionNotFoundException
import com.joaomagdaleno.music_hub.utils.ContextUtils.getSettings
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext

object ExtensionUtils {

    suspend fun <R> Extension<*>.get(
        block: suspend ExtensionClient.() -> R
    ) = runCatching {
        runCatching {
            withContext(Dispatchers.IO) { instance.value().getOrThrow().block() }
        }.getOrElse { throw it.toAppException(this) }
    }

    suspend inline fun <reified C, R> Extension<*>.getAs(
        crossinline block: suspend C.() -> R
    ): Result<R> = get {
        val client = this as? C
            ?: throw ClientException.NotSupported(C::class.simpleName ?: "Unknown Class")
        block(client)
    }

    suspend inline fun <reified C, R> Extension<*>.getIf(
        crossinline block: suspend C.() -> R
    ): Result<R?> = get {
        val client = this as? C
        client?.let { block(it) }
    }

    suspend fun <T> Result<T>.getOrThrow(
        throwableFlow: MutableSharedFlow<Throwable>
    ) = getOrElse {
        throwableFlow.emit(it)
        it.printStackTrace()
        null
    }

    suspend inline fun <reified C> Extension<*>.runIf(
        throwableFlow: MutableSharedFlow<Throwable>,
        crossinline block: suspend C.() -> Unit
    ) { getIf<C, Unit>(block).getOrThrow(throwableFlow) }

    suspend inline fun <reified C, R> Extension<*>.getIf(
        throwableFlow: MutableSharedFlow<Throwable>,
        crossinline block: suspend C.() -> R
    ): R? = getIf<C, R>(block).getOrThrow(throwableFlow)

    suspend fun Extension<*>.inject(
        id: String,
        throwableFlow: MutableSharedFlow<Throwable>,
        block: suspend ExtensionClient.() -> Unit
    ) = runCatching {
        instance.injectOrRun(id) { withContext(Dispatchers.IO) { block() } }
    }.getOrElse {
        throwableFlow.emit(it.toAppException(this))
    }

    suspend inline fun <reified T> Extension<*>.isClient() = instance.value().getOrNull() is T

    suspend fun <T : Extension<*>> Flow<List<T>>.getExtension(id: String?): T? {
        val list = first { it.isNotEmpty() }
        return list.find { it.id == id }
    }

    suspend fun <T : Extension<*>> Flow<List<T>>.getExtensionOrThrow(id: String?) =
        getExtension(id) ?: throw ExtensionNotFoundException(id)

    fun <T : Extension<*>> Flow<List<T>>.getExtensionFlow(id: String?): Flow<T?> {
        return map { list -> list.find { it.id == id } }
    }

    fun extensionPrefId(extensionType: String, extensionId: String) = "$extensionType-$extensionId"
    fun String.prefs(context: Context) =
        context.getSharedPreferences(this, Context.MODE_PRIVATE)!!

    fun Metadata.prefs(context: Context) = extensionPrefId(type.name, id).prefs(context)
    fun Extension<*>.prefs(context: Context) = metadata.prefs(context)

    fun getSettings(context: Context, metadata: Metadata): Settings {
        return toSettings(metadata.prefs(context))
    }

    fun getGlobalSettings(context: Context): Settings {
        return toSettings(context.getSettings())
    }

    fun toSettings(prefs: SharedPreferences) = object : Settings {
        override fun getString(key: String) = prefs.getString(key, null)
        override fun putString(key: String, value: String?) {
            prefs.edit { putString(key, value) }
        }

        override fun getInt(key: String) =
            if (prefs.contains(key)) prefs.getInt(key, 0) else null

        override fun putInt(key: String, value: Int?) {
            prefs.edit { if (value != null) putInt(key, value) else remove(key) }
        }

        override fun getBoolean(key: String) =
            if (prefs.contains(key)) prefs.getBoolean(key, false) else null

        override fun putBoolean(key: String, value: Boolean?) {
            prefs.edit { if (value != null) putBoolean(key, value) else remove(key) }
        }

        override fun getStringSet(key: String) = prefs.getStringSet(key, null)
        override fun putStringSet(key: String, value: Set<String>?) {
            prefs.edit { putStringSet(key, value) }
        }
    }

    @Suppress("UNCHECKED_CAST")
    fun SharedPreferences.copyTo(dest: SharedPreferences) = dest.edit {
        all.entries.forEach { entry ->
            val value = entry.value ?: return@forEach
            val key = entry.key
            when (value) {
                is String -> putString(key, value)
                is Set<*> -> putStringSet(key, value as Set<String>)
                is Int -> putInt(key, value)
                is Long -> putLong(key, value)
                is Float -> putFloat(key, value)
                is Boolean -> putBoolean(key, value)
                else -> {}
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\InstallationUtils.kt ----------
package com.joaomagdaleno.music_hub.extensions

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.net.Uri
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.FileProvider
import androidx.core.net.toUri
import androidx.fragment.app.FragmentActivity
import com.joaomagdaleno.music_hub.extensions.repo.ExtensionParser.Companion.PACKAGE_FLAGS
import com.joaomagdaleno.music_hub.extensions.repo.FileRepository.Companion.getExtensionsFileDir
import com.joaomagdaleno.music_hub.utils.ContextUtils.getTempFile
import com.joaomagdaleno.music_hub.utils.PermsUtils.registerActivityResultLauncher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import java.io.File
import kotlin.coroutines.resume

object InstallationUtils {

    suspend fun installApp(activity: FragmentActivity, file: File) {
        val contentUri = FileProvider.getUriForFile(
            activity, "${activity.packageName}.provider", file
        )
        val installIntent = Intent(Intent.ACTION_VIEW).apply {
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
            putExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, true)
            putExtra(Intent.EXTRA_RETURN_RESULT, true)
            data = contentUri
        }
        val it = activity.waitForResult(installIntent)
        if (it.resultCode == Activity.RESULT_OK) return
        val result = it.data?.extras?.getInt("android.intent.extra.INSTALL_RESULT")
        throw Exception("Please uninstall the existing extension first. Error Code: $result")
    }

    suspend fun installFile(
        context: Context, fileIgnoreFlow: MutableSharedFlow<File?>, id: String, tempFile: File
    ) {
        val dir = context.getExtensionsFileDir()
        val newFile = File(dir, "$id.apk")
        dir.setWritable(true)
        newFile.setWritable(true)
        if (newFile.exists())
            if (!newFile.delete())
                throw IllegalStateException("Failed to delete existing file: $newFile")
        tempFile.renameTo(newFile)
        newFile.setWritable(false)
        dir.setReadOnly()
        fileIgnoreFlow.emit(null)
    }

    suspend fun FragmentActivity.openFileSelector(
        fileType: String = "application/octet-stream"
    ): File {
        val intent = Intent(Intent.ACTION_GET_CONTENT).apply {
            type = fileType
            addCategory(Intent.CATEGORY_OPENABLE)
        }
        val result = waitForResult(intent)
        val uri = result.data?.data ?: throw IllegalStateException("No file selected")
        return getTempFile(uri)
    }

    fun Context.getTempFile(uri: Uri): File {
        val stream = contentResolver.openInputStream(uri)!!
        val tempFile = getTempFile("dat")
        tempFile.outputStream().use { outputStream ->
            stream.copyTo(outputStream)
        }
        return tempFile
    }

    suspend fun uninstallApp(activity: FragmentActivity, path: String) {
        val packageName =
            activity.packageManager.getPackageArchiveInfo(path, PACKAGE_FLAGS)?.packageName
                ?: throw IllegalStateException("Invalid APK path or package name not found")
        activity.packageManager.getPackageInfo(packageName, 0)
        val intent = Intent(Intent.ACTION_DELETE).apply {
            data = "package:$packageName".toUri()
            putExtra(Intent.EXTRA_RETURN_RESULT, true)
        }
        val result = activity.waitForResult(intent)
        if (result.resultCode != Activity.RESULT_OK) {
            val errorCode = result.data?.extras?.getInt("android.intent.extra.INSTALL_RESULT")
            throw Exception("Failed to uninstall extension: $errorCode")
        }
    }

    suspend fun uninstallFile(
        fileIgnoreFlow: MutableSharedFlow<File?>, path: String
    ) = withContext(Dispatchers.IO) {
        val file = File(path)
        fileIgnoreFlow.emit(file)
        file.parentFile!!.setWritable(true)
        file.setWritable(true)
        if (file.exists() && !file.delete())
            throw IllegalStateException("Failed to delete file: $file")
        fileIgnoreFlow.emit(null)
    }

    private suspend fun FragmentActivity.waitForResult(
        intent: Intent
    ) = suspendCancellableCoroutine { cont ->
        val contract = ActivityResultContracts.StartActivityForResult()
        val launcher = registerActivityResultLauncher(contract) { cont.resume(it) }
        cont.invokeOnCancellation { launcher.unregister() }
        launcher.launch(intent)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\MediaState.kt ----------
package com.joaomagdaleno.music_hub.extensions

import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import kotlinx.serialization.Serializable

@Serializable
sealed interface MediaState<T : EchoMediaItem> {
    val extensionId: String
    val item: T
    val loaded: Boolean

    @Serializable
    class Loaded<T : EchoMediaItem>(
        override val extensionId: String,
        override val item: T,
        val isFollowed: Boolean?,
        val followers: Long?,
        val isSaved: Boolean?,
        val isLiked: Boolean?,
        val isHidden: Boolean?,
        val showRadio: Boolean,
        val showShare: Boolean
    ) : MediaState<T> {
        override val loaded = true
    }

    @Serializable
    data class Unloaded<T : EchoMediaItem>(
        override val extensionId: String,
        override val item: T
    ) : MediaState<T> {
        override val loaded = false
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\WebViewClientFactory.kt ----------
package com.joaomagdaleno.music_hub.extensions

import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import com.joaomagdaleno.music_hub.MainActivity.Companion.getMainActivity
import com.joaomagdaleno.music_hub.common.helpers.WebViewClient
import com.joaomagdaleno.music_hub.common.helpers.WebViewRequest
import com.joaomagdaleno.music_hub.common.models.Metadata
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.first

class WebViewClientFactory(
    private val context: Context,
) {

    val requests = mutableMapOf<Int, Wrapper>()
    val responseFlow = MutableSharedFlow<Pair<Wrapper, Result<String?>?>>()

    suspend fun await(
        ext: Metadata, showWebView: Boolean, reason: String, request: WebViewRequest<String>,
    ): Result<String?> {
        val wrapper = Wrapper(ext, showWebView, reason, request)
        val id = wrapper.hashCode()
        requests[id] = wrapper
        startWebView(id)
        val res = responseFlow.first { it.first == wrapper && it.second != null }.second!!
        requests.remove(id)
        return res
    }

    private fun startWebView(id: Int) {
        PendingIntent.getActivity(
            context,
            0,
            Intent(context, context.getMainActivity()).apply {
                putExtra("webViewRequest", id)
            },
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT,
        ).send()
    }

    fun createFor(metadata: Metadata) = object : WebViewClient {
        override suspend fun await(
            showWebView: Boolean,
            reason: String,
            request: WebViewRequest<String>,
        ): Result<String?> = await(metadata, showWebView, reason, request)
    }

    data class Wrapper(
        val extension: Metadata,
        val showWebView: Boolean,
        val reason: String,
        val request: WebViewRequest<String>,
    )

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\internal\InternalDownloadSource.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.internal

import android.content.Context
import android.os.Environment
import com.joaomagdaleno.music_hub.common.clients.DownloadClient
import com.joaomagdaleno.music_hub.common.models.DownloadContext
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.ImportType
import com.joaomagdaleno.music_hub.common.models.Metadata
import com.joaomagdaleno.music_hub.common.models.Progress
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.common.models.ImageHolder
import com.joaomagdaleno.music_hub.common.settings.Setting
import com.joaomagdaleno.music_hub.common.settings.Settings
import com.joaomagdaleno.music_hub.common.helpers.ContinuationCallback.Companion.await
import com.joaomagdaleno.music_hub.utils.TagInjector
import kotlinx.coroutines.flow.MutableStateFlow
import okhttp3.OkHttpClient
import okhttp3.Request
import java.io.File
import java.io.FileOutputStream

class InternalDownloadSource(
    private val context: Context
) : DownloadClient {

    companion object {
        const val INTERNAL_DOWNLOAD_ID = "internal_downloader"
        val metadata = Metadata(
            className = "com.joaomagdaleno.music_hub.extensions.builtin.internal.InternalDownloadSource",
            path = "",
            importType = ImportType.BuiltIn,
            type = ExtensionType.MISC,
            id = INTERNAL_DOWNLOAD_ID,
            name = "Music Hub Downloader",
            version = "1.0.0",
            description = "Internal downloader with metadata tagging support",
            author = "João Magdaleno",
            isEnabled = true
        )
    }

    private val client = OkHttpClient()
    private val lrcLib = LrcLibApi(client)

    override val concurrentDownloads = 3

    override suspend fun getDownloadTracks(
        extensionId: String,
        item: EchoMediaItem,
        context: EchoMediaItem?
    ): List<DownloadContext> {
        return when (item) {
            is Track -> listOf(DownloadContext(extensionId, item))
            else -> emptyList()
        }
    }

    override suspend fun selectServer(context: DownloadContext): Streamable {
        return context.track.servers.first()
    }

    override suspend fun selectSources(
        context: DownloadContext,
        server: Streamable.Media.Server
    ): List<Streamable.Source> {
        return server.sources
    }

    override suspend fun download(
        progressFlow: MutableStateFlow<Progress>,
        context: DownloadContext,
        source: Streamable.Source
    ): File {
        val request = Request.Builder().url(source.id).build()
        val response = client.newCall(request).await()
        if (!response.isSuccessful) throw Exception("Download failed: ${response.code}")

        val totalBytes = response.body?.contentLength() ?: -1L
        val destination = File(this.context.cacheDir, "download_${System.currentTimeMillis()}")
        
        response.body?.byteStream()?.use { input ->
            FileOutputStream(destination).use { output ->
                val buffer = ByteArray(8192)
                var bytesRead: Int
                var totalRead = 0L
                while (input.read(buffer).also { bytesRead = it } != -1) {
                    output.write(buffer, 0, bytesRead)
                    totalRead += bytesRead
                    if (totalBytes > 0) {
                        progressFlow.value = Progress(totalBytes, totalRead)
                    }
                }
            }
        }
        return destination
    }

    override suspend fun merge(
        progressFlow: MutableStateFlow<Progress>,
        context: DownloadContext,
        files: List<File>
    ): File {
        // Simple merge: if multiple files, just append (works for some formats like TS)
        // But for most audio, it should be just one file.
        if (files.size == 1) return files[0]
        
        val mergedFile = File(this.context.cacheDir, "merged_${System.currentTimeMillis()}")
        FileOutputStream(mergedFile).use { output ->
            files.forEach { file ->
                file.inputStream().use { input ->
                    input.copyTo(output)
                }
                file.delete()
            }
        }
        return mergedFile
    }

    override suspend fun tag(
        progressFlow: MutableStateFlow<Progress>,
        context: DownloadContext,
        file: File
    ): File {
        val track = context.track
        val lyrics = try {
            lrcLib.getLyrics(
                title = track.title,
                artist = track.artists.joinToString(", ") { it.name },
                duration = track.duration?.div(1000)?.toInt()
            )
        } catch (e: Exception) {
            null
        }

        TagInjector.writeMetadata(
            file = file,
            title = track.title,
            artist = track.artists.joinToString(", ") { it.name },
            album = track.album?.title,
            coverUrl = (track.cover as? ImageHolder.NetworkRequestImageHolder)?.request?.url,
            lyrics = lyrics
        )
        
        // After tagging, move to public music folder
        val publicDir = File(
            Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC),
            "Music Hub"
        )
        if (!publicDir.exists()) publicDir.mkdirs()
        
        val extension = if (file.extension.isNotEmpty()) file.extension else "mp3"
        val fileName = "${track.title} - ${track.artists.firstOrNull()?.name}.$extension"
            .replace(Regex("[\\\\/:*?\"<>|]"), "_")
            
        val finalFile = File(publicDir, fileName)
        file.renameTo(finalFile)
        
        return finalFile
    }

    override suspend fun onInitialize() {}
    override suspend fun onExtensionSelected() {}
    override suspend fun getSettingItems(): List<Setting> = emptyList()
    override fun setSettings(settings: Settings) {}
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\internal\InternalMusicSource.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.internal

import com.joaomagdaleno.music_hub.BuildConfig
import com.joaomagdaleno.music_hub.common.clients.AlbumClient
import com.joaomagdaleno.music_hub.common.clients.ArtistClient
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.clients.HomeFeedClient
import com.joaomagdaleno.music_hub.common.clients.LibraryFeedClient
import com.joaomagdaleno.music_hub.common.clients.LyricsClient
import com.joaomagdaleno.music_hub.common.clients.SearchFeedClient
import com.joaomagdaleno.music_hub.common.clients.TrackClient
import com.joaomagdaleno.music_hub.common.models.*
import com.joaomagdaleno.music_hub.common.models.Streamable.Media.Companion.toServerMedia
import com.joaomagdaleno.music_hub.common.helpers.PagedData
import com.joaomagdaleno.music_hub.common.settings.Setting
import com.joaomagdaleno.music_hub.common.settings.SettingCategory
import com.joaomagdaleno.music_hub.common.settings.SettingSwitch
import com.joaomagdaleno.music_hub.common.settings.SettingTextInput
import com.joaomagdaleno.music_hub.common.settings.Settings

/**
 * Built-in extension that provides internal music sources.
 * This represents the "Fake Extension" pattern to transition to a built-in logic model.
 */
class InternalMusicSource : ExtensionClient, SearchFeedClient, TrackClient, AlbumClient, ArtistClient, HomeFeedClient, LibraryFeedClient, LyricsClient {

    companion object {
        const val INTERNAL_ID = "internal_source"
        const val PREF_QUALITY = "pref_high_quality"
        const val PREF_REGION = "pref_trending_region"
        val metadata = Metadata(
            className = "com.joaomagdaleno.music_hub.extensions.builtin.internal.InternalMusicSource",
            path = "",
            importType = ImportType.BuiltIn,
            type = ExtensionType.MUSIC,
            id = INTERNAL_ID,
            name = "Music Hub Base",
            version = "v${BuildConfig.VERSION_CODE}",
            description = "Official built-in source for Music Hub",
            author = "João Magdaleno",
            isEnabled = true
        )
    }

    private lateinit var settings: Settings

    // --- ExtensionClient ---
    override suspend fun onInitialize() {
        // Initialization logic here
    }

    override suspend fun onExtensionSelected() {
        // Selection logic here
    }

    // --- SettingsProvider ---
    override suspend fun getSettingItems(): List<Setting> = listOf(
        SettingCategory(
            title = "Home Content",
            key = "home_group",
            items = listOf(
                SettingTextInput(
                    title = "Trending Region",
                    key = PREF_REGION,
                    summary = "Country code for YouTube trends (e.g. BR, US, PT)",
                    defaultValue = "BR"
                )
            )
        ),
        SettingCategory(
            title = "Audio Quality",
            key = "audio_group",
            items = listOf(
                SettingSwitch(
                    title = "Force High Quality (FLAC/320)",
                    key = PREF_QUALITY,
                    summary = "Prioritize lossless sources whenever available",
                    defaultValue = true
                )
            )
        )
    )

    override fun setSettings(settings: Settings) {
        this.settings = settings
    }

    private val slavArt = SlavArtApi()
    private val piped = PipedApi()
    private val lrcLib = LrcLibApi()

    // --- SearchFeedClient ---
    override suspend fun loadSearchFeed(query: String): Feed<Shelf> {
        // 1. Try SlavArt first (High Quality)
        val slavArtResults = try {
            slavArt.search(query)
        } catch (e: Exception) {
            emptyList()
        }

        if (slavArtResults.isNotEmpty()) {
            val tracks = slavArtResults.map { result ->
                Track(
                    id = result.id,
                    title = result.title,
                    album = result.album?.let { Album(id = "slavart_album:${result.id}", title = it, artists = listOf()) },
                    artists = listOf(Artist(id = "slavart_artist:${result.artist}", name = result.artist)),
                    cover = result.thumbnail?.let { ImageHolder.NetworkRequestImageHolder(NetworkRequest(it), false) },
                    isPlayable = Track.Playable.Yes,
                    duration = result.duration?.toLong()?.times(1000), // ms
                    extras = mapOf(
                        "source_url" to result.url,
                        "quality" to (result.quality ?: if (settings.getBoolean(PREF_QUALITY) != false) "FLAC" else "320kbps"),
                        "source" to "slavart"
                    )
                )
            }

            val shelf = Shelf.Lists.Tracks(
                id = "slavart_results",
                title = "SlavArt Results",
                list = tracks
            )

            return Feed(tabs = emptyList(), getPagedData = { Feed.Data(PagedData.Single { listOf(shelf) }) })
        }

        // 2. Try YouTube Cascade
        val youtubeTracks = try {
            youtubeCascadeSearch(query)
        } catch (e: Exception) {
            emptyList()
        }

        val shelfTitle = if (youtubeTracks.isNotEmpty()) "YouTube Results" else "No results found"
        val shelf = Shelf.Lists.Tracks(
            id = "youtube_results",
            title = shelfTitle,
            list = youtubeTracks
        )

        return Feed(tabs = emptyList(), getPagedData = { Feed.Data(PagedData.Single { listOf(shelf) }) })
    }

    private suspend fun youtubeCascadeSearch(query: String): List<Track> {
        // Attempt search with different terms for better results
        val searchTerms = listOf(query, "$query topic", "$query official audio")
        val allResults = mutableListOf<PipedSearchResult>()
        val seenIds = mutableSetOf<String>()

        for (term in searchTerms) {
            val results = piped.search(term)
            for (res in results) {
                val videoId = res.url.substringAfter("v=", "")
                if (videoId.isNotBlank() && videoId !in seenIds) {
                    // Filter: Ignore short clips (< 60s)
                    if (res.duration != null && res.duration < 60) continue
                    
                    allResults.add(res)
                    seenIds.add(videoId)
                }
            }
            if (allResults.size >= 10) break
        }

        // Prioritization logic: Topic > Official > Others
        val topicResults = allResults.filter { it.uploaderName?.endsWith(" - Topic") == true }
        val officialResults = allResults.filter { it.title?.contains("Official", ignoreCase = true) == true && it !in topicResults }
        val remainingResults = allResults.filter { it !in topicResults && it !in officialResults }

        val finalResults = (topicResults + officialResults + remainingResults).take(15)

        return finalResults.map { res ->
            val videoId = res.url.substringAfter("v=", "")
            Track(
                id = videoId,
                title = res.title ?: "Unknown",
                artists = listOf(Artist(id = res.uploaderUrl?.substringAfterLast("/")?.let { "youtube_channel:$it" } ?: "unknown", name = res.uploaderName ?: "Unknown")),
                cover = res.thumbnail?.let { ImageHolder.NetworkRequestImageHolder(NetworkRequest(it), false) },
                duration = res.duration?.times(1000),
                isPlayable = Track.Playable.Yes,
                extras = mapOf(
                    "video_id" to videoId,
                    "source" to "youtube"
                )
            )
        }
    }

    // --- TrackClient ---
    override suspend fun loadTrack(track: Track, isDownload: Boolean): Track {
        return track
    }

    override suspend fun loadStreamableMedia(streamable: Streamable, isDownload: Boolean): Streamable.Media {
        val source = streamable.extras["source"] ?: "slavart"
        
        val url = if (source == "youtube") {
            val videoId = streamable.extras["video_id"] ?: ""
            piped.getStreamUrl(videoId) ?: ""
        } else {
            val trackUrl = streamable.extras["source_url"] ?: ""
            if (trackUrl.contains(".slavart-api.")) {
                trackUrl
            } else {
                slavArt.getDownloadUrl(trackUrl) ?: ""
            }
        }

        return url.toServerMedia()
    }

    override suspend fun loadFeed(track: Track): Feed<Shelf>? = null

    // --- AlbumClient ---
    override suspend fun loadAlbum(album: Album): Album = album

    override suspend fun loadTracks(album: Album): Feed<Track>? {
        if (album.id.startsWith("slavart_album:")) {
            val realId = album.id.removePrefix("slavart_album:")
            val results = slavArt.getAlbumTracks(realId)
            val tracks = results.map { result ->
                Track(
                    id = result.id,
                    title = result.title,
                    album = album,
                    artists = listOf(Artist(id = "slavart_artist:${result.artist}", name = result.artist)),
                    cover = result.thumbnail?.let { ImageHolder.NetworkRequestImageHolder(NetworkRequest(it), false) },
                    isPlayable = Track.Playable.Yes,
                    duration = result.duration?.toLong()?.times(1000),
                    extras = mapOf(
                        "source_url" to result.url,
                        "quality" to (result.quality ?: "FLAC"),
                        "source" to "slavart"
                    )
                )
            }
            return Feed(tabs = emptyList(), getPagedData = { Feed.Data(PagedData.Single { tracks }) })
        } else if (album.id.startsWith("youtube_playlist:")) {
            val realId = album.id.removePrefix("youtube_playlist:")
            val results = piped.getPlaylistTracks(realId)
            val tracks = results.map { res ->
                val videoId = res.url.substringAfter("v=", "")
                Track(
                    id = videoId,
                    title = res.title ?: "Unknown",
                    artists = listOf(Artist(id = res.uploaderUrl?.substringAfterLast("/")?.let { "youtube_channel:$it" } ?: "unknown", name = res.uploaderName ?: "Unknown")),
                    cover = res.thumbnail?.let { ImageHolder.NetworkRequestImageHolder(NetworkRequest(it), false) },
                    duration = res.duration?.times(1000),
                    isPlayable = Track.Playable.Yes,
                    extras = mapOf(
                        "video_id" to videoId,
                        "source" to "youtube"
                    )
                )
            }
            return Feed(tabs = emptyList(), getPagedData = { Feed.Data(PagedData.Single { tracks }) })
        }
        return null
    }

    override suspend fun loadFeed(album: Album): Feed<Shelf>? = null

    // --- ArtistClient ---
    override suspend fun loadArtist(artist: Artist): Artist = artist

    override suspend fun loadFeed(artist: Artist): Feed<Shelf> {
        val shelves = mutableListOf<Shelf>()
        
        if (artist.id.startsWith("slavart_artist:")) {
            val realId = artist.id.removePrefix("slavart_artist:")
            val info = slavArt.getArtistInfo(realId)

            if (info.topTracks.isNotEmpty()) {
                val tracks = info.topTracks.map { result ->
                    Track(
                        id = result.id,
                        title = result.title,
                        album = result.album?.let { Album(id = "slavart_album:${result.id}", title = it, artists = listOf()) },
                        artists = listOf(artist),
                        cover = result.thumbnail?.let { ImageHolder.NetworkRequestImageHolder(NetworkRequest(it), false) },
                        isPlayable = Track.Playable.Yes,
                        duration = result.duration?.toLong()?.times(1000),
                        extras = mapOf(
                            "source_url" to result.url,
                            "quality" to (result.quality ?: "FLAC"),
                            "source" to "slavart"
                        )
                    )
                }
                shelves.add(Shelf.Lists.Tracks("popular_tracks", "Popular Tracks", tracks))
            }

            if (info.albums.isNotEmpty()) {
                val albums = info.albums.map { result ->
                    Album(
                        id = "slavart_album:${result.id}",
                        title = result.title ?: result.name ?: "Unknown",
                        cover = result.cover?.let { ImageHolder.NetworkRequestImageHolder(NetworkRequest(it), false) },
                        artists = listOf(artist)
                    )
                }
                shelves.add(Shelf.Lists.Items("albums", "Albums", albums, type = Shelf.Lists.Type.Grid))
            }
        } else if (artist.id.startsWith("youtube_channel:")) {
            val realId = artist.id.removePrefix("youtube_channel:")
            val items = piped.getChannelItems(realId)
            
            val tracks = items.map { res ->
                val videoId = res.url.substringAfter("v=", "")
                Track(
                    id = videoId,
                    title = res.title ?: "Unknown",
                    artists = listOf(Artist(id = res.uploaderUrl?.substringAfterLast("/")?.let { "youtube_channel:$it" } ?: "unknown", name = res.uploaderName ?: "Unknown")),
                    cover = res.thumbnail?.let { ImageHolder.NetworkRequestImageHolder(NetworkRequest(it), false) },
                    duration = res.duration?.times(1000),
                    isPlayable = Track.Playable.Yes,
                    extras = mapOf(
                        "video_id" to videoId,
                        "source" to "youtube"
                    )
                )
            }
            if (tracks.isNotEmpty()) {
                shelves.add(Shelf.Lists.Tracks("latest_uploads", "Latest Uploads", tracks))
            }
        }

        return Feed(tabs = emptyList(), getPagedData = { Feed.Data(PagedData.Single { shelves }) })
    }

    // --- HomeFeedClient ---
    override suspend fun loadHomeFeed(): Feed<Shelf> = Feed(
        listOf(
            Tab("trending", "Trending"),
            Tab("discovery", "Discovery")
        )
    ) { tab ->
        val shelves = mutableListOf<Shelf>()
        when (tab?.id) {
            "trending" -> {
                val region = settings.getString(PREF_REGION) ?: "BR"
                val trending = try { piped.getTrending(region) } catch (e: Exception) { emptyList() }
                if (trending.isNotEmpty()) {
                    val tracks = trending.map { res ->
                        val videoId = res.url.substringAfter("v=", "")
                        Track(
                            id = videoId,
                            title = res.title ?: "Unknown",
                            artists = listOf(Artist(id = res.uploaderUrl?.substringAfterLast("/")?.let { "youtube_channel:$it" } ?: "unknown", name = res.uploaderName ?: "Unknown")),
                            cover = res.thumbnail?.let { ImageHolder.NetworkRequestImageHolder(NetworkRequest(it), false) },
                            duration = res.duration?.times(1000),
                            isPlayable = Track.Playable.Yes,
                            extras = mapOf(
                                "video_id" to videoId,
                                "source" to "youtube"
                            )
                        )
                    }
                    shelves.add(Shelf.Lists.Tracks("trending_youtube", "Popular on YouTube", tracks, type = Shelf.Lists.Type.Grid))
                }
            }
            "discovery" -> {
                val results = try { slavArt.search("top 2024") } catch (e: Exception) { emptyList() }
                if (results.isNotEmpty()) {
                    val tracks = results.map { result ->
                        Track(
                            id = result.id,
                            title = result.title,
                            album = result.album?.let { Album(id = "slavart_album:${result.id}", title = it, artists = listOf()) },
                            artists = listOf(Artist(id = "slavart_artist:${result.artist}", name = result.artist)),
                            cover = result.thumbnail?.let { ImageHolder.NetworkRequestImageHolder(NetworkRequest(it), false) },
                            isPlayable = Track.Playable.Yes,
                            duration = result.duration?.toLong()?.times(1000),
                            extras = mapOf(
                                "source_url" to result.url,
                                "quality" to (result.quality ?: "FLAC"),
                                "source" to "slavart"
                            )
                        )
                    }
                    shelves.add(Shelf.Lists.Tracks("discovery_slavart", "High Quality Picks", tracks, type = Shelf.Lists.Type.Grid))
                }
            }
        }
        Feed.Data(PagedData.Single { shelves })
    }

    // --- LibraryFeedClient ---
    override suspend fun loadLibraryFeed(): Feed<Shelf> = Feed(
        tabs = emptyList(),
        getPagedData = { Feed.Data(PagedData.Single { emptyList<Shelf>() }) }
    )

    // --- LyricsClient ---
    override suspend fun searchTrackLyrics(clientId: String, track: Track): Feed<Lyrics> {
        val title = track.title
        val artist = track.artists.firstOrNull()?.name ?: "Unknown"
        val duration = track.duration?.div(1000)?.toInt()

        val rawLrc = lrcLib.getLyrics(title, artist, duration)
        if (rawLrc == null) return Feed(tabs = emptyList(), getPagedData = { Feed.Data(PagedData.Single { emptyList<Lyrics>() }) })

        val lyrics = Lyrics(
            id = "lrclib:${track.id}",
            title = title,
            subtitle = artist,
            lyrics = lrcLib.parseLrc(rawLrc)
        )
        return Feed(tabs = emptyList(), getPagedData = { Feed.Data(PagedData.Single { listOf(lyrics) }) })
    }

    override suspend fun loadLyrics(lyrics: Lyrics): Lyrics {
        // Since we fetch the full LRC in searchTrackLyrics, nothing more to load
        return lyrics
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\internal\LrcLibApi.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.internal

import com.joaomagdaleno.music_hub.common.helpers.ContinuationCallback.Companion.await
import com.joaomagdaleno.music_hub.common.models.Lyrics
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
import okhttp3.OkHttpClient
import okhttp3.Request

@Serializable
data class LrcEntry(
    val id: Int,
    val trackName: String? = null,
    val artistName: String? = null,
    val plainLyrics: String? = null,
    val syncedLyrics: String? = null,
    val duration: Double? = null
)

class LrcLibApi(private val client: OkHttpClient = OkHttpClient()) {
    private val baseUrl = "https://lrclib.net/api"
    private val json = Json { ignoreUnknownKeys = true }

    suspend fun getLyrics(title: String, artist: String, duration: Int? = null): String? {
        val url = "$baseUrl/get".toHttpUrlOrNull()?.newBuilder()
            ?.addQueryParameter("artist_name", artist)
            ?.addQueryParameter("track_name", title)
            ?.apply { if (duration != null) addQueryParameter("duration", duration.toString()) }
            ?.build() ?: return null

        val request = Request.Builder().url(url).build()
        val response = try { client.newCall(request).await() } catch (e: Exception) { null }

        if (response != null && response.isSuccessful) {
            val body = response.body?.string() ?: return null
            val entry = json.decodeFromString<LrcEntry>(body)
            return entry.syncedLyrics ?: entry.plainLyrics
        }

        // If exact match fails, try search
        return searchLyrics(title, artist)
    }

    private suspend fun searchLyrics(title: String, artist: String): String? {
        val query = "$artist $title"
        val url = "$baseUrl/search".toHttpUrlOrNull()?.newBuilder()
            ?.addQueryParameter("q", query)
            ?.build() ?: return null

        val request = Request.Builder().url(url).build()
        val response = try { client.newCall(request).await() } catch (e: Exception) { null }

        if (response != null && response.isSuccessful) {
            val body = response.body?.string() ?: return null
            val entries = json.decodeFromString<List<LrcEntry>>(body)
            val best = entries.firstOrNull { !it.syncedLyrics.isNullOrBlank() } ?: entries.firstOrNull()
            return best?.syncedLyrics ?: best?.plainLyrics
        }
        return null
    }

    fun parseLrc(lrc: String): Lyrics.Lyric {
        val items = mutableListOf<Lyrics.Item>()
        val lines = lrc.lines()
        // Regex for [mm:ss.xx] or [mm:ss.xxx]
        val pattern = Regex("\\[(\\d+):(\\d+)\\.(\\d+)\\](.*)")
        
        for (line in lines) {
            val match = pattern.find(line)
            if (match != null) {
                val (min, sec, ms, text) = match.destructured
                // ms part can be 2 or 3 digits. If 2 digits, it's centiseconds.
                val milliseconds = when (ms.length) {
                    2 -> ms.toLong() * 10
                    else -> ms.toLong()
                }
                val startTime = (min.toLong() * 60 * 1000) + (sec.toLong() * 1000) + milliseconds
                items.add(Lyrics.Item(text.trim(), startTime, 0L))
            }
        }
        
        if (items.isEmpty()) return Lyrics.Simple(lrc)

        // Sort by start time just in case
        items.sortBy { it.startTime }

        // Set End Times
        val finalItems = mutableListOf<Lyrics.Item>()
        for (i in 0 until items.size - 1) {
            finalItems.add(items[i].copy(endTime = items[i+1].startTime))
        }
        // Last line
        if (items.isNotEmpty()) {
            finalItems.add(items.last().copy(endTime = items.last().startTime + 10000L)) // 10s buffer
        }

        return Lyrics.Timed(finalItems)
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\internal\PipedApi.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.internal

import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive
import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
import okhttp3.OkHttpClient
import okhttp3.Request
import com.joaomagdaleno.music_hub.common.helpers.ContinuationCallback.Companion.await

@Serializable
data class PipedSearchResult(
    val url: String,
    val type: String? = null,
    val title: String? = null,
    val thumbnail: String? = null,
    val uploaderName: String? = null,
    val uploaderUrl: String? = null,
    val duration: Long? = null,
    val isShort: Boolean = false
)

@Serializable
data class PipedStreamInfo(
    val audioStreams: List<PipedAudioStream> = emptyList()
)

@Serializable
data class PipedAudioStream(
    val url: String,
    val format: String,
    val quality: String,
    val bitrate: Int
)

class PipedApi(private val client: OkHttpClient = OkHttpClient()) {
    private val baseUrl = "https://pipedapi.kavin.rocks"
    private val json = Json { ignoreUnknownKeys = true }

    suspend fun search(query: String): List<PipedSearchResult> {
        val url = "$baseUrl/search".toHttpUrlOrNull()?.newBuilder()
            ?.addQueryParameter("q", query)
            ?.addQueryParameter("filter", "music_songs")
            ?.build() ?: return emptyList()

        val request = Request.Builder().url(url).build()
        val response = client.newCall(request).await()

        if (!response.isSuccessful) return emptyList()

        val responseBody = response.body?.string() ?: return emptyList()
        return try {
            val data = json.parseToJsonElement(responseBody)
            when (data) {
                is JsonObject -> {
                    val items = data["items"]?.jsonArray ?: return emptyList()
                    items.mapNotNull { 
                        try {
                            json.decodeFromJsonElement(PipedSearchResult.serializer(), it)
                        } catch (e: Exception) {
                            null
                        }
                    }
                }
                else -> emptyList()
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    suspend fun getStreamUrl(videoId: String): String? {
        val url = "$baseUrl/streams/$videoId".toHttpUrlOrNull() ?: return null

        val request = Request.Builder().url(url).build()
        val response = client.newCall(request).await()

        if (!response.isSuccessful) return null

        val responseBody = response.body?.string() ?: return null
        return try {
            val data = json.decodeFromString<PipedStreamInfo>(responseBody)
            // Pick highest bitrate audio stream
            data.audioStreams.maxByOrNull { it.bitrate }?.url
        } catch (e: Exception) {
            null
        }
    }

    suspend fun getChannelItems(channelId: String): List<PipedSearchResult> {
        val url = "$baseUrl/channels/$channelId".toHttpUrlOrNull() ?: return emptyList()
        val request = Request.Builder().url(url).build()
        val response = client.newCall(request).await()

        if (!response.isSuccessful) return emptyList()

        val responseBody = response.body?.string() ?: return emptyList()
        return try {
            val data = json.parseToJsonElement(responseBody).jsonObject
            val items = data["relatedStreams"]?.jsonArray ?: return emptyList()
            items.mapNotNull {
                try {
                    json.decodeFromJsonElement(PipedSearchResult.serializer(), it)
                } catch (e: Exception) {
                    null
                }
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    suspend fun getPlaylistTracks(playlistId: String): List<PipedSearchResult> {
        val url = "$baseUrl/playlists/$playlistId".toHttpUrlOrNull() ?: return emptyList()
        val request = Request.Builder().url(url).build()
        val response = client.newCall(request).await()

        if (!response.isSuccessful) return emptyList()

        val responseBody = response.body?.string() ?: return emptyList()
        return try {
            val data = json.parseToJsonElement(responseBody).jsonObject
            val items = data["relatedStreams"]?.jsonArray ?: return emptyList()
            items.mapNotNull {
                try {
                    json.decodeFromJsonElement(PipedSearchResult.serializer(), it)
                } catch (e: Exception) {
                    null
                }
            }
        } catch (e: Exception) {
            emptyList()
        }
    }

    suspend fun getTrending(region: String = "BR"): List<PipedSearchResult> {
        val url = "$baseUrl/trending".toHttpUrlOrNull()?.newBuilder()
            ?.addQueryParameter("region", region)
            ?.build() ?: return emptyList()
        
        val request = Request.Builder().url(url).build()
        val response = client.newCall(request).await()

        if (!response.isSuccessful) return emptyList()

        val responseBody = response.body?.string() ?: return emptyList()
        return try {
            val items = json.parseToJsonElement(responseBody).jsonArray
            items.mapNotNull {
                try {
                    json.decodeFromJsonElement(PipedSearchResult.serializer(), it)
                } catch (e: Exception) {
                    null
                }
            }
        } catch (e: Exception) {
            emptyList()
        }
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\internal\SlavArtApi.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.internal

import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.decodeFromJsonElement
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonArray
import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
import okhttp3.OkHttpClient
import okhttp3.Request
import com.joaomagdaleno.music_hub.common.helpers.ContinuationCallback.Companion.await

@Serializable
data class SlavArtTrack(
    val id: String,
    val title: String? = null,
    val name: String? = null,
    val artist: JsonElement? = null,
    val artists: JsonElement? = null,
    val performer: JsonElement? = null,
    val album: SlavArtAlbum? = null,
    val cover: String? = null,
    val image: String? = null,
    val duration: Int? = null,
    val url: String? = null,
    val link: String? = null,
    val maximum_bit_depth: Int? = null,
    val maximum_sampling_rate: Double? = null,
    val audioQuality: String? = null
)

@Serializable
data class SlavArtAlbum(
    val title: String? = null,
    val name: String? = null,
    val cover: String? = null
)

class SlavArtApi(private val client: OkHttpClient = OkHttpClient()) {
    private val baseUrl = "https://slavart.gamesdrive.net"
    private val downloadBaseUrl = "https://slavart-api.gamesdrive.net"
    private val json = Json { ignoreUnknownKeys = true }

    suspend fun search(query: String): List<SlavArtResult> {
        val url = "$baseUrl/api/search".toHttpUrlOrNull()?.newBuilder()
            ?.addQueryParameter("q", query)
            ?.build() ?: return emptyList()

        val request = Request.Builder().url(url).build()
        val response = client.newCall(request).await()

        if (!response.isSuccessful) return emptyList()

        val responseBody = response.body?.string() ?: return emptyList()
        val data = json.parseToJsonElement(responseBody).jsonObject

        val results = mutableListOf<SlavArtResult>()

        for (source in listOf("qobuz", "tidal", "deezer")) {
            val sourceData = data[source] ?: continue
            val items = when {
                sourceData.jsonObject.containsKey("results") ->
                    sourceData.jsonObject["results"]?.jsonArray
                else -> null
            } ?: continue

            for (item in items) {
                try {
                    val track = json.decodeFromJsonElement<SlavArtTrack>(item)
                    results.add(parseTrack(track, source))
                } catch (e: Exception) {
                    continue
                }
            }
        }
        return results
    }

    private fun parseTrack(track: SlavArtTrack, source: String): SlavArtResult {
        return SlavArtResult(
            id = track.id,
            title = track.title ?: track.name ?: "Unknown",
            artist = extractArtist(track),
            album = track.album?.title ?: track.album?.name,
            thumbnail = track.cover ?: track.album?.cover ?: track.image,
            duration = track.duration,
            source = source,
            url = track.url ?: track.link ?: "",
            quality = parseQuality(track, source)
        )
    }

    private fun extractArtist(track: SlavArtTrack): String {
        track.artist?.let { artist ->
            if (artist is kotlinx.serialization.json.JsonObject) {
                return artist["name"]?.toString()?.removeSurrounding("\"") ?: "Unknown"
            }
        }
        track.artists?.let { artists ->
            if (artists is kotlinx.serialization.json.JsonArray && artists.isNotEmpty()) {
                val first = artists[0]
                if (first is kotlinx.serialization.json.JsonObject) {
                    return first["name"]?.toString()?.removeSurrounding("\"") ?: "Unknown"
                } else if (first is kotlinx.serialization.json.JsonPrimitive) {
                    return first.content
                }
            }
        }
        track.performer?.let { performer ->
            if (performer is kotlinx.serialization.json.JsonObject) {
                return performer["name"]?.toString()?.removeSurrounding("\"") ?: "Unknown"
            }
        }
        return track.artist?.toString()?.removeSurrounding("\"") ?: "Unknown"
    }

    private fun parseQuality(track: SlavArtTrack, source: String): String? {
        return when (source) {
            "qobuz" -> {
                if (track.maximum_bit_depth != null && track.maximum_sampling_rate != null) {
                    "${track.maximum_bit_depth}-bit/${track.maximum_sampling_rate}kHz"
                } else "FLAC"
            }
            "tidal" -> {
                when (track.audioQuality) {
                    "HI_RES" -> "MQA 24-bit"
                    "LOSSLESS" -> "FLAC 16-bit"
                    else -> track.audioQuality
                }
            }
            "deezer" -> "FLAC 16-bit"
            else -> null
        }
    }

    suspend fun getDownloadUrl(trackUrl: String): String? {
        val url = "$downloadBaseUrl/api/download".toHttpUrlOrNull()?.newBuilder()
            ?.addQueryParameter("url", trackUrl)
            ?.build() ?: return null

        val request = Request.Builder().url(url).build()
        val response = client.newCall(request).await()

        if (!response.isSuccessful) return null

        val responseBody = response.body?.string() ?: return null
        val data = json.parseToJsonElement(responseBody).jsonObject
        return data["download_url"]?.toString()?.removeSurrounding("\"")
    }

    suspend fun getAlbumTracks(albumId: String): List<SlavArtResult> {
        val url = "$baseUrl/api/album/$albumId".toHttpUrlOrNull() ?: return emptyList()
        val request = Request.Builder().url(url).build()
        val response = client.newCall(request).await()

        if (!response.isSuccessful) return emptyList()

        val responseBody = response.body?.string() ?: return emptyList()
        val data = json.parseToJsonElement(responseBody).jsonObject
        val tracks = data["tracks"]?.jsonArray ?: return emptyList()

        return tracks.mapNotNull {
            try {
                val track = json.decodeFromJsonElement<SlavArtTrack>(it)
                parseTrack(track, "slavart")
            } catch (e: Exception) {
                null
            }
        }
    }

    suspend fun getArtistInfo(artistId: String): SlavArtArtistInfo {
        val url = "$baseUrl/api/artist/$artistId".toHttpUrlOrNull() ?: return SlavArtArtistInfo(emptyList(), emptyList())
        val request = Request.Builder().url(url).build()
        val response = client.newCall(request).await()

        if (!response.isSuccessful) return SlavArtArtistInfo(emptyList(), emptyList())

        val responseBody = response.body?.string() ?: return SlavArtArtistInfo(emptyList(), emptyList())
        val data = json.parseToJsonElement(responseBody).jsonObject

        val topTracks = data["top_tracks"]?.jsonArray?.mapNotNull {
            try {
                val track = json.decodeFromJsonElement<SlavArtTrack>(it)
                parseTrack(track, "slavart")
            } catch (e: Exception) {
                null
            }
        } ?: emptyList()

        val albums = data["albums"]?.jsonArray?.mapNotNull {
            try {
                json.decodeFromJsonElement<SlavArtAlbumResult>(it)
            } catch (e: Exception) {
                null
            }
        } ?: emptyList()

        return SlavArtArtistInfo(topTracks, albums)
    }
}

@Serializable
data class SlavArtAlbumResult(
    val id: String,
    val title: String? = null,
    val name: String? = null,
    val cover: String? = null,
    val year: String? = null
)

data class SlavArtArtistInfo(
    val topTracks: List<SlavArtResult>,
    val albums: List<SlavArtAlbumResult>
)

data class SlavArtResult(
    val id: String,
    val title: String,
    val artist: String,
    val album: String?,
    val thumbnail: String?,
    val duration: Int?,
    val source: String,
    val url: String,
    val quality: String?
)


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\offline\Convertors.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.offline

import android.content.Context
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.helpers.PagedData
import com.joaomagdaleno.music_hub.common.models.Album
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.Date
import com.joaomagdaleno.music_hub.common.models.Date.Companion.toYearDate
import com.joaomagdaleno.music_hub.common.models.Feed
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.toFeed
import com.joaomagdaleno.music_hub.common.models.ImageHolder.Companion.toResourceImageHolder
import com.joaomagdaleno.music_hub.common.models.ImageHolder.Companion.toResourceUriImageHolder
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.common.models.Shelf
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.EXTENSION_ID

fun MediaStoreUtils.MAlbum.toAlbum() = Album(
    id.toString(),
    title ?: "Unknown",
    null,
    cover.toString().toResourceUriImageHolder(),
    artists.map { it.toArtist() },
    songList.size.toLong(),
    songList.sumOf { it.duration ?: 0 },
    albumYear?.toYearDate(),
    extras = mapOf(EXTENSION_ID to OfflineExtension.metadata.id)
)

fun MediaStoreUtils.MArtist?.toArtist() = Artist(
    this?.id.toString(),
    this?.title ?: "Unknown",
    this?.songList?.firstOrNull()?.cover,
    extras = mapOf(EXTENSION_ID to OfflineExtension.metadata.id)
)

fun MediaStoreUtils.MPlaylist.toPlaylist() = Playlist(
    id.toString(),
    title ?: "Unknown",
    true,
    isPrivate = true,
    cover = songList.firstOrNull()?.cover,
    authors = listOf(),
    trackCount = songList.size.toLong(),
    duration = songList.sumOf { it.duration ?: 0 },
    creationDate = modifiedDate.toDate(),
    description = description,
    extras = mapOf(EXTENSION_ID to OfflineExtension.metadata.id)
)

fun Long.toDate() = Date(this)

private fun MediaStoreUtils.FileNode.toSongList(): List<Track> =
    songList + folderList.values.flatMap { it.toSongList() }

fun MediaStoreUtils.FileNode.toShelf(
    context: Context,
    title: String?
): Shelf.Category = run {
    if (folderList.size == 1 && songList.isEmpty())
        return@run folderList.entries.first()
            .run { value.toShelf(context, "${title ?: folderName}/$key") }
    val itemSize = folderList.size + songList.size
    Shelf.Category(
        folderName,
        title ?: folderName,
        PagedData.Single {
            folderList.map {
                it.value.toShelf(context, it.key)
            } + songList.map { it.toShelf() }
        }.toFeed(
            Feed.Buttons(
                showPlayAndShuffle = true,
                customTrackList = toSongList()
            ),
            songList.firstOrNull()?.cover
        ),
        context.resources.runCatching {
            getQuantityString(R.plurals.number_items, itemSize, itemSize)
        }.getOrNull() ?: context.getString(R.string.n_items, itemSize),
        image = songList.firstOrNull()?.cover ?: R.drawable.ic_offline_files.toResourceImageHolder()
    )
}

fun MediaStoreUtils.Genre.toShelf(): Shelf {
    val id = id.toString()
    return Shelf.Lists.Tracks(
        id,
        title ?: "Unknown",
        songList.take(9),
        more = PagedData.Single<Shelf> { songList.map { it.toShelf() } }.toFeed()
    )
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\offline\MediaStoreUtils.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.offline

import android.content.ContentUris
import android.content.ContentValues
import android.content.Context
import android.content.pm.PackageManager
import android.database.Cursor
import android.net.Uri
import android.os.Build
import android.provider.MediaStore
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.database.getIntOrNull
import androidx.core.database.getLongOrNull
import androidx.core.database.getStringOrNull
import androidx.core.net.toUri
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.Album
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.Date.Companion.toYearDate
import com.joaomagdaleno.music_hub.common.models.ImageHolder.Companion.toResourceUriImageHolder
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.common.settings.Settings
import com.joaomagdaleno.music_hub.extensions.builtin.offline.MediaStoreUtils.getAllSongs
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.EXTENSION_ID
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File

/**
 * Blatantly kanged from [Gramophone](https://github.com/AkaneTan/Gramophone/blob/beta/app/src/main/kotlin/org/akanework/gramophone/logic/utils/MediaStoreUtils.kt)
 */
object MediaStoreUtils {

    private const val TAG = "MediaStoreUtils"

    interface Item {
        val id: Long?
        val title: String?
        val songList: MutableSet<Track>
    }

    /**
     * [MAlbum] stores Album metadata.
     */
    interface MAlbum : Item {
        override val id: Long?
        override val title: String?
        val artists: List<MArtist?>
        val albumYear: Int?
        val cover: Uri?
        override val songList: MutableSet<Track>
    }

    data class AlbumImpl(
        override val id: Long?,
        override val title: String?,
        override val artists: List<MArtist?>,
        override val albumYear: Int?,
        override var cover: Uri?,
        override val songList: MutableSet<Track>,
    ) : MAlbum

    /**
     * [MArtist] stores Artist metadata.
     */
    data class MArtist(
        override val id: Long?,
        override val title: String?,
        override val songList: MutableSet<Track>,
        val albumList: MutableList<MAlbum>,
    ) : Item

    /**
     * [Genre] stores Genre metadata.
     */
    data class Genre(
        override val id: Long?,
        override val title: String?,
        override val songList: MutableSet<Track>,
    ) : Item

    /**
     * [Date] stores Date metadata.
     */
    data class Date(
        override val id: Long,
        override val title: String?,
        override val songList: MutableSet<Track>,
    ) : Item

    /**
     * [MPlaylist] stores playlist information.
     */
    open class MPlaylist(
        override val id: Long,
        override val title: String?,
        override val songList: MutableSet<Track>,
        val description: String?,
        val modifiedDate: Long,
    ) : Item


    /**
     * [LibraryStoreClass] collects above metadata classes
     * together for more convenient reading/writing.
     */
    @Suppress("unused")
    class LibraryStoreClass(
        val songList: MutableList<Track>,
        val albumList: MutableList<MAlbum>,
        val artistMap: MutableMap<Long?, MArtist>,
        val genreList: MutableList<Genre>,
        val dateList: MutableList<Date>,
        val playlistList: MutableList<MPlaylist>,
        val likedPlaylist: MPlaylist?,
        val folderStructure: FileNode,
        val shallowFolder: FileNode,
        val folders: Set<String>,
    )

    class FileNode(
        val folderName: String,
    ) {
        val folderList = hashMapOf<String, FileNode>()
        val songList = mutableListOf<Track>()
        var albumId: Long? = null
            private set

        fun addSong(item: Track, id: Long?) {
            if (albumId != null && id != albumId) {
                albumId = null
            } else if (albumId == null && songList.isEmpty()) {
                albumId = id
            }
            songList.add(item)
        }
    }

    private fun handleMediaFolder(path: String, rootNode: FileNode): FileNode {
        val newPath = if (path.endsWith('/')) path.substring(1, path.length - 1)
        else path.substring(1)
        val splitPath = newPath.split('/')
        var node: FileNode = rootNode
        for (fld in splitPath.subList(0, splitPath.size - 1)) {
            var newNode = node.folderList[fld]
            if (newNode == null) {
                newNode = FileNode(fld)
                node.folderList[newNode.folderName] = newNode
            }
            node = newNode
        }
        return node
    }

    private fun handleShallowTrack(
        mediaItem: Track,
        albumId: Long?,
        path: String,
        shallowFolder: FileNode,
        folderArray: MutableList<String>,
    ) {
        val newPath = if (path.endsWith('/')) path.substring(0, path.length - 1) else path
        val splitPath = newPath.split('/')
        if (splitPath.size < 2) throw IllegalArgumentException("splitPath.size < 2: $newPath")
        val lastFolderName = splitPath[splitPath.size - 2]
        var folder = shallowFolder.folderList[lastFolderName]
        if (folder == null) {
            folder = FileNode(lastFolderName)
            shallowFolder.folderList[folder.folderName] = folder
            // hack to cut off /
            folderArray.add(
                newPath.substring(0, splitPath[splitPath.size - 1].length + 1)
            )
        }
        folder.addSong(mediaItem, albumId)
    }

    private val selection = "${MediaStore.Audio.Media.IS_MUSIC} != 0" +
            listOf(
                "audio/x-wav",
                "audio/ogg",
                "audio/aac",
                "audio/midi"
            ).joinToString("") { " or ${MediaStore.Audio.Media.MIME_TYPE} = '$it'" }

    private val projection = arrayListOf(
        MediaStore.Audio.Media._ID,
        MediaStore.Audio.Media.TITLE,
        MediaStore.Audio.Media.ARTIST,
        MediaStore.Audio.Media.ARTIST_ID,
        MediaStore.Audio.Media.ALBUM,
        MediaStore.Audio.Media.ALBUM_ARTIST,
        MediaStore.Audio.Media.DATA,
        MediaStore.Audio.Media.YEAR,
        MediaStore.Audio.Media.ALBUM_ID,
        MediaStore.Audio.Media.MIME_TYPE,
        MediaStore.Audio.Media.TRACK,
        MediaStore.Audio.Media.DURATION,
        MediaStore.Audio.Media.DATE_ADDED,
        MediaStore.Audio.Media.DATE_MODIFIED
    ).apply {
        if (hasImprovedMediaStore()) {
            add(MediaStore.Audio.Media.GENRE)
            add(MediaStore.Audio.Media.GENRE_ID)
            add(MediaStore.Audio.Media.CD_TRACK_NUMBER)
            add(MediaStore.Audio.Media.COMPILATION)
            add(MediaStore.Audio.Media.DATE_TAKEN)
            add(MediaStore.Audio.Media.DISC_NUMBER)
        }
    }.toTypedArray()

    private fun playlistContent(
        context: Context,
        playlists: MutableList<Pair<MPlaylist, MutableList<Long>>>,
    ): Boolean {
        var foundPlaylistContent = false
        context.contentResolver.query(
            @Suppress("DEPRECATION") MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
            arrayOf(
                @Suppress("DEPRECATION") MediaStore.Audio.Playlists._ID,
                @Suppress("DEPRECATION") MediaStore.Audio.Playlists.NAME,
                @Suppress("DEPRECATION") MediaStore.Audio.Playlists.DATE_MODIFIED
            ),
            null, null, null
        )?.use {
            val playlistIdColumn = it.getColumnIndexOrThrow(
                @Suppress("DEPRECATION") MediaStore.Audio.Playlists._ID
            )
            val playlistNameColumn = it.getColumnIndexOrThrow(
                @Suppress("DEPRECATION") MediaStore.Audio.Playlists.NAME
            )
            val playlistModifiedDateColumn = it.getColumnIndexOrThrow(
                @Suppress("DEPRECATION") MediaStore.Audio.Playlists.DATE_MODIFIED
            )
            while (it.moveToNext()) {
                val playlistId = it.getLong(playlistIdColumn)
                val playlistName = it.getString(playlistNameColumn)?.ifEmpty { null }
                val modifiedDate = it.getLong(playlistModifiedDateColumn)
                val content = mutableListOf<Long>()
                context.contentResolver.query(
                    @Suppress("DEPRECATION")
                    MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId),
                    arrayOf(
                        @Suppress("DEPRECATION") MediaStore.Audio.Playlists.Members.AUDIO_ID
                    ), null, null,
                    @Suppress("DEPRECATION") MediaStore.Audio.Playlists.Members.PLAY_ORDER + " ASC"
                )?.use { cursor ->
                    val column = cursor.getColumnIndexOrThrow(
                        @Suppress("DEPRECATION") MediaStore.Audio.Playlists.Members.AUDIO_ID
                    )
                    while (cursor.moveToNext()) {
                        foundPlaylistContent = true
                        content.add(cursor.getLong(column))
                    }
                }

                val playlist =
                    MPlaylist(playlistId, playlistName, mutableSetOf(), null, modifiedDate)
                playlists.add(Pair(playlist, content))
            }

        }
        return foundPlaylistContent
    }

    private fun Cursor.parseSongQuery(
        limitValue: Int,
        folderFilter: Set<String>,
        blacklistKeywords: List<String>,
        context: Context,
        songs: MutableList<Track>,
        foundPlaylistContent: Boolean,
        idMap: MutableMap<Long, Track>?,
        block: (Track) -> Unit,
    ) = use { cursor ->
        // Get columns from mediaStore.
        val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID)
        val titleColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE)
        val artistColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST)
        val albumColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM)
        val albumArtistColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ARTIST)
        val trackNumberColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TRACK)
        val pathColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATA)
        val yearColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.YEAR)
        val albumIdColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM_ID)
        val genreColumn = if (hasImprovedMediaStore())
            cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.GENRE) else null
        val durationColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION)
        val addDateColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATE_ADDED)

        while (cursor.moveToNext()) {
            val path = cursor.getStringOrNull(pathColumn) ?: continue
            val duration = cursor.getLongOrNull(durationColumn)
            val fldPath = File(path).parentFile?.absolutePath
            val skip = (duration != null && duration < limitValue * 1000)
                    || folderFilter.contains(fldPath)
                    || blacklistKeywords.any { fldPath?.contains(it, true) == true }
            // We need to add blacklisted songs to idMap as they can be referenced by playlist
            if (skip && !foundPlaylistContent) continue
            val id = cursor.getLongOrNull(idColumn)!!
            val title = cursor.getStringOrNull(titleColumn)!!
            val artist = cursor.getStringOrNull(artistColumn)
                .let { v -> if (v == "<unknown>") null else v }
            val albumName = cursor.getStringOrNull(albumColumn)
            val albumArtist = cursor.getStringOrNull(albumArtistColumn)
            val trackNumber = cursor.getIntOrNull(trackNumberColumn)
            val year = cursor.getIntOrNull(yearColumn).let { v -> if (v == 0) null else v }
            val albumId = cursor.getLongOrNull(albumIdColumn)
            val genre = genreColumn?.let { col -> cursor.getStringOrNull(col) }
            val addDate = cursor.getLongOrNull(addDateColumn)
            val imgUri = ContentUris.appendId(
                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI.buildUpon(), id
            ).appendPath("albumart").build().takeIf { uri ->
                context.contentResolver.runCatching { openInputStream(uri)!!.close() }.isSuccess
            }

            val artists = artist.toArtists()
            val album = albumName?.let {
                Album(albumId.toString(), it, null, null, albumArtist.toArtists())
            }
            val song = Track(
                id = id.toString(),
                title = title,
                artists = artists,
                album = album,
                cover = imgUri?.toString()?.toResourceUriImageHolder(),
                duration = duration,
                releaseDate = year?.toYearDate(),
                streamables = listOf(Streamable.server(path, 0, path)),
                extras = mapOf(
                    "genre" to (genre ?: context.getString(R.string.unknown)),
                    "addDate" to addDate.toString(),
                    "trackNumber" to trackNumber.toString(),
                    EXTENSION_ID to OfflineExtension.metadata.id
                )
            )

            // Build our metadata maps/lists.
            idMap?.put(id, song)
            // Now that the song can be found by playlists, do NOT register other metadata.
            if (skip) continue
            songs.add(song)
            block(song)
        }
    }

    private val coverUri = "content://media/external/audio/albumart".toUri()

    private fun songAlbumMap(
        song: Track,
        year: Int?,
        albumMap: MutableMap<Long?, AlbumImpl>,
        artistMap: MutableMap<Long?, MArtist>,
        haveImgPerm: Boolean,
    ) {
        val album = song.album ?: return
        val id = album.id.toLong()
        albumMap.getOrPut(id) {
            val cover = if (haveImgPerm) null else ContentUris.withAppendedId(coverUri, id)
            val artists = album.artists.map {
                MArtist(it.id.toLongOrNull(), it.name, mutableSetOf(), mutableListOf())
            }

            AlbumImpl(id, album.title, artists, year, cover, mutableSetOf()).apply {
                artists.forEach {
                    val mArtist = artistMap.getOrPut(it.id) {
                        MArtist(it.id, it.title, mutableSetOf(), mutableListOf())
                    }
                    mArtist.albumList.add(this)
                }
            }
        }.songList.add(song)
    }

    private val allowedCoverExtensions = listOf("jpg", "png", "jpeg", "bmp", "tiff", "tif", "webp")

    private fun albumMapToAlbumList(
        albumMap: MutableMap<Long?, AlbumImpl>,
        coverCache: HashMap<Long, Pair<File, FileNode>>?,
    ) = albumMap.values.onEach {
        it.artists.forEach { mArtist ->
            mArtist?.albumList?.add(it)
        }
        // coverCache == null if !haveImgPerm
        coverCache?.get(it.id)?.let { p ->
            // if this is false, folder contains >1 albums
            if (p.second.albumId == it.id) {
                var bestScore = 0
                var bestFile: File? = null
                try {
                    val files = p.first.listFiles() ?: return@let
                    for (file in files) {
                        if (file.extension !in allowedCoverExtensions)
                            continue
                        var score = 1
                        when (file.extension) {
                            "jpg" -> score += 3
                            "png" -> score += 2
                            "jpeg" -> score += 1
                        }
                        if (file.nameWithoutExtension == "albumart") score += 24
                        else if (file.nameWithoutExtension == "cover") score += 20
                        else if (file.nameWithoutExtension.startsWith("albumart")) score += 16
                        else if (file.nameWithoutExtension.startsWith("cover")) score += 12
                        else if (file.nameWithoutExtension.contains("albumart")) score += 8
                        else if (file.nameWithoutExtension.contains("cover")) score += 4
                        if (bestScore < score) {
                            bestScore = score
                            bestFile = file
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, Log.getStackTraceString(e))
                }
                // allow .jpg or .png files with any name, but only permit more exotic
                // formats if name contains either cover or albumart
                if (bestScore >= 3) {
                    bestFile?.let { f -> it.cover = f.toUri() }
                }
            }
        }
    }.toMutableList<MAlbum>()

    /**
     * [getAllSongs] gets all of your songs from your local disk.
     *
     * @param context
     * @return
     */
    suspend fun getAllSongs(
        context: Context, settings: Settings
    ) = withContext(Dispatchers.IO) {
        val limitValueSeconds = settings.getInt("limit_value") ?: 10
        val haveImgPerm = if (hasScopedStorage()) context.hasImagePermission() else false
        val folderFilter = settings.getStringSet("blacklist_folders") ?: setOf()
        val blacklistKeywords = settings.getString("blacklist_keywords")?.split(',')
            ?.mapNotNull { it.trim().takeIf { s -> s.isNotBlank() } }.orEmpty()
        // Initialize list and maps.
        val coverCache = if (haveImgPerm) hashMapOf<Long, Pair<File, FileNode>>() else null
        val folders = hashSetOf<String>()
        val folderArray = mutableListOf<String>()
        val root = FileNode("storage")
        val shallowRoot = FileNode("shallow")
        val songs = mutableListOf<Track>()
        val albumMap = mutableMapOf<Long?, AlbumImpl>()
        val artistMap = mutableMapOf<Long?, MArtist>()
        val albumArtistMap =
            hashMapOf<MArtist?, Pair<MutableSet<MAlbum>, MutableSet<Track>>>()

        val genreMap = hashMapOf<String?, Genre>()
        val dateMap = hashMapOf<Int?, Date>()
        val playlists = mutableListOf<Pair<MPlaylist, MutableList<Long>>>()
        val foundPlaylistContent =
            runCatching { playlistContent(context, playlists) }.getOrNull() ?: false
        val idMap = hashMapOf<Long, Track>()
        val uri = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q)
            MediaStore.Audio.Media.getContentUri(MediaStore.VOLUME_EXTERNAL)
        else MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
        val cursor = context.contentResolver.query(
            uri, projection, selection, null,
            MediaStore.Audio.Media.TITLE + " COLLATE UNICODE ASC",
        )
        cursor?.parseSongQuery(
            limitValueSeconds,
            folderFilter,
            blacklistKeywords,
            context,
            songs,
            foundPlaylistContent,
            idMap,
        ) { song ->
            song.artists.map {
                val id = it.id.toLongOrNull()
                val mArtist = artistMap.getOrPut(id) {
                    MArtist(id, it.name, mutableSetOf(), mutableListOf())
                }
                mArtist.songList.add(song)
                mArtist
            }

            val year = song.releaseDate?.year
            songAlbumMap(song, year, albumMap, artistMap, haveImgPerm)

            val albumId = song.album?.id?.toLong()
            val path = song.streamables.first().id
            val parent = File(path).parentFile
            parent?.absolutePath?.let { folders.add(it) }

            val fn = handleMediaFolder(path, root)
            fn.addSong(song, song.album?.id?.toLong())
            if (albumId != null && parent != null) {
                coverCache?.putIfAbsent(albumId, Pair(parent, fn))
            }
            handleShallowTrack(song, albumId, path, shallowRoot, folderArray)

            val genre = song.extras["genre"] ?: "Unknown"
            genreMap.getOrPut(genre) {
                Genre(genre.id(), genre, mutableSetOf())
            }.songList.add(song)

            dateMap.getOrPut(year) {
                Date(year?.toLong() ?: 0, year?.toString(), mutableSetOf())
            }.songList.add(song)
        }

        // Parse all the lists.
        val albumList = albumMapToAlbumList(albumMap, coverCache)
        albumArtistMap.entries.forEach { (artist, pair) ->
            val albums = pair.first
            val song = pair.second
            MArtist(artist?.id, artist?.title, song, albums.toMutableList())
        }
        val genreList = genreMap.values.toMutableList()
        val dateList = dateMap.values.toMutableList()

        val playlistsFinal = playlists.map {
            it.first.also { playlist ->
                playlist.songList.addAll(it.second.map { value ->
                    idMap[value] ?: dummyTrack(value, "Unknown [$value]")
                })
            }
        }.toMutableList()

        val likedPlaylist = getLikedPlaylist(context, playlistsFinal)
        likedPlaylist?.let { playlistsFinal.add(0, it) }

        folders.addAll(folderFilter)
        LibraryStoreClass(
            songs, albumList, artistMap, genreList, dateList, playlistsFinal,
            likedPlaylist, root, shallowRoot, folders
        )
    }

    private fun getLikedPlaylist(
        context: Context,
        playlistsFinal: MutableList<MPlaylist>,
    ) = run {
        val liked = playlistsFinal.find { it.title == "Liked" }
        val id = liked?.id ?: context.createPlaylist("Liked")
        liked?.let { playlistsFinal.remove(it) }
        MPlaylist(
            id ?: return@run null,
            context.getString(R.string.playlist_liked),
            liked?.songList ?: mutableSetOf(),
            context.getString(R.string.playlist_liked_desc),
            liked?.modifiedDate ?: (System.currentTimeMillis() / 1000L)
        )
    }

    private fun dummyTrack(id: Long, title: String): Track {
        return Track(id.toString(), title)
    }

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    fun Context.hasImagePermission() =
        checkSelfPermission(android.Manifest.permission.READ_MEDIA_IMAGES) ==
                PackageManager.PERMISSION_GRANTED

    private fun hasImprovedMediaStore(): Boolean =
        Build.VERSION.SDK_INT >= Build.VERSION_CODES.R

    private fun hasScopedStorage(): Boolean =
        Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU

    fun Context.createPlaylist(title: String): Long? {
        val values = ContentValues()
        values.put(
            @Suppress("DEPRECATION") MediaStore.Audio.Playlists.NAME,
            title
        )
        return contentResolver.insert(
            @Suppress("DEPRECATION")
            MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
            values
        )?.lastPathSegment?.toLong()
    }

    fun Context.editPlaylist(id: Long, title: String) {
        val values = ContentValues()
        values.put(
            @Suppress("DEPRECATION") MediaStore.Audio.Playlists.NAME,
            title
        )
        contentResolver.update(
            @Suppress("DEPRECATION")
            MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
            values,
            @Suppress("DEPRECATION")
            MediaStore.Audio.Playlists._ID + "=?",
            arrayOf(id.toString())
        )
    }

    fun Context.deletePlaylist(id: Long) {
        contentResolver.delete(
            @Suppress("DEPRECATION")
            MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
            @Suppress("DEPRECATION") MediaStore.Audio.Playlists._ID + "=?",
            arrayOf(id.toString())
        )
    }

    fun Context.addSongToPlaylist(playlistId: Long, songId: Long, index: Int) {
        val values = ContentValues()
        values.put(
            @Suppress("DEPRECATION") MediaStore.Audio.Playlists.Members.PLAY_ORDER,
            index + 1
        )
        values.put(
            @Suppress("DEPRECATION") MediaStore.Audio.Playlists.Members.AUDIO_ID,
            songId
        )
        contentResolver.insert(
            @Suppress("DEPRECATION")
            MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId),
            values
        )
    }

    fun Context.removeSongFromPlaylist(playlistId: Long, index: Int) {
        contentResolver.delete(
            @Suppress("DEPRECATION")
            MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId),
            @Suppress("DEPRECATION") MediaStore.Audio.Playlists.Members.PLAY_ORDER + "=?",
            arrayOf((index + 1).toString())
        )
    }

    fun Context.moveSongInPlaylist(playlistId: Long, song: Long, from: Int, to: Int) {
        removeSongFromPlaylist(playlistId, from)
        addSongToPlaylist(playlistId, song, to)
    }

    fun <E> List<E>.searchBy(query: String, block: (E) -> List<String?>) = map { item ->
        val qLower = query.lowercase().split(" ").ifEmpty { return@map 5 to item }
        val titles = block(item).flatMap {
            it?.split(" ") ?: listOf()
        }.mapNotNull {
            it.takeIf { it.isNotBlank() }?.lowercase()
        }.ifEmpty { return@map 5 to item }
        val selected = titles.map { t ->
            val distance = qLower.sumOf {
                val distance = wagnerFischer(t, it)
                val bonus = if (t.contains(it)) -t.length else 0
                distance + bonus
            } / qLower.size
            distance to t
        }.minBy { it.first }
        selected.first to item
    }.filter { it.first <= 3 }.sortedBy { it.first }

    // taken from https://gist.github.com/jmarchesini/e330088e03daa394cf03ddedb8956fbe
    private fun wagnerFischer(s: String, t: String): Int {
        val m = s.length
        val n = t.length

        if (s == t) return 0
        if (s.isEmpty()) return n
        if (t.isEmpty()) return m

        val d = Array(m + 1) { IntArray(n + 1) }

        for (i in 1..m) {
            d[i][0] = i
        }

        for (j in 1..n) {
            d[0][j] = j
        }

        for (j in 1..n) {
            for (i in 1..m) {
                val cost = if (s[i - 1] == t[j - 1]) 0 else 1
                val delCost = d[i - 1][j] + 1
                val addCost = d[i][j - 1] + 1
                val subCost = d[i - 1][j - 1] + cost

                d[i][j] = minOf(delCost, addCost, subCost)
            }
        }
        return d[m][n]
    }

    private fun String?.splitArtists() = this?.split(",", "&", " and ")
        ?.mapNotNull { it.trim().takeIf { s -> s.isNotBlank() } }
        ?: listOf(null)

    private fun String?.toArtists() = takeIf { this != "null" }.splitArtists().map {
        Artist(it?.id().toString(), it ?: "Unknown")
    }

    fun String.id() = this.lowercase().hashCode().toLong()
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\offline\OfflineExtension.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.offline

import android.content.Context
import android.net.Uri
import androidx.annotation.OptIn
import androidx.media3.common.util.UnstableApi
import com.joaomagdaleno.music_hub.BuildConfig
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.clients.AlbumClient
import com.joaomagdaleno.music_hub.common.clients.ArtistClient
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.clients.HomeFeedClient
import com.joaomagdaleno.music_hub.common.clients.LibraryFeedClient
import com.joaomagdaleno.music_hub.common.clients.LikeClient
import com.joaomagdaleno.music_hub.common.clients.PlaylistClient
import com.joaomagdaleno.music_hub.common.clients.PlaylistEditorListenerClient
import com.joaomagdaleno.music_hub.common.clients.RadioClient
import com.joaomagdaleno.music_hub.common.clients.SearchFeedClient
import com.joaomagdaleno.music_hub.common.clients.SettingsChangeListenerClient
import com.joaomagdaleno.music_hub.common.clients.TrackClient
import com.joaomagdaleno.music_hub.common.helpers.ClientException
import com.joaomagdaleno.music_hub.common.helpers.PagedData
import com.joaomagdaleno.music_hub.common.models.Album
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.Feed
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.loadAll
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.toFeed
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.toFeedData
import com.joaomagdaleno.music_hub.common.models.ImageHolder.Companion.toResourceImageHolder
import com.joaomagdaleno.music_hub.common.models.ImportType
import com.joaomagdaleno.music_hub.common.models.Metadata
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.common.models.Radio
import com.joaomagdaleno.music_hub.common.models.Shelf
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Streamable.Media.Companion.toMedia
import com.joaomagdaleno.music_hub.common.models.Streamable.Source.Companion.toSource
import com.joaomagdaleno.music_hub.common.models.Tab
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.common.settings.Setting
import com.joaomagdaleno.music_hub.common.settings.SettingMultipleChoice
import com.joaomagdaleno.music_hub.common.settings.SettingSlider
import com.joaomagdaleno.music_hub.common.settings.SettingSwitch
import com.joaomagdaleno.music_hub.common.settings.SettingTextInput
import com.joaomagdaleno.music_hub.common.settings.Settings
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getSettings
import com.joaomagdaleno.music_hub.extensions.builtin.offline.MediaStoreUtils.addSongToPlaylist
import com.joaomagdaleno.music_hub.extensions.builtin.offline.MediaStoreUtils.createPlaylist
import com.joaomagdaleno.music_hub.extensions.builtin.offline.MediaStoreUtils.deletePlaylist
import com.joaomagdaleno.music_hub.extensions.builtin.offline.MediaStoreUtils.editPlaylist
import com.joaomagdaleno.music_hub.extensions.builtin.offline.MediaStoreUtils.moveSongInPlaylist
import com.joaomagdaleno.music_hub.extensions.builtin.offline.MediaStoreUtils.removeSongFromPlaylist
import com.joaomagdaleno.music_hub.extensions.builtin.offline.MediaStoreUtils.searchBy
import com.joaomagdaleno.music_hub.utils.Serializer.toData
import com.joaomagdaleno.music_hub.utils.Serializer.toJson
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.io.File

@OptIn(UnstableApi::class)
class OfflineExtension(
    private val context: Context,
) : ExtensionClient, HomeFeedClient, TrackClient, AlbumClient, ArtistClient, PlaylistClient,
    RadioClient, LibraryFeedClient, LikeClient, PlaylistEditorListenerClient,
    SearchFeedClient, SettingsChangeListenerClient {

    companion object {
        val metadata = Metadata(
            className = "OfflineExtension",
            path = "",
            importType = ImportType.BuiltIn,
            type = ExtensionType.MUSIC,
            id = "echo-offline",
            name = "Offline",
            description = "An extension for all your downloaded files.",
            version = "v${BuildConfig.VERSION_CODE}",
            author = "Echo",
            icon = R.drawable.ic_offline.toResourceImageHolder(),
        )
    }

    override suspend fun onSettingsChanged(settings: Settings, key: String?) {
        refreshLibrary()
    }

    override suspend fun getSettingItems(): List<Setting> {
        val folders = getLibrary().folders
        return listOf(
            SettingSwitch(
                context.getString(R.string.refresh_library_on_reload),
                "refresh_library",
                context.getString(R.string.refresh_library_on_reload_summary),
                false
            ),
            SettingSlider(
                context.getString(R.string.duration_filter),
                "limit_value",
                context.getString(R.string.duration_filter_summary),
                10,
                0,
                120,
                10
            ),
            SettingMultipleChoice(
                context.getString(R.string.blacklist_folders),
                "blacklist_folders",
                context.getString(R.string.blacklist_folders_summary),
                folders.toList(),
                folders.toList()
            ),
            SettingTextInput(
                context.getString(R.string.blacklist_folder_keywords),
                "blacklist_keywords",
                context.getString(R.string.blacklist_folder_keywords_summary)
            )
        )
    }

    private val settings = getSettings(context, metadata)
    override fun setSettings(settings: Settings) {}
    private val refreshLibrary
        get() = settings.getBoolean("refresh_library") ?: true

    private val mutex = Mutex()
    private var _library: MediaStoreUtils.LibraryStoreClass? = null
    private suspend fun getLibrary() = mutex.withLock {
        if (_library == null) _library = MediaStoreUtils.getAllSongs(context, settings)
        _library!!
    }

    private suspend fun refreshLibrary() {
        _library = MediaStoreUtils.getAllSongs(context, settings)
    }

    private suspend fun find(artist: Artist) =
        getLibrary().artistMap[artist.id.toLongOrNull()]

    private suspend fun find(album: Album) =
        getLibrary().albumList.find { it.id == album.id.toLong() }

    private suspend fun find(playlist: Playlist) =
        getLibrary().playlistList.find { it.id == playlist.id.toLong() }

    private fun List<EchoMediaItem>.toShelves(buttons: Feed.Buttons? = null): Feed<Shelf> =
        map { it.toShelf() }.toFeed(buttons)

    override suspend fun loadHomeFeed() = Feed(listOf()) {
        if (refreshLibrary) refreshLibrary()
        val library = getLibrary()
        val recentlyAdded = library.songList.sortedByDescending {
            it.extras["addDate"]?.toLongOrNull()
        }.map { it }
        val albums = library.albumList.map {
            it.toAlbum()
        }.shuffled()
        val artists = library.artistMap.values.map {
            it.toArtist()
        }.shuffled()

        val recent = if (recentlyAdded.isNotEmpty()) Shelf.Lists.Tracks(
            "recents",
            context.getString(R.string.recently_added),
            recentlyAdded.take(9),
            more = recentlyAdded.toShelves().takeIf { recentlyAdded.size > 9 }
        ) else null

        val albumShelf = if (albums.isNotEmpty()) Shelf.Lists.Items(
            "albums",
            context.getString(R.string.albums),
            albums.take(10),
            more = albums.toShelves().takeIf { albums.size > 10 }
        ) else null

        val artistsShelf = if (artists.isNotEmpty()) Shelf.Lists.Items(
            "artists",
            context.getString(R.string.artists),
            artists.take(10),
            more = artists.toShelves().takeIf { artists.size > 10 }
        ) else null

        val data = PagedData.Single {
            listOfNotNull(recent, albumShelf, artistsShelf) + library.songList.map { it.toShelf() }
        }
        data.toFeedData(
            Feed.Buttons(
                showSearch = false, showSort = true, showPlayAndShuffle = true
            )
        )
    }

    override suspend fun loadTrack(track: Track, isDownload: Boolean): Track = track

    override suspend fun loadStreamableMedia(streamable: Streamable, isDownload: Boolean) =
        Uri.fromFile(File(streamable.id)).toString().toSource(isLive = false).toMedia()

    override suspend fun loadFeed(track: Track): Feed<Shelf>? = null

    override suspend fun loadAlbum(album: Album) =
        find(album)!!.toAlbum()

    override suspend fun loadTracks(album: Album): Feed<Track> = PagedData.Single {
        find(album)!!.songList.sortedBy { it.extras["trackNumber"]?.toLongOrNull() }.map { it }
    }.toFeed()

    override suspend fun loadFeed(album: Album) =
        getArtistsWithCategories(album.artists) { it.album?.id != album.id }

    private suspend fun getArtistsWithCategories(
        artists: List<Artist>, filter: (Track) -> Boolean,
    ) = artists.map { small ->
        val artist = find(small)
        val category = artist?.songList?.filter {
            filter(it)
        }?.map { it }?.ifEmpty { null }?.let { tracks ->
            Shelf.Lists.Items(
                small.id,
                context.getString(R.string.more_by_x, small.name),
                tracks,
                more = tracks.toShelves()
            )
        }
        listOfNotNull(artist.toArtist().toShelf(), category)
    }.flatten().toFeed()

    override suspend fun loadArtist(artist: Artist) =
        find(artist)!!.toArtist()

    override suspend fun loadFeed(artist: Artist): Feed<Shelf> {
        return find(artist)!!.run {
            val tracks = songList.ifEmpty { null }?.toList()
            val albums = albumList.map { it.toAlbum() }.ifEmpty { null }
            listOfNotNull(
                tracks?.let {
                    val id = "${artist.id}_tracks"
                    listOf(
                        Shelf.Lists.Items(
                            id,
                            context.getString(R.string.songs) + " (${it.size})",
                            listOf(),
                            more = tracks.toShelves().takeIf { tracks.size >= 10 }
                        )
                    )
                },
                tracks?.take(10)?.map { it.toShelf() },
                albums?.let {
                    val id = "${artist.id}_albums"
                    listOf(
                        Shelf.Lists.Items(
                            id,
                            context.getString(R.string.albums) + " (${it.size})",
                            it,
                            more = albums.toShelves().takeIf { albums.size >= 4 }
                        )
                    )
                }
            ).flatten().toFeed(Feed.Buttons(showPlayAndShuffle = true, customTrackList = tracks))
        }
    }

    override suspend fun loadPlaylist(playlist: Playlist) =
        if (playlist.id == "cached") playlist else find(playlist)!!.toPlaylist()

    override suspend fun loadTracks(playlist: Playlist): Feed<Track> = PagedData.Single {
        find(playlist)!!.songList.map { it }
    }.toFeed()

    override suspend fun loadFeed(playlist: Playlist): Feed<Shelf>? = null

    override suspend fun loadRadio(radio: Radio) = radio

    override suspend fun loadTracks(radio: Radio): Feed<Track> = PagedData.Single {
        val mediaItem = radio.extras["mediaItem"]!!.toData<EchoMediaItem>().getOrThrow()
        val library = getLibrary()
        when (mediaItem) {
            is Album -> {
                val tracks = loadTracks(mediaItem).loadAll().asSequence()
                    .map { it.artists }.flatten().map { artist ->
                        library.artistMap[artist.id.toLongOrNull()]?.songList?.map { it }!!
                    }.flatten().filter { it.album?.id != mediaItem.id }.take(25)

                val randomTracks = library.songList.shuffled().take(25).map { it }
                (tracks + randomTracks).distinctBy { it.id }.toMutableList()
            }

            is Playlist -> {
                val tracks = loadTracks(mediaItem).loadAll()
                val randomTracks = getLibrary().songList.shuffled().take(25).map { it }
                (tracks + randomTracks).distinctBy { it.id }.toMutableList()
            }

            is Artist -> {
                val tracks = find(mediaItem)?.songList?.map { it } ?: emptyList()
                val randomTracks = getLibrary().songList.shuffled().take(25).map { it }
                (tracks + randomTracks).distinctBy { it.id }.toMutableList()
            }

            is Track -> {
                val albumTracks = mediaItem.album?.let { loadTracks(loadAlbum(it)).loadAll() }
                val artistTracks = mediaItem.artists.map { artist ->
                    find(artist)?.songList ?: emptyList()
                }.flatten().map { it }
                val randomTracks = getLibrary().songList.shuffled().take(25).map { it }
                val allTracks =
                    listOfNotNull(albumTracks, artistTracks, randomTracks).flatten()
                        .distinctBy { it.id }
                        .toMutableList()
                allTracks.removeIf { it.id == mediaItem.id }
                allTracks
            }

            else -> throw IllegalAccessException()
        }.shuffled()
    }.toFeed()

    override suspend fun radio(item: EchoMediaItem, context: EchoMediaItem?): Radio {
        val id = "radio_${item.hashCode()}"
        val title = item.title
        return Radio(
            id = id,
            title = this.context.getString(R.string.x_radio, title),
            extras = mapOf("mediaItem" to item.toJson())
        )
    }

    private fun List<EchoMediaItem>.sorted() =
        sortedBy { it.title.lowercase() }.map { it.toShelf() }

    private fun List<Shelf>.toPair(buttons: Feed.Buttons? = null) =
        PagedData.Single { this }.toFeedData(buttons)

    private fun Pair<List<Shelf>, Boolean>.toFeed() =
        first.toPair(if (second) Feed.Buttons(false, showSort = true) else null)

    override suspend fun loadSearchFeed(query: String) = Feed(
        (if (query.isBlank()) listOf("Songs", "Albums", "Artists", "Genres")
        else listOf("All", "Songs", "Albums", "Artists")).map { Tab(it, it) }
    ) { tab ->
        if (query.isBlank()) {
            if (refreshLibrary) refreshLibrary()
            when (tab?.id) {
                "Albums" -> getLibrary().albumList.map { it.toAlbum() }.sorted().toPair(
                    Feed.Buttons(showSearch = false, showSort = true)
                )

                "Artists" -> getLibrary().artistMap.values.map { it.toArtist() }.sorted().toPair(
                    Feed.Buttons(showSearch = false, showSort = true)
                )

                "Genres" -> getLibrary().genreList.map { it.toShelf() }.toPair()
                else -> getLibrary().songList.sortedByDescending {
                    it.extras["addDate"]?.toLongOrNull()
                }.map { it.toShelf() }.toPair(
                    Feed.Buttons(
                        showSearch = false, showSort = true, showPlayAndShuffle = true
                    )
                )
            }
        } else {
            val tracks = getLibrary().songList.map { it }.searchBy(query) {
                listOf(it.title, it.album?.title) + it.artists.map { artist -> artist.name }
            }
            val albums = getLibrary().albumList.map { it.toAlbum() }.searchBy(query) {
                listOf(it.title) + it.artists.map { artist -> artist.name }
            }
            val artists = getLibrary().artistMap.values.map { it.toArtist() }.searchBy(query) {
                listOf(it.name)
            }

            when (tab?.id) {
                "Songs" -> tracks.map { it.second.toShelf() } to true
                "Albums" -> albums.map { it.second.toShelf() } to true
                "Artists" -> artists.map { it.second.toShelf() } to true
                else -> {
                    val items = listOf(
                        "Songs" to tracks, "Albums" to albums, "Artist" to artists
                    ).sortedBy { it.second.firstOrNull()?.first ?: 20 }
                        .map { it.first to it.second.map { pair -> pair.second } }
                        .filter { it.second.isNotEmpty() }

                    val exactMatch = items.firstNotNullOfOrNull {
                        it.second.find { item -> item.title.contains(query, true) }
                    }?.toShelf()

                    val containers = items.map { (title, items) ->
                        val id = "${query}_$title"
                        Shelf.Lists.Items(id, title, items, more = items.toShelves())
                    }

                    listOf(listOfNotNull(exactMatch), containers).flatten() to false
                }
            }.toFeed()
        }
    }

    override suspend fun loadLibraryFeed() = Feed(
        listOf("Playlists", "Folders").map { Tab(it, it) }
    ) { tab ->
        if (refreshLibrary) refreshLibrary()
        val pagedData: PagedData<Shelf> = when (tab?.id) {
            "Folders" -> getLibrary().folderStructure.folderList.entries.firstOrNull()?.value
                ?.toShelf(context, null)?.feed?.getPagedData?.invoke(null)?.pagedData
                ?: PagedData.Single { listOf() }

            else -> PagedData.Single {
                getLibrary().playlistList.map { it.toPlaylist().toShelf() }
            }
        }
        pagedData.toFeedData(Feed.Buttons())
    }

    override suspend fun listEditablePlaylists(track: Track?) = getLibrary().playlistList.map {
        val has = it.songList.any { song -> song.id == track?.id }
        it.toPlaylist() to has
    }

    override suspend fun likeItem(item: EchoMediaItem, shouldLike: Boolean) {
        val library = getLibrary()
        val playlist = library.likedPlaylist?.id
            ?: throw ClientException.NotSupported("Couldn't create Liked Playlist")
        if (shouldLike) context.addSongToPlaylist(playlist, item.id.toLong(), 0)
        else {
            val index = library.likedPlaylist.songList.indexOfFirst { it.id == item.id }
            context.removeSongFromPlaylist(playlist, index)
        }
        refreshLibrary()
    }

    override suspend fun isItemLiked(item: EchoMediaItem) =
        getLibrary().likedPlaylist?.songList?.find { it.id == item.id } != null

    override suspend fun createPlaylist(title: String, description: String?): Playlist {
        val id = context.createPlaylist(title)
        refreshLibrary()
        return getLibrary().playlistList.find { it.id == id }!!.toPlaylist()
    }

    override suspend fun deletePlaylist(playlist: Playlist) {
        context.deletePlaylist(playlist.id.toLong())
        refreshLibrary()
    }

    override suspend fun editPlaylistMetadata(
        playlist: Playlist, title: String, description: String?,
    ) {
        context.editPlaylist(playlist.id.toLong(), title)
    }

    override suspend fun addTracksToPlaylist(
        playlist: Playlist, tracks: List<Track>, index: Int, new: List<Track>,
    ) {
        new.forEach {
            context.addSongToPlaylist(playlist.id.toLong(), it.id.toLong(), index)
        }
    }

    override suspend fun removeTracksFromPlaylist(
        playlist: Playlist, tracks: List<Track>, indexes: List<Int>,
    ) {
        indexes.forEach { index ->
            context.removeSongFromPlaylist(playlist.id.toLong(), index)
        }
    }

    override suspend fun moveTrackInPlaylist(
        playlist: Playlist, tracks: List<Track>, fromIndex: Int, toIndex: Int,
    ) {
        val song = tracks[fromIndex].id.toLong()
        context.moveSongInPlaylist(playlist.id.toLong(), song, fromIndex, toIndex)
    }

    override suspend fun onEnterPlaylistEditor(playlist: Playlist, tracks: List<Track>) {}
    override suspend fun onExitPlaylistEditor(playlist: Playlist, tracks: List<Track>) {
        refreshLibrary()
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\test\DownloadExtension.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.test

import android.content.Context
import com.joaomagdaleno.music_hub.common.MusicExtension
import com.joaomagdaleno.music_hub.common.clients.AlbumClient
import com.joaomagdaleno.music_hub.common.clients.DownloadClient
import com.joaomagdaleno.music_hub.common.clients.PlaylistClient
import com.joaomagdaleno.music_hub.common.clients.RadioClient
import com.joaomagdaleno.music_hub.common.models.Album
import com.joaomagdaleno.music_hub.common.models.DownloadContext
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.loadAll
import com.joaomagdaleno.music_hub.common.models.ImportType
import com.joaomagdaleno.music_hub.common.models.Metadata
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.common.models.Progress
import com.joaomagdaleno.music_hub.common.models.Radio
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.common.providers.MusicExtensionsProvider
import com.joaomagdaleno.music_hub.common.settings.Setting
import com.joaomagdaleno.music_hub.common.settings.Settings
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getAs
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import java.io.File

class DownloadExtension(
    val context: Context
) : DownloadClient, MusicExtensionsProvider {

    companion object {
        val metadata = Metadata(
            "DownloadExtension",
            "",
            ImportType.BuiltIn,
            ExtensionType.MISC,
            "test_download",
            "Test Download Extension",
            "1.0.0",
            "Test extension for download testing",
            "Test",
        )
    }

    override val concurrentDownloads = 2

    override suspend fun selectServer(context: DownloadContext): Streamable {
        return context.track.servers.first()
    }

    override suspend fun selectSources(
        context: DownloadContext, server: Streamable.Media.Server
    ): List<Streamable.Source> {
        return server.sources
    }

    override suspend fun download(
        progressFlow: MutableStateFlow<Progress>,
        context: DownloadContext,
        source: Streamable.Source
    ) = test(progressFlow, "Downloading", 10000)

    override suspend fun merge(
        progressFlow: MutableStateFlow<Progress>,
        context: DownloadContext,
        files: List<File>
    ) = test(progressFlow, "Merging", 5000)

    override suspend fun tag(
        progressFlow: MutableStateFlow<Progress>,
        context: DownloadContext,
        file: File
    ) = test(progressFlow, "Tagging", 2000)

    override suspend fun getDownloadTracks(
        extensionId: String,
        item: EchoMediaItem,
        context: EchoMediaItem?
    ): List<DownloadContext> {
        return when (item) {
            is Track -> listOf(DownloadContext(extensionId, item))
            is EchoMediaItem.Lists -> {
                val ext = exts.first { it.id == extensionId }
                val tracks = when (item) {
                    is Album -> ext.getAs<AlbumClient, List<Track>> {
                        val album = loadAlbum(item)
                        val tracks = loadTracks(album)!!.loadAll()
                        tracks
                    }

                    is Playlist -> ext.getAs<PlaylistClient, List<Track>> {
                        val album = loadPlaylist(item)
                        val tracks = loadTracks(album).loadAll()
                        tracks
                    }

                    is Radio -> ext.getAs<RadioClient, List<Track>> {
                        val radio = loadRadio(item)
                        loadTracks(radio).loadAll()
                    }

                }.getOrThrow()
                tracks.mapIndexed { index, track ->
                    DownloadContext(extensionId, track, index, item)
                }
            }

            else -> listOf()
        }
    }

    private suspend fun test(
        progressFlow: MutableSharedFlow<Progress>,
        type: String,
        crash: Long
    ): File {
        progressFlow.emit(Progress(crash, 0))
        var it = 0L
        while (it < crash) {
            delay(1)
            progressFlow.emit(Progress(crash, it))
            it++
        }
        if (type == "Tagging") throw Exception("Test exception in $type")
        return this.context.cacheDir
    }

    override suspend fun getSettingItems() = listOf<Setting>()
    override fun setSettings(settings: Settings) {}
    override val requiredMusicExtensions = listOf<String>()

    private lateinit var exts: List<MusicExtension>
    override fun setMusicExtensions(extensions: List<MusicExtension>) {
        exts = extensions
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\test\TestExtension.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.test

import com.joaomagdaleno.music_hub.common.clients.ArtistClient
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.clients.FollowClient
import com.joaomagdaleno.music_hub.common.clients.HideClient
import com.joaomagdaleno.music_hub.common.clients.HomeFeedClient
import com.joaomagdaleno.music_hub.common.clients.LibraryFeedClient
import com.joaomagdaleno.music_hub.common.clients.LikeClient
import com.joaomagdaleno.music_hub.common.clients.LoginClient
import com.joaomagdaleno.music_hub.common.clients.LoginClient.InputField
import com.joaomagdaleno.music_hub.common.clients.LyricsSearchClient
import com.joaomagdaleno.music_hub.common.clients.RadioClient
import com.joaomagdaleno.music_hub.common.clients.SaveClient
import com.joaomagdaleno.music_hub.common.clients.ShareClient
import com.joaomagdaleno.music_hub.common.clients.TrackClient
import com.joaomagdaleno.music_hub.common.clients.TrackerMarkClient
import com.joaomagdaleno.music_hub.common.helpers.ContinuationCallback.Companion.await
import com.joaomagdaleno.music_hub.common.helpers.PagedData
import com.joaomagdaleno.music_hub.common.helpers.WebViewClient
import com.joaomagdaleno.music_hub.common.helpers.WebViewRequest
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.Feed
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.toFeed
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.toFeedData
import com.joaomagdaleno.music_hub.common.models.ImageHolder.Companion.toImageHolder
import com.joaomagdaleno.music_hub.common.models.ImportType
import com.joaomagdaleno.music_hub.common.models.Lyrics
import com.joaomagdaleno.music_hub.common.models.Metadata
import com.joaomagdaleno.music_hub.common.models.NetworkRequest
import com.joaomagdaleno.music_hub.common.models.NetworkRequest.Companion.toGetRequest
import com.joaomagdaleno.music_hub.common.models.Radio
import com.joaomagdaleno.music_hub.common.models.Shelf
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Streamable.Media.Companion.toBackgroundMedia
import com.joaomagdaleno.music_hub.common.models.Streamable.Media.Companion.toServerMedia
import com.joaomagdaleno.music_hub.common.models.Streamable.Media.Companion.toSubtitleMedia
import com.joaomagdaleno.music_hub.common.models.Streamable.Source.Companion.toSource
import com.joaomagdaleno.music_hub.common.models.Tab
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.common.models.TrackDetails
import com.joaomagdaleno.music_hub.common.models.User
import com.joaomagdaleno.music_hub.common.providers.WebViewClientProvider
import com.joaomagdaleno.music_hub.common.settings.Setting
import com.joaomagdaleno.music_hub.common.settings.Settings
import kotlinx.coroutines.delay
import okhttp3.OkHttpClient
import okhttp3.Request
import kotlin.random.Random

@Suppress("unused")
class TestExtension : ExtensionClient, LoginClient.CustomInput, TrackClient, LoginClient.WebView,
    HomeFeedClient, FollowClient, RadioClient, WebViewClientProvider, ArtistClient,
    LyricsSearchClient, LibraryFeedClient,
    SaveClient, LikeClient, HideClient, TrackerMarkClient, ShareClient {

    companion object {
        val metadata = Metadata(
            "TestExtension",
            "",
            ImportType.BuiltIn,
            ExtensionType.MUSIC,
            "test",
            "Test Extension",
            "1.0.0",
            "Test extension for offline testing",
            "Test",
            icon = "https://yt3.googleusercontent.com/UMGZZMPQkM3kGtyW4jNE1GtpSrydfNJdbG1UyWTp5zeqUYc6-rton70Imm7B11RulRRuK521NQ=s160-c-k-c0x00ffffff-no-rj".toImageHolder()
        )

        const val FUN =
            "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerFun.mp4"

        const val BUNNY =
            "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"

        const val M3U8 =
            "https://fl3.moveonjoy.com/CNBC/index.m3u8"

        const val SUBTITLE =
            "https://raw.githubusercontent.com/brenopolanski/html5-video-webvtt-example/master/MIB2-subtitles-pt-BR.vtt"

        private fun createTrack(id: String, title: String, streamables: List<Streamable>) = Track(
            id,
            title,
            cover = "https://picsum.photos/seed/$id/300".toImageHolder(),
            isExplicit = Random.nextBoolean(),
            streamables = streamables
        ).toShelf()
    }

    override suspend fun getSettingItems() = listOf<Setting>()
    override fun setSettings(settings: Settings) {}

    override val forms = listOf(
        LoginClient.Form(
            "bruh",
            "Test Form",
            InputField.Type.Username,
            listOf(
                InputField(InputField.Type.Username, "name", "Name", true),
                InputField(InputField.Type.Password, "password", "Password", false),
                InputField(InputField.Type.Email, "email", "EMail", false),
                InputField(InputField.Type.Misc, "text", "Text", false),
                InputField(InputField.Type.Number, "number", "Number", false),
                InputField(InputField.Type.Url, "url", "Url", false),
            )
        )
    )

    override suspend fun onLogin(key: String, data: Map<String, String?>): List<User> {
        return listOf(
            User(
                key,
                "$key User",
                "https://picsum.photos/seed/$key/200".toImageHolder(),
            )
        )
    }

    override val webViewRequest = object : WebViewRequest.Cookie<List<User>> {
        override suspend fun onStop(url: NetworkRequest, cookie: String): List<User> {
            return listOf(
                User(
                    "test_user",
                    "WebView User",
                    "https://picsum.photos/seed/test_user/200".toImageHolder(),
                )
            )
        }

        override val initialUrl = "https://www.example.com/".toGetRequest()
        override val stopUrlRegex = "https://www\\.iana\\.org/.*".toRegex()
    }

    override fun setLoginUser(user: User?) {
//        println("setLoginUser: $user")
    }

    override suspend fun getCurrentUser(): User? = null

    override suspend fun loadStreamableMedia(
        streamable: Streamable, isDownload: Boolean,
    ): Streamable.Media {
        if (streamable.quality == 3) throw Exception("Test exception for quality 3")
        return when (streamable.type) {
            Streamable.MediaType.Background -> streamable.id.toBackgroundMedia()
            Streamable.MediaType.Server -> {
                val srcs = Srcs.valueOf(streamable.id)
                when (srcs) {
                    Srcs.Single -> FUN.toServerMedia()
                    Srcs.Merged -> Streamable.Media.Server(
                        listOf(
                            BUNNY.toSource(),
                            FUN.toSource(),
                        ), false
                    )

                    Srcs.M3U8 -> M3U8.toServerMedia(type = Streamable.SourceType.HLS)
                }
            }

            Streamable.MediaType.Subtitle -> streamable.id.toSubtitleMedia(Streamable.SubtitleType.VTT)
        }
    }

    override suspend fun loadFeed(track: Track): Feed<Shelf>? = null

    enum class Srcs {
        Single, Merged, M3U8;

        fun createTrack() = createTrack(
            name, name, listOf(Streamable.subtitle(SUBTITLE)) + (0..5).map { i ->
                Streamable.server(this.name, i)
            }
        )
    }

    private lateinit var webViewClient: WebViewClient
    override fun setWebViewClient(webViewClient: WebViewClient) {
        this.webViewClient = webViewClient
    }

    override suspend fun loadHomeFeed(): Feed<Shelf> = Feed(
        listOf("All", "Music", "Podcasts").map { Tab(it, it) }
    ) { tab ->
        if (tab?.id == "Podcasts") {
            throw Exception("Test exception for Podcasts tab")
//            return@Feed PagedData.empty<Shelf>().toFeedData()
        }
        PagedData.Single {
            if (tab?.id == "Music") delay(5000)
            OkHttpClient().newCall(
                Request.Builder().url("https://example.com").build()
            ).await().body
            listOf(
                Shelf.Lists.Categories(
                    "bruh",
                    "Bruh ${tab?.title}",
                    listOf(
                        "Burhhhhhhh", "brjdksls", "sbajkxclllll", "a", "b", " b"
                    ).map { Shelf.Category(it, it, loadHomeFeed()) }
                ),
                Shelf.Lists.Categories(
                    "bruh",
                    "Bruh ${tab?.title}",
                    listOf(
                        "Burhhhhhhh", "brjdksls", "sbajkxclllll", "a", "b", " b"
                    ).map { Shelf.Category(it, it, loadHomeFeed()) },
                    type = Shelf.Lists.Type.Grid
                ),
                Artist(
                    "bruh",
                    "Bruh",
                    cover = "https://www.easygifanimator.net/images/samples/video-to-gif-sample.gif"
                        .toImageHolder()
                ).toShelf(),
                Track("not", "Not Playable", isPlayable = Track.Playable.Unreleased).toShelf(),
                createTrack(
                    "all", "All", listOf(
                        Streamable.server(Srcs.Single.name, 0),
                        Streamable.server(Srcs.Merged.name, 0),
                        Streamable.server(Srcs.M3U8.name, 0),
                        Streamable.subtitle(SUBTITLE)
                    )
                ),
                Srcs.Single.createTrack(),
                Srcs.Merged.createTrack(),
                Srcs.M3U8.createTrack()
            )
        }.toFeedData(background = "https://picsum.photos/id/21/400/300".toImageHolder())
    }

    private val radio = Radio("empty", "empty")
    override suspend fun loadRadio(radio: Radio) = radio
    override suspend fun loadTracks(radio: Radio) = listOf(
        Track("", "Bruh")
    ).toFeed()

    override suspend fun radio(item: EchoMediaItem, context: EchoMediaItem?) = radio


    override suspend fun loadFeed(artist: Artist) = PagedData.Single<Shelf> {
        listOf(
            Srcs.Single.createTrack(),
            artist.toShelf(),
        )
    }.toFeed()

    override suspend fun loadArtist(artist: Artist) = artist

    private var isSaved = false
    override suspend fun saveToLibrary(item: EchoMediaItem, shouldSave: Boolean) {
        println(item.extras["loaded"])
        isSaved = shouldSave
        println("save $shouldSave")
    }

    override suspend fun isItemSaved(item: EchoMediaItem): Boolean {
        println(item.extras["loaded"])
        println("isSaved : $isSaved")
        return isSaved
    }


    private var isLiked = false
    override suspend fun likeItem(item: EchoMediaItem, shouldLike: Boolean) {
        println(item.extras["loaded"])
        isLiked = shouldLike
        println("like $shouldLike")
    }

    override suspend fun isItemLiked(item: EchoMediaItem): Boolean {
        println(item.extras["loaded"])
        println("isLiked : $isLiked")
        return isLiked
    }

    private var isHidden = false
    override suspend fun hideItem(item: EchoMediaItem, shouldHide: Boolean) {
        println("hide")
        this.isHidden = shouldHide
    }

    override suspend fun isItemHidden(item: EchoMediaItem): Boolean {
        println("isHidden : $isHidden")
        return isHidden
    }

    override suspend fun loadTrack(track: Track, isDownload: Boolean): Track = track.copy(
        extras = mapOf("loaded" to "Loaded bro")
    )

    override suspend fun onTrackChanged(details: TrackDetails?) {
        println("onTrackChanged : $details")
    }

    override suspend fun onPlayingStateChanged(details: TrackDetails?, isPlaying: Boolean) {
        println("onPlayingStateChanged $isPlaying : $details")
    }

    override suspend fun getMarkAsPlayedDuration(details: TrackDetails) = 10000L
    override suspend fun onMarkAsPlayed(details: TrackDetails) {
        println("onMarkAsPlayed : $details")
    }

    private var isFollowing = false
    override suspend fun isFollowing(item: EchoMediaItem) = isFollowing
    override suspend fun getFollowersCount(item: EchoMediaItem): Long = 1000L
    override suspend fun followItem(item: EchoMediaItem, shouldFollow: Boolean) {
        println("followItem: $item, follow: $shouldFollow")
        isFollowing = shouldFollow
    }

    override suspend fun onShare(item: EchoMediaItem): String {
        return "https://example.com/${item.id}"
    }

    val lyrics = listOf(
        Lyrics("1", "Test Lyrics 1", lyrics = Lyrics.Simple("First line\nSecond line\nThird line")),
        Lyrics(
            "2", "Test Lyrics 2", lyrics = Lyrics.Timed(
                listOf(
                    Lyrics.Item("First line", 0, 1000),
                    Lyrics.Item("Second line", 1000, 2000),
                    Lyrics.Item("Third line", 2000, 3000)
                )
            )
        ),
        Lyrics(
            "3", "Test Lyrics 3", lyrics = Lyrics.WordByWord(
                listOf(
                    listOf(Lyrics.Item("First", 0, 500), Lyrics.Item("line", 500, 1000)),
                    listOf(Lyrics.Item("Second", 1000, 1500), Lyrics.Item("line", 1500, 2000)),
                    listOf(Lyrics.Item("Third", 2000, 2500), Lyrics.Item("line", 2500, 3000))
                )
            )
        ),
    )

    override suspend fun searchLyrics(query: String): Feed<Lyrics> = Feed(
        listOf("Simple", "Timed", "WordByWord", "All").map { Tab(it, it) }
    ) { tab ->
        delay(3000)
        val burh = when (tab?.id) {
            "Simple" -> lyrics.filter { it.lyrics is Lyrics.Simple }
            "Timed" -> lyrics.filter { it.lyrics is Lyrics.Timed }
            "WordByWord" -> lyrics.filter { it.lyrics is Lyrics.WordByWord }
            else -> lyrics
        }
        burh.toFeedData()
    }

    override suspend fun searchTrackLyrics(clientId: String, track: Track) = run {
        delay(5000)
        lyrics.toFeed()
    }

    override suspend fun loadLyrics(lyrics: Lyrics) = lyrics
    override suspend fun loadLibraryFeed() = (0..10).map {
        createTrack("lib_$it", "Library Track $it", listOf(Streamable.server(Srcs.Single.name, 0)))
    }.toFeed<Shelf>(Feed.Buttons(showPlayAndShuffle = true))

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\test\TrackerTestExtension.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.test

import com.joaomagdaleno.music_hub.common.clients.TrackerMarkClient
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.ImportType
import com.joaomagdaleno.music_hub.common.models.Metadata
import com.joaomagdaleno.music_hub.common.models.TrackDetails
import com.joaomagdaleno.music_hub.common.settings.Setting
import com.joaomagdaleno.music_hub.common.settings.Settings

class TrackerTestExtension : TrackerMarkClient {
    companion object {
        val metadata = Metadata(
            "TrackerTestExtension",
            "",
            ImportType.BuiltIn,
            ExtensionType.TRACKER,
            "test",
            "Tracker Test Extension",
            "1.0.0",
            "Test extension for offline testing",
            "Test",
        )
    }

    override suspend fun getSettingItems() = listOf<Setting>()
    override fun setSettings(settings: Settings) {}

    override suspend fun onTrackChanged(details: TrackDetails?) {
        println("onTrackChanged ${details?.track?.id}")
    }

    override suspend fun getMarkAsPlayedDuration(details: TrackDetails): Long? {
        return details.totalDuration?.div(3)
    }

    override suspend fun onMarkAsPlayed(details: TrackDetails) {
        println("onMarkAsPlayed: ${details.track.id}")
    }

    override suspend fun onPlayingStateChanged(details: TrackDetails?, isPlaying: Boolean) {
        println("onPlayingStateChanged $isPlaying: ${details?.track?.id}")
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\unified\UnifiedDatabase.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.unified

import android.content.Context
import androidx.core.net.toUri
import androidx.room.Dao
import androidx.room.Database
import androidx.room.Delete
import androidx.room.Entity
import androidx.room.Insert
import androidx.room.OnConflictStrategy.Companion.REPLACE
import androidx.room.PrimaryKey
import androidx.room.Query
import androidx.room.RoomDatabase
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.Date
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.ImageHolder
import com.joaomagdaleno.music_hub.common.models.ImageHolder.Companion.toResourceUriImageHolder
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedDatabase.PlaylistEntity.Companion.toEntity
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedDatabase.PlaylistTrackEntity.Companion.toTrackEntity
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedDatabase.SavedEntity.Companion.toEntity
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.EXTENSION_ID
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.UNIFIED_ID
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.extensionId
import com.joaomagdaleno.music_hub.utils.Serializer.toData
import com.joaomagdaleno.music_hub.utils.Serializer.toJson
import java.io.File
import java.util.Calendar

@Database(
    entities = [
        UnifiedDatabase.PlaylistEntity::class,
        UnifiedDatabase.PlaylistTrackEntity::class,
        UnifiedDatabase.SavedEntity::class,
    ],
    version = 6,
    exportSchema = false
)
abstract class UnifiedDatabase : RoomDatabase() {
    abstract fun playlistDao(): PlaylistDao

    private val dao by lazy { playlistDao() }

    suspend fun getCreatedPlaylists(): List<Playlist> {
        return dao.getPlaylists().filter { it.actualId.isEmpty() }.map { it.playlist }
    }

    suspend fun getSaved(): List<EchoMediaItem> {
        return dao.getSaved().mapNotNull { it.item.getOrNull() }
    }

    suspend fun isSaved(item: EchoMediaItem): Boolean {
        val extId = item.extras.extensionId
        return dao.isSaved(item.id, extId)
    }

    suspend fun save(item: EchoMediaItem) {
        dao.insertSaved(item.toEntity())
    }

    suspend fun deleteSaved(item: EchoMediaItem) {
        dao.deleteSaved(item.toEntity())
    }

    private fun getDateNow(): Date {
        val calendar = Calendar.getInstance()
        calendar.time = java.util.Date()
        return Date(
            year = calendar.get(Calendar.YEAR),
            month = calendar.get(Calendar.MONTH),
            day = calendar.get(Calendar.DAY_OF_MONTH),
        )
    }

    suspend fun getLikedPlaylist(context: Context): Playlist {
        val liked = dao.getPlaylist("Liked")
        return if (liked == null) {
            val playlist = PlaylistEntity(
                0,
                getDateNow().toJson(),
                "Liked",
                context.getString(R.string.unified_liked_playlist_summary),
                null,
                "[]"
            )
            val id = dao.insertPlaylist(playlist)
            playlist.copy(id = id).playlist
        } else liked.playlist
    }

    suspend fun createPlaylist(
        title: String,
        description: String?,
        cover: ImageHolder? = null,
        actualId: String = "",
    ): Playlist {
        val playlist = PlaylistEntity(
            0,
            getDateNow().toJson(),
            title,
            description ?: "",
            cover?.toJson(),
            "[]",
            actualId
        )
        val id = dao.insertPlaylist(playlist)
        return playlist.copy(id = id).playlist
    }

    suspend fun deletePlaylist(playlist: Playlist) {
        dao.deleteAllTracks(playlist.id.toLong())
        dao.deletePlaylist(playlist.toEntity())
    }

    suspend fun editPlaylistMetadata(playlist: Playlist, title: String, description: String?) {
        val entity = playlist.toEntity().copy(name = title, description = description ?: "")
        dao.insertPlaylist(entity)
    }

    suspend fun editPlaylistCover(playlist: Playlist, file: File?) {
        val image: ImageHolder? = file?.toUri()?.toString()?.toResourceUriImageHolder(true)
        val entity = playlist.toEntity().copy(
            cover = image?.toJson()
        )
        dao.insertPlaylist(entity)
    }

    suspend fun loadPlaylist(playlist: Playlist): Playlist {
        val entity = dao.getPlaylist(playlist.toEntity().id)
        val tracks = dao.getTracks(entity.id).map { it.track }
        if (tracks.isEmpty()) return playlist.copy(trackCount = 0, duration = null)
        val durations = tracks.mapNotNull { it.duration }
        val average = durations.average().toLong()
        return entity.playlist.copy(
            trackCount = tracks.size.toLong(),
            duration = average * tracks.size
        )
    }

    suspend fun getTracks(playlist: Playlist): List<Track> {
        val entity = dao.getPlaylist(playlist.toEntity().id)
        val tracks = dao.getTracks(entity.id).associateBy { it.eid }
        if (tracks.isEmpty()) return emptyList()
        return entity.list.map { tracks[it]!!.track }
    }

    suspend fun addTracksToPlaylist(
        playlist: Playlist, index: Int, new: List<Track>,
    ) {
        if (new.isEmpty()) return
        val entity = dao.getPlaylist(playlist.toEntity().id)
        val newTracks = new.map {
            val trackEntity = PlaylistTrackEntity(
                0, entity.id, it.id, it.extras.extensionId, it.toJson()
            )
            dao.insertPlaylistTrack(trackEntity)
        }
        val newEntity = entity.copy(
            listData = entity.list.toMutableList().apply {
                addAll(index, newTracks)
            }.toJson()
        )
        dao.insertPlaylist(newEntity)
    }

    suspend fun removeTracksFromPlaylist(
        playlist: Playlist, tracks: List<Track>, indexes: List<Int>,
    ) {
        val entities = indexes.map { tracks[it].toTrackEntity() }
        entities.forEach { dao.deletePlaylistTrack(it) }
        val entity = dao.getPlaylist(playlist.toEntity().id)
        val newEntity = entity.copy(
            listData = entity.list.toMutableList().apply {
                entities.forEach {
                    val index = indexOf(it.eid)
                    if (index != -1) removeAt(index)
                }
            }.toJson()
        )
        dao.insertPlaylist(newEntity)
    }

    suspend fun moveTrack(playlist: Playlist, fromIndex: Int, toIndex: Int) {
        val entity = dao.getPlaylist(playlist.toEntity().id)
        val newEntity = entity.copy(
            listData = entity.list.toMutableList().apply {
                add(toIndex, removeAt(fromIndex))
            }.toJson()
        )
        dao.insertPlaylist(newEntity)
    }

    suspend fun isLiked(track: Track): Boolean {
        val liked = dao.getPlaylist("Liked") ?: return false
        return dao.getTracks(liked.id)
            .any { it.trackId == track.id && it.extId == track.extras.extensionId }
    }

    suspend fun getOrCreate(app: Context, context: EchoMediaItem): Playlist {
        return dao.getPlaylistByActualId(context.id)?.playlist ?: createPlaylist(
            context.title,
            app.getString(R.string.downloaded_x, ""),
            context.cover,
            context.id
        )
    }

    suspend fun getPlaylist(mediaItem: EchoMediaItem): Playlist? {
        return dao.getPlaylistByActualId(mediaItem.id)?.playlist
    }

    @Dao
    interface PlaylistDao {
        @Query("SELECT * FROM PlaylistEntity")
        suspend fun getPlaylists(): List<PlaylistEntity>

        @Query("SELECT * FROM PlaylistEntity WHERE id = :id")
        suspend fun getPlaylist(id: Long): PlaylistEntity

        @Query("SELECT * FROM PlaylistEntity WHERE name = :name")
        suspend fun getPlaylist(name: String): PlaylistEntity?

        @Query("SELECT * FROM PlaylistEntity WHERE actualId = :actualId")
        suspend fun getPlaylistByActualId(actualId: String): PlaylistEntity?

        @Insert(onConflict = REPLACE)
        suspend fun insertPlaylist(playlist: PlaylistEntity): Long

        @Delete
        suspend fun deletePlaylist(playlist: PlaylistEntity)

        @Query("SELECT * FROM PlaylistTrackEntity WHERE playlistId = :playlistId")
        suspend fun getTracks(playlistId: Long): List<PlaylistTrackEntity>

        @Insert(onConflict = REPLACE)
        suspend fun insertPlaylistTrack(playlistTrack: PlaylistTrackEntity): Long

        @Delete
        suspend fun deletePlaylistTrack(playlistTrack: PlaylistTrackEntity)

        @Query("DELETE FROM PlaylistTrackEntity WHERE playlistId = :playlistId")
        suspend fun deleteAllTracks(playlistId: Long)

        @Query("SELECT * FROM SavedEntity")
        suspend fun getSaved(): List<SavedEntity>

        @Query("SELECT EXISTS(SELECT 1 FROM SavedEntity WHERE id = :id AND extId = :extId)")
        suspend fun isSaved(id: String, extId: String): Boolean

        @Insert(onConflict = REPLACE)
        suspend fun insertSaved(saved: SavedEntity): Long

        @Delete
        suspend fun deleteSaved(saved: SavedEntity)

        @Query("SELECT * FROM PlaylistTrackEntity WHERE eid = :eid")
        suspend fun getTrack(eid: Long?): PlaylistTrackEntity?

        @Query("SELECT * FROM PlaylistTrackEntity WHERE \"after\" = :eid")
        suspend fun getAfterTrack(eid: Long): PlaylistTrackEntity?
    }

    @Entity
    data class PlaylistEntity(
        @PrimaryKey(true)
        val id: Long,
        val modified: String,
        val name: String,
        val description: String,
        val cover: String?,
        val listData: String,
        val actualId: String = "",
    ) {
        val list by lazy {
            listData.toData<List<Long>>().getOrThrow()
        }

        val playlist by lazy {
            Playlist(
                id.toString(),
                name,
                true,
                cover = cover?.toData<ImageHolder?>()?.getOrThrow(),
                creationDate = modified.toData<Date>().getOrNull(),
                description = description.takeIf { it.isNotBlank() },
                extras = mapOf(
                    EXTENSION_ID to UNIFIED_ID,
                    "listData" to listData,
                    "actualId" to actualId
                )
            )
        }

        companion object {
            fun Playlist.toEntity(): PlaylistEntity {
                return PlaylistEntity(
                    id.toLong(),
                    creationDate.toJson(),
                    title,
                    description ?: "",
                    cover?.toJson(),
                    extras["listData"] ?: "[]",
                    extras["actualId"] ?: ""
                )
            }
        }
    }

    @Entity
    data class PlaylistTrackEntity(
        @PrimaryKey(autoGenerate = true)
        val eid: Long,
        val playlistId: Long,
        val trackId: String,
        val extId: String,
        val data: String,
    ) {
        val track by lazy {
            data.toData<Track>().getOrThrow().run {
                this.copy(
                    type = type,
                    extras = extras + mapOf(
                        "pId" to playlistId.toString(),
                        "eId" to eid.toString(),
                    )
                )
            }
        }

        companion object {
            fun Track.toTrackEntity(): PlaylistTrackEntity {
                val pId = extras["pId"]!!.toLong()
                val eId = extras["eId"]!!.toLong()
                return PlaylistTrackEntity(eId, pId, id, extras.extensionId, this.toJson())
            }
        }
    }

    @Entity(primaryKeys = ["id", "extId"])
    data class SavedEntity(
        val id: String,
        val extId: String,
        val data: String,
    ) {
        val item by lazy { data.toData<EchoMediaItem>() }

        companion object {
            fun EchoMediaItem.toEntity(): SavedEntity {
                val extId = extras.extensionId
                return SavedEntity(id, extId, this.toJson())
            }
        }
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\builtin\unified\UnifiedExtension.kt ----------
package com.joaomagdaleno.music_hub.extensions.builtin.unified

import android.content.Context
import androidx.annotation.OptIn
import androidx.media3.common.util.UnstableApi
import androidx.media3.datasource.cache.SimpleCache
import androidx.room.Room
import com.joaomagdaleno.music_hub.BuildConfig
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.MusicExtension
import com.joaomagdaleno.music_hub.common.clients.AlbumClient
import com.joaomagdaleno.music_hub.common.clients.ArtistClient
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.clients.FollowClient
import com.joaomagdaleno.music_hub.common.clients.HideClient
import com.joaomagdaleno.music_hub.common.clients.HomeFeedClient
import com.joaomagdaleno.music_hub.common.clients.LibraryFeedClient
import com.joaomagdaleno.music_hub.common.clients.LikeClient
import com.joaomagdaleno.music_hub.common.clients.LyricsClient
import com.joaomagdaleno.music_hub.common.clients.PlaylistClient
import com.joaomagdaleno.music_hub.common.clients.PlaylistEditClient
import com.joaomagdaleno.music_hub.common.clients.PlaylistEditCoverClient
import com.joaomagdaleno.music_hub.common.clients.RadioClient
import com.joaomagdaleno.music_hub.common.clients.SaveClient
import com.joaomagdaleno.music_hub.common.clients.SearchFeedClient
import com.joaomagdaleno.music_hub.common.clients.ShareClient
import com.joaomagdaleno.music_hub.common.clients.TrackClient
import com.joaomagdaleno.music_hub.common.clients.TrackerClient
import com.joaomagdaleno.music_hub.common.clients.TrackerMarkClient
import com.joaomagdaleno.music_hub.common.helpers.ClientException
import com.joaomagdaleno.music_hub.common.helpers.PagedData
import com.joaomagdaleno.music_hub.common.models.Album
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.Feed
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.loadAll
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.toFeed
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.toFeedData
import com.joaomagdaleno.music_hub.common.models.ImportType
import com.joaomagdaleno.music_hub.common.models.Lyrics
import com.joaomagdaleno.music_hub.common.models.Metadata
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.common.models.Radio
import com.joaomagdaleno.music_hub.common.models.Shelf
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Tab
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.common.models.TrackDetails
import com.joaomagdaleno.music_hub.common.providers.MusicExtensionsProvider
import com.joaomagdaleno.music_hub.common.settings.SettingSwitch
import com.joaomagdaleno.music_hub.common.settings.Settings
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.extensions.cache.Cached
import com.joaomagdaleno.music_hub.extensions.exceptions.AppException.Companion.toAppException
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.toKey
import com.joaomagdaleno.music_hub.utils.CacheUtils.getFromCache
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.first
import java.io.File

@OptIn(UnstableApi::class)
class UnifiedExtension(
    private val app: App,
    private val cache: SimpleCache,
) : ExtensionClient, MusicExtensionsProvider,
    HomeFeedClient, SearchFeedClient, LibraryFeedClient,
    PlaylistClient, AlbumClient, ArtistClient, TrackClient,
    FollowClient, RadioClient, LikeClient, SaveClient, HideClient, ShareClient,
    PlaylistEditClient, PlaylistEditCoverClient, LyricsClient, TrackerMarkClient {

    companion object {
        const val UNIFIED_ID = "unified"
        const val EXTENSION_ID = "extension_id"
        val metadata = Metadata(
            "UnifiedExtension",
            "",
            ImportType.BuiltIn,
            ExtensionType.MUSIC,
            UNIFIED_ID,
            "Unified Extension",
            version = "v${BuildConfig.VERSION_CODE}",
            "All your extensions in one place!",
            "Echo",
            isEnabled = true
        )

        fun Context.getFeed(items: List<EchoMediaItem>): Feed<Shelf> {
            if (items.isEmpty()) return listOf<Shelf>().toFeed()
            val types = items.groupBy {
                when (it) {
                    is Track -> getString(R.string.track)
                    is Album -> getString(R.string.album)
                    is Artist -> getString(R.string.artists)
                    is Playlist -> getString(R.string.playlist)
                    is Radio -> getString(R.string.radio)
                }
            }
            val tabs = if (types.keys.size == 1) listOf()
            else getString(R.string.all).let { listOf(Tab(it, it)) } +
                    types.keys.map { Tab(it, it, true) }

            return Feed(tabs) { tab ->
                val items = types[tab?.id]?.toList() ?: items
                items.map { it.toShelf() }.toFeedData()
            }
        }

        suspend inline fun <reified C, T> Extension<*>.client(block: C.() -> T): T = runCatching {
            val client = instance.value().getOrThrow() as? C
                ?: throw ClientException.NotSupported(C::class.run { simpleName ?: java.name })
            client.block()
        }.getOrElse { throw it.toAppException(this) }

        suspend inline fun <reified C, T> Extension<*>.clientOrNull(block: C.() -> T): T? =
            runCatching {
                val client = instance.value().getOrThrow() as? C
                client?.block()
            }.getOrElse { throw it.toAppException(this) }

        private fun List<Extension<*>>.get(id: String?) =
            find { it.id == id } ?: throw Exception("Extension $id not found")

        private fun List<Extension<*>>.getOrNull(id: String?) = find { it.id == id }

        val Map<String, String>.extensionId
            get() = this[EXTENSION_ID] ?: throw Exception("Extension id not found")

        fun Track.withExtensionId(
            id: String, client: Any?, cached: Boolean = false,
        ) = copy(
            extras = extras + mapOf(EXTENSION_ID to id, "cached" to cached.toString()),
            album = album?.withExtensionId(id, client),
            artists = artists.map { it.withExtensionId(id, client) },
            streamables = streamables.map {
                it.copy(extras = it.extras + mapOf(EXTENSION_ID to id))
            },
            isSaveable = true,
            isLikeable = true,
            isHideable = client is HideClient && isHideable,
            isRadioSupported = client is RadioClient && isRadioSupported,
            isFollowable = client is FollowClient && isFollowable,
            isShareable = client is ShareClient && isShareable
        )

        private fun Album.withExtensionId(id: String, client: Any?) = copy(
            artists = artists.map { it.withExtensionId(id, client) },
            extras = extras + mapOf(EXTENSION_ID to id),
            isSaveable = true,
            isLikeable = false,
            isHideable = client is HideClient && isHideable,
            isRadioSupported = client is RadioClient && isRadioSupported,
            isFollowable = client is FollowClient && isFollowable,
            isShareable = client is ShareClient && isShareable
        )

        private fun Artist.withExtensionId(id: String, client: Any?) = copy(
            extras = extras + mapOf(EXTENSION_ID to id),
            isSaveable = true,
            isLikeable = false,
            isHideable = client is HideClient && isHideable,
            isRadioSupported = client is RadioClient && isRadioSupported,
            isFollowable = client is FollowClient && isFollowable,
            isShareable = client is ShareClient && isShareable
        )

        private fun Playlist.withExtensionId(id: String, client: Any?) = copy(
            isEditable = false,
            authors = authors.map { it.withExtensionId(id, client) },
            extras = extras + mapOf(EXTENSION_ID to id),
            isSaveable = true,
            isLikeable = false,
            isHideable = client is HideClient && isHideable,
            isRadioSupported = client is RadioClient && isRadioSupported,
            isFollowable = client is FollowClient && isFollowable,
            isShareable = client is ShareClient && isShareable
        )

        private fun Radio.withExtensionId(id: String, client: Any?) = copy(
            extras = extras + mapOf(EXTENSION_ID to id),
            isSaveable = true,
            isLikeable = false,
            isHideable = client is HideClient && isHideable,
            isFollowable = client is FollowClient && isFollowable,
            isShareable = client is ShareClient && isShareable
        )

        private fun EchoMediaItem.withExtensionId(
            id: String, client: Any?,
        ) = when (this) {
            is Artist -> this.withExtensionId(id, client)
            is Album -> this.withExtensionId(id, client)
            is Playlist -> this.withExtensionId(id, client)
            is Radio -> this.withExtensionId(id, client)
            is Track -> this.withExtensionId(id, client)
        }

        private fun Lyrics.withExtensionId(id: String) = copy(
            extras = extras + mapOf(EXTENSION_ID to id)
        )

        fun Shelf.Item.withExtensionId(id: String, client: Any?) = copy(
            media = media.withExtensionId(id, client)
        )

        fun Feed.Buttons.withExtensionId(extension: Extension<*>) = copy(
            customTrackList = customTrackList?.map {
                it.withExtensionId(extension.id, extension.instance.value)
            }
        )

        private fun Feed<Shelf>.injectExtensionId(extension: Extension<*>) = copy(
            tabs = tabs.map { it.injectId(extension.id) },
            getPagedData = { tab ->
                val (data, buttons, bg) = runCatching { getPagedData(tab) }.getOrElse {
                    throw it.toAppException(extension)
                }
                data.injectExtensionId(extension)
                    .toFeedData(buttons?.withExtensionId(extension), bg)
            }
        )

        private fun Feed<Track>.injectExtension(extension: Extension<*>) = copy(
            tabs = tabs.map { it.injectId(extension.id) },
            getPagedData = { tab ->
                val id = extension.id
                val (data, buttons, bg) = runCatching { getPagedData(tab) }.getOrElse {
                    throw it.toAppException(extension)
                }
                data.map { result ->
                    val list = result.getOrElse { throw it.toAppException(extension) }
                    list.map { it.withExtensionId(id, extension.instance.value) }
                }.toFeedData(buttons?.withExtensionId(extension), bg)
            }
        )

        fun Feed<Lyrics>.injectLyricsExtId(extension: Extension<*>) = copy(
            tabs = tabs.map { it.injectId(extension.id) },
        ) { tab ->
            val (data, buttons, bg) = runCatching { getPagedData(tab) }.getOrElse {
                throw it.toAppException(extension)
            }
            data.map { result ->
                val id = extension.id
                val list = result.getOrElse { throw it.toAppException(extension) }
                list.map { it.withExtensionId(id) }
            }.toFeedData(buttons?.withExtensionId(extension), bg)
        }

        private fun Shelf.Category.withExtensionId(extension: Extension<*>): Shelf.Category =
            copy(feed = feed?.injectExtensionId(extension))

        private fun PagedData<Shelf>.injectExtensionId(extension: Extension<*>): PagedData<Shelf> =
            map { result ->
                val id = extension.id
                val client = extension.instance.value
                val list = result.getOrElse { throw it.toAppException(extension) }
                list.map {
                    when (it) {
                        is Shelf.Category -> it.withExtensionId(extension)
                        is Shelf.Item -> it.withExtensionId(id, client)
                        is Shelf.Lists.Categories -> it.copy(
                            list = it.list.map { category -> category.withExtensionId(extension) },
                            more = it.more?.injectExtensionId(extension)
                        )

                        is Shelf.Lists.Items -> it.copy(
                            list = it.list.map { item -> item.withExtensionId(id, client) },
                            more = it.more?.injectExtensionId(extension)
                        )

                        is Shelf.Lists.Tracks -> it.copy(
                            list = it.list.map { track ->
                                track.withExtensionId(id, client)
                            },
                            more = it.more?.injectExtensionId(extension)
                        )
                    }
                }
            }

        fun Tab.injectId(id: String) = copy(extras = extras + mapOf(EXTENSION_ID to id))
    }

    private val context = app.context

    override suspend fun getSettingItems() = listOf(
        SettingSwitch(
            context.getString(R.string.show_tabs),
            "show_tabs",
            context.getString(R.string.show_tab_summary),
            false
        ),
    )

    private lateinit var settings: Settings
    override fun setSettings(settings: Settings) {
        this.settings = settings
    }

    private val showTabs get() = settings.getBoolean("show_tabs") ?: false

    override val requiredMusicExtensions = listOf<String>()
    private var extFlow = MutableStateFlow<List<MusicExtension>?>(null)
    suspend fun extensions() = extFlow.first { it != null }!!
    override fun setMusicExtensions(extensions: List<MusicExtension>) {
        extFlow.value = extensions.filter { it.id != UNIFIED_ID && it.metadata.isEnabled }
    }

    private suspend inline fun <reified T> Extension<*>.getFeedData(
        crossinline loadFeed: suspend T.() -> Feed<Shelf>,
    ): Feed.Data<Shelf> {
        val feed = client<T, Feed<Shelf>> { loadFeed() }.injectExtensionId(this)
        val data = feed.run { getPagedData(tabs.firstOrNull()) }
        val otherTabs = feed.tabs.drop(1).map { tab ->
            Shelf.Category(
                tab.id,
                tab.title,
                Feed(listOf()) { feed.run { getPagedData(tab) } }
            )
        }
        return if (feed.tabs.size > 1 && showTabs) {
            Feed.Data(
                PagedData.Concat(
                    PagedData.Single {
                        listOf(
                            Shelf.Lists.Categories(
                                "tabs",
                                context.getString(R.string.tabs),
                                otherTabs
                            )
                        )
                    },
                    data.pagedData
                ),
                data.buttons?.withExtensionId(this),
                data.background
            )
        } else data
    }

    private suspend inline fun <reified T> feed(
        crossinline loadFeed: suspend T.() -> Feed<Shelf>,
    ): Feed<Shelf> {
        val list = extensions()
        return if (list.size == 1) {
            val ext = list.first()
            ext.client<T, Feed<Shelf>> { loadFeed() }.injectExtensionId(ext)
        } else Feed(
            list.map { Tab(it.id, it.name).injectId(it.id) }
        ) { tab ->
            val extensions = extensions()
            val id = tab?.extras?.extensionId ?: extensions.firstOrNull()?.id
            extensions.get(id).getFeedData(loadFeed)
        }
    }

    override suspend fun loadHomeFeed() = feed<HomeFeedClient> { loadHomeFeed() }

    override suspend fun loadSearchFeed(query: String): Feed<Shelf> {
        return feed<SearchFeedClient> { loadSearchFeed(query) }
    }

    val db = Room.databaseBuilder(
        context, UnifiedDatabase::class.java, "unified-db"
    ).fallbackToDestructiveMigration(true).build()

    private suspend fun getCached() = cache.keys.mapNotNull {
        val key = context.getFromCache<String>(it, "player")
        key?.toKey()?.getOrNull()
    }.reversed().groupBy { it.trackId }.mapNotNull {
        var (id, _, extId) = it.value.first()
        val state = Cached.getMedia<Track>(app, extId, id).getOrNull()
            ?: return@mapNotNull null
        if (extId == UNIFIED_ID) extId = state.item.extras[EXTENSION_ID] ?: return@mapNotNull null
        val client = extensions().getOrNull(extId)?.instance?.value
        state.item.withExtensionId(extId, client, true)
    }

    private var cachedTracks = listOf<Track>()
    private fun cachePlaylist() = if (cachedTracks.isNotEmpty()) Playlist(
        id = "cached",
        title = context.getString(R.string.cached_songs),
        isEditable = false,
        cover = cachedTracks.first().cover,
        description = context.getString(R.string.cache_playlist_warning),
        trackCount = cachedTracks.size.toLong(),
        extras = mapOf(EXTENSION_ID to UNIFIED_ID)
    ) else null

    val downloadFeed = MutableStateFlow(listOf<EchoMediaItem>())
    override suspend fun loadLibraryFeed() = Feed(
        listOf(Tab("Unified", context.getString(R.string.all))) + extensions().map {
            Tab(it.id, it.name)
        }
    ) { tab ->
        val extension = extensions().getOrNull(tab?.id)
        extension?.getFeedData<LibraryFeedClient> { loadLibraryFeed() } ?: run {
            PagedData.Single {
                cachedTracks = getCached()
                listOfNotNull(
                    Shelf.Category(
                        "saved",
                        context.getString(R.string.saved),
                        context.getFeed(db.getSaved())
                    ),
                    Shelf.Category(
                        "downloads",
                        context.getString(R.string.downloads),
                        context.getFeed(downloadFeed.value)
                    ),
                    cachePlaylist()?.toShelf()
                ) + db.getCreatedPlaylists().map { it.toShelf() }
            }.toFeedData()
        }
    }

    override suspend fun loadRadio(radio: Radio): Radio {
        val id = radio.extras.extensionId
        val extension = extensions().get(id)
        return extension.client<RadioClient, Radio> {
            loadRadio(radio).withExtensionId(id, this)
        }
    }

    override suspend fun loadTracks(radio: Radio): Feed<Track> {
        val id = radio.extras.extensionId
        val extension = extensions().get(id)
        return extension.client<RadioClient, Feed<Track>> {
            this.loadTracks(radio).injectExtension(extension)
        }
    }

    override suspend fun radio(item: EchoMediaItem, context: EchoMediaItem?): Radio {
        val id = item.extras.extensionId
        return extensions().get(id).client<RadioClient, Radio> {
            radio(item, context).withExtensionId(id, this)
        }
    }

    override suspend fun loadTrack(track: Track, isDownload: Boolean): Track {
        val cached = track.extras["cached"]?.toBoolean() ?: false
        if (cached) return track
        val id = track.extras.extensionId
        return extensions().get(id).client<TrackClient, Track> {
            loadTrack(track, isDownload).withExtensionId(id, this)
        }
    }

    override suspend fun loadStreamableMedia(
        streamable: Streamable, isDownload: Boolean,
    ): Streamable.Media {
        val id = streamable.extras.extensionId
        return extensions().get(id).client<TrackClient, Streamable.Media> {
            loadStreamableMedia(streamable, isDownload)
        }
    }

    override suspend fun loadFeed(track: Track): Feed<Shelf>? {
        val id = track.extras.extensionId
        val extension = extensions().get(id)
        return extension.client<TrackClient, Feed<Shelf>?> {
            loadFeed(track)?.injectExtensionId(extension)
        }
    }

    override suspend fun loadAlbum(album: Album): Album {
        val id = album.extras.extensionId
        return extensions().get(id).client<AlbumClient, Album> {
            loadAlbum(album).withExtensionId(id, this)
        }
    }

    override suspend fun loadTracks(album: Album): Feed<Track>? {
        val id = album.extras.extensionId
        val extension = extensions().get(id)
        return extension.client<AlbumClient, Feed<Track>?> {
            loadTracks(album)?.injectExtension(extension)
        }
    }

    override suspend fun loadFeed(album: Album): Feed<Shelf>? {
        val id = album.extras.extensionId
        val extension = extensions().get(id)
        return extension.client<AlbumClient, Feed<Shelf>?> {
            loadFeed(album)?.injectExtensionId(extension)
        }
    }

    override suspend fun loadArtist(artist: Artist): Artist {
        val id = artist.extras.extensionId
        return extensions().get(id).client<ArtistClient, Artist> {
            loadArtist(artist).withExtensionId(id, this)
        }
    }

    override suspend fun loadFeed(artist: Artist): Feed<Shelf> {
        val id = artist.extras.extensionId
        val extension = extensions().get(id)
        return extension.client<ArtistClient, Feed<Shelf>> {
            loadFeed(artist).injectExtensionId(extension)
        }
    }

    override suspend fun loadPlaylist(playlist: Playlist): Playlist {
        val extId = playlist.extras.extensionId
        return if (extId == UNIFIED_ID) {
            if (playlist.id == "cached") cachePlaylist() ?: playlist else db.loadPlaylist(playlist)
        } else extensions().get(extId).client<PlaylistClient, Playlist> {
            loadPlaylist(playlist).withExtensionId(extId, this)
        }
    }

    override suspend fun loadTracks(playlist: Playlist): Feed<Track> {
        val id = playlist.extras.extensionId
        return if (id == UNIFIED_ID) PagedData.Single {
            if (playlist.id == "cached") cachedTracks
            else db.getTracks(playlist)
        }.toFeed()
        else {
            val extension = extensions().get(id)
            extension.client<PlaylistClient, Feed<Track>> {
                loadTracks(playlist).injectExtension(extension)
            }
        }
    }

    override suspend fun loadFeed(playlist: Playlist): Feed<Shelf>? {
        val id = playlist.extras.extensionId
        val extension = if (id != UNIFIED_ID) extensions().get(id) else return null
        return extension.client<PlaylistClient, Feed<Shelf>?> {
            loadFeed(playlist)?.injectExtensionId(extension)
        }
    }

    override suspend fun saveToLibrary(item: EchoMediaItem, shouldSave: Boolean) {
        if (shouldSave) db.save(item) else db.deleteSaved(item)
    }

    override suspend fun isItemSaved(item: EchoMediaItem): Boolean {
        return db.isSaved(item)
    }

    override suspend fun listEditablePlaylists(track: Track?) = db.getCreatedPlaylists().map {
        val has = db.getTracks(it).any { t -> t.id == track?.id }
        it to has
    }

    override suspend fun createPlaylist(title: String, description: String?): Playlist {
        return db.createPlaylist(title, description)
    }

    val coverDir = context.filesDir.resolve("unified-playlist-covers")
    override suspend fun deletePlaylist(playlist: Playlist) {
        db.deletePlaylist(playlist)
        File(coverDir, playlist.id).let {
            if (it.exists()) it.delete()
        }
    }

    override suspend fun editPlaylistMetadata(
        playlist: Playlist, title: String, description: String?
    ) {
        db.editPlaylistMetadata(playlist, title, description)
    }

    override suspend fun editPlaylistCover(
        playlist: Playlist, cover: File?
    ) {
//        coverDir.listFiles {
//            it.nameWithoutExtension == playlist.id
//        }?.firstOrNull()?.delete()
//        val savedFile = cover?.let {
//            val newFile = File(coverDir, playlist.id + "."+ it.extension)
//            it.copyTo(newFile, true)
//        }
        db.editPlaylistCover(playlist, cover)
    }

    override suspend fun addTracksToPlaylist(
        playlist: Playlist, tracks: List<Track>, index: Int, new: List<Track>,
    ) {
        db.addTracksToPlaylist(playlist, index, new)
    }

    override suspend fun removeTracksFromPlaylist(
        playlist: Playlist, tracks: List<Track>, indexes: List<Int>,
    ) {
        db.removeTracksFromPlaylist(playlist, tracks, indexes)
    }

    override suspend fun moveTrackInPlaylist(
        playlist: Playlist, tracks: List<Track>, fromIndex: Int, toIndex: Int,
    ) {
        db.moveTrack(playlist, fromIndex, toIndex)
    }

    override suspend fun searchTrackLyrics(clientId: String, track: Track): Feed<Lyrics> {
        val extId = track.extras.extensionId
        val extension = extensions().get(extId)
        return extension.clientOrNull<LyricsClient, Feed<Lyrics>> {
            searchTrackLyrics(clientId, track).injectLyricsExtId(extension)
        } ?: listOf<Lyrics>().toFeed()
    }

    override suspend fun loadLyrics(lyrics: Lyrics): Lyrics {
        val extId = lyrics.extras.extensionId
        return extensions().get(extId).client<LyricsClient, Lyrics> {
            loadLyrics(lyrics).withExtensionId(extId)
        }
    }

    private var current: Track? = null
    override suspend fun onTrackChanged(details: TrackDetails?) {
        current = details?.track
        val id = details?.track?.extras?.extensionId ?: return
        val extension = extensions().get(id)
        extension.clientOrNull<TrackerClient, Unit> { onTrackChanged(details) }
    }

    override suspend fun onMarkAsPlayed(details: TrackDetails) {
        val id = details.track.extras.extensionId
        val extension = extensions().get(id)
        extension.clientOrNull<TrackerMarkClient, Unit> { onMarkAsPlayed(details) }
    }

    override suspend fun onPlayingStateChanged(details: TrackDetails?, isPlaying: Boolean) {
        val id = details?.track?.extras?.extensionId ?: return
        val extension = extensions().get(id)
        extension.clientOrNull<TrackerClient, Unit> { onPlayingStateChanged(details, isPlaying) }
    }

    override suspend fun getMarkAsPlayedDuration(details: TrackDetails): Long? {
        val extension = extensions().get(details.track.extras.extensionId)
        return extension.clientOrNull<TrackerMarkClient, Long?> { getMarkAsPlayedDuration(details) }
    }

    override suspend fun onShare(item: EchoMediaItem): String {
        val id = item.extras.extensionId
        val extension = extensions().get(id)
        return extension.client<ShareClient, String> { onShare(item) }
    }

    override suspend fun isFollowing(item: EchoMediaItem): Boolean {
        val id = item.extras.extensionId
        val extension = extensions().get(id)
        return extension.client<FollowClient, Boolean> { isFollowing(item) }
    }

    override suspend fun getFollowersCount(item: EchoMediaItem): Long? {
        val id = item.extras.extensionId
        val extension = extensions().get(id)
        return extension.client<FollowClient, Long?> { getFollowersCount(item) }
    }

    override suspend fun followItem(item: EchoMediaItem, shouldFollow: Boolean) {
        val id = item.extras.extensionId
        val extension = extensions().get(id)
        extension.client<FollowClient, Unit> { followItem(item, shouldFollow) }
    }

    override suspend fun likeItem(item: EchoMediaItem, shouldLike: Boolean) {
        if (item !is Track) throw ClientException.NotSupported("LikeItem only supports Track")
        val likedPlaylist = db.getLikedPlaylist(context)
        val tracks = loadTracks(likedPlaylist).loadAll()
        if (shouldLike) addTracksToPlaylist(likedPlaylist, tracks, 0, listOf(item))
        else removeTracksFromPlaylist(
            likedPlaylist, tracks, listOf(tracks.indexOfFirst { it.id == item.id })
        )
    }

    override suspend fun isItemLiked(item: EchoMediaItem): Boolean {
        if (item !is Track) throw ClientException.NotSupported("IsItemLiked only supports Track")
        return db.isLiked(item)
    }

    override suspend fun hideItem(item: EchoMediaItem, shouldHide: Boolean) {
        val id = item.extras.extensionId
        val extension = extensions().get(id)
        extension.client<HideClient, Unit> { hideItem(item, shouldHide) }
    }

    override suspend fun isItemHidden(item: EchoMediaItem): Boolean {
        val id = item.extras.extensionId
        val extension = extensions().get(id)
        return extension.client<HideClient, Boolean> { isItemHidden(item) }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\cache\Cached.kt ----------
package com.joaomagdaleno.music_hub.extensions.cache

import com.mayakapps.kache.FileKache
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.clients.AlbumClient
import com.joaomagdaleno.music_hub.common.clients.ArtistClient
import com.joaomagdaleno.music_hub.common.clients.FollowClient
import com.joaomagdaleno.music_hub.common.clients.HideClient
import com.joaomagdaleno.music_hub.common.clients.LikeClient
import com.joaomagdaleno.music_hub.common.clients.LyricsClient
import com.joaomagdaleno.music_hub.common.clients.LyricsSearchClient
import com.joaomagdaleno.music_hub.common.clients.PlaylistClient
import com.joaomagdaleno.music_hub.common.clients.RadioClient
import com.joaomagdaleno.music_hub.common.clients.SaveClient
import com.joaomagdaleno.music_hub.common.clients.ShareClient
import com.joaomagdaleno.music_hub.common.clients.TrackClient
import com.joaomagdaleno.music_hub.common.helpers.Page
import com.joaomagdaleno.music_hub.common.helpers.PagedData
import com.joaomagdaleno.music_hub.common.models.Album
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Feed
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.toFeedData
import com.joaomagdaleno.music_hub.common.models.ImageHolder
import com.joaomagdaleno.music_hub.common.models.Lyrics
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.common.models.Radio
import com.joaomagdaleno.music_hub.common.models.Shelf
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Tab
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getAs
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getIf
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.isClient
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.EXTENSION_ID
import com.joaomagdaleno.music_hub.extensions.exceptions.AppException.Companion.toAppException
import com.joaomagdaleno.music_hub.utils.Serializer.toData
import com.joaomagdaleno.music_hub.utils.Serializer.toJson
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import java.io.File

object Cached {
    class NotFound(id: String) : Exception("Cache not found for $id")

    suspend inline fun <reified T> FileKache.getData(id: String) = runCatching {
        val file = get(id) ?: throw NotFound(id)
        File(file).readText().toData<T>().getOrThrow()
    }

    suspend inline fun <reified T> FileKache.putData(id: String, data: T) = runCatching {
        put(id) {
            runCatching {
                File(it).writeText(data.toJson())
            }.isSuccess
        }
    }

    suspend inline fun <reified T : EchoMediaItem> getMedia(
        app: App, extensionId: String, itemId: String,
    ) = runCatching {
        val fileCache = app.fileCache.await()
        val id = "media-$extensionId-$itemId-state"
        fileCache.getData<MediaState.Loaded<T>>(id).getOrThrow()
    }

    suspend inline fun <reified T : EchoMediaItem> loadMedia(
        app: App, extension: Extension<*>, state: MediaState<T>,
    ) = coroutineScope {
        runCatching {
            val result = runCatching {
                val new = loadItem(extension, state.item).getOrThrow()
                val isSaved = async {
                    if (new.isSaveable) extension.getIf<SaveClient, Boolean> {
                        isItemSaved(new)
                    } else null
                }
                val isFollowed = async {
                    if (new.isFollowable) extension.getIf<FollowClient, Boolean> {
                        isFollowing(new)
                    } else null
                }
                val followers = async {
                    if (new.isFollowable) extension.getIf<FollowClient, Long?> {
                        getFollowersCount(new)
                    } else null
                }
                val isLiked = async {
                    if (new.isLikeable) extension.getIf<LikeClient, Boolean> {
                        isItemLiked(new)
                    } else null
                }
                val isHidden = async {
                    if (new.isHideable) extension.getIf<HideClient, Boolean> {
                        isItemHidden(new)
                    } else null
                }
                val newState = MediaState.Loaded(
                    item = new,
                    extensionId = extension.id,
                    isSaved = isSaved.await()?.getOrThrow(),
                    isFollowed = isFollowed.await()?.getOrThrow(),
                    followers = followers.await()?.getOrThrow(),
                    isLiked = isLiked.await()?.getOrThrow(),
                    isHidden = isHidden.await()?.getOrThrow(),
                    showRadio = new.isRadioSupported && extension.isClient<RadioClient>(),
                    showShare = new.isShareable && extension.isClient<ShareClient>(),
                )
                val fileCache = app.fileCache.await()
                val id = "media-${extension.id}-${newState.item.id}-state"
                fileCache.putData(id, newState)
                newState
            }
            result.getOrElse {
                getMedia<T>(app, extension.id, state.item.id).getOrNull()
                    ?: throw it
            }
        }
    }

    suspend inline fun <reified T : EchoMediaItem> loadItem(
        extension: Extension<*>, item: T,
    ) = runCatching {
        when (item) {
            is Artist -> extension.getAs<ArtistClient, Artist> { loadArtist(item) }
            is Album -> extension.getAs<AlbumClient, Album> { loadAlbum(item) }
            is Playlist -> extension.getAs<PlaylistClient, Playlist> { loadPlaylist(item) }
            is Track -> extension.getAs<TrackClient, Track> { loadTrack(item, false) }
            is Radio -> extension.getAs<RadioClient, Radio> { loadRadio(item) }
        }.getOrThrow() as T
    }

    suspend fun loadStreamableMedia(
        app: App, extension: Extension<*>, track: Track, streamable: Streamable,
    ) = runCatching {
        val fileCache = app.fileCache.await()
        val extId = track.extras[EXTENSION_ID] ?: extension.id
        val id = "media-${extId}-${track.id}-${streamable.id}"
        val media = extension.getAs<TrackClient, Streamable.Media> {
            loadStreamableMedia(streamable, false)
        }.getOrElse { throwable ->
            fileCache.getData<Streamable.Media>(id).getOrNull() ?: throw throwable
        }
        fileCache.putData(id, media)
        media
    }

    suspend fun getTracks(
        app: App, extensionId: String, item: EchoMediaItem,
    ) = runCatching {
        if (item !is EchoMediaItem.Lists) return@runCatching null
        val itemId = item.id
        getFeed<Track>(app, extensionId, "$itemId-tracks") { it }
    }

    suspend fun loadTracks(app: App, extension: Extension<*>, item: EchoMediaItem) = runCatching {
        val feed = when (item) {
            is Album -> extension.getAs<AlbumClient, Feed<Track>?> { loadTracks(item) }
            is Playlist -> extension.getAs<PlaylistClient, Feed<Track>> { loadTracks(item) }
            is Radio -> extension.getAs<RadioClient, Feed<Track>> { loadTracks(item) }
            is Artist -> null
            is Track -> null
        }?.getOrThrow() ?: return@runCatching null
        savingFeed(app, extension, "${item.id}-tracks", feed)
    }

    suspend fun getFeed(
        app: App, extensionId: String, item: EchoMediaItem,
    ) = run {
        if (item !is EchoMediaItem.Lists) return@run null
        val itemId = item.id
        getFeedShelf(app, extensionId, itemId)
    }

    suspend fun loadFeed(app: App, extension: Extension<*>, item: EchoMediaItem) = runCatching {
        val feed = when (item) {
            is Artist -> extension.getAs<ArtistClient, Feed<Shelf>> { loadFeed(item) }
            is Album -> extension.getAs<AlbumClient, Feed<Shelf>?> { loadFeed(item) }
            is Playlist -> extension.getAs<PlaylistClient, Feed<Shelf>?> { loadFeed(item) }
            is Track -> extension.getAs<TrackClient, Feed<Shelf>?> { loadFeed(item) }
            is Radio -> null
        }?.getOrThrow() ?: return@runCatching null
        savingFeed(app, extension, item.id, feed)
    }

    suspend fun loadLyrics(app: App, extension: Extension<*>, lyrics: Lyrics) = runCatching {
        val fileCache = app.fileCache.await()
        val id = "lyrics-${extension.id}-${lyrics.id}"
        val loaded = extension.getAs<LyricsClient, Lyrics> {
            loadLyrics(lyrics)
        }.getOrElse { throwable ->
            fileCache.getData<Lyrics>(id).getOrNull() ?: throw throwable
        }
        fileCache.putData(id, loaded)
        loaded
    }

    suspend fun getLyricsFeed(
        app: App, extensionId: String, clientId: String, track: Track, query: String,
    ) = runCatching {
        val id = if (query.isEmpty()) "lyrics-$clientId-${track.id}" else "lyrics-search-$query"
        getFeed<Lyrics>(app, extensionId, id) { it }
    }

    suspend fun loadLyricsFeed(
        app: App, extension: Extension<*>, clientId: String, track: Track, query: String,
    ) = runCatching {
        val feed = if (query.isEmpty()) extension.getAs<LyricsClient, Feed<Lyrics>> {
            searchTrackLyrics(clientId, track)
        }.getOrThrow() else extension.getAs<LyricsSearchClient, Feed<Lyrics>> {
            searchLyrics(query)
        }.getOrThrow()
        val id = if (query.isEmpty()) "lyrics-$clientId-${track.id}" else "lyrics-search-$query"
        savingFeed(app, extension, id, feed)
    }

    suspend fun getFeedShelf(
        app: App, extensionId: String, feedId: String,
    ): Result<Feed<Shelf>> = runCatching {
        getFeed<Shelf>(app, extensionId, feedId) { shelf ->
            when (shelf) {
                is Shelf.Item -> shelf
                is Shelf.Category -> shelf.copy(
                    feed = getFeedShelf(app, extensionId, shelf.id).getOrNull()
                )

                is Shelf.Lists.Categories -> shelf.copy(
                    list = shelf.list.map {
                        it.copy(feed = getFeedShelf(app, extensionId, it.id).getOrNull())
                    },
                    more = getFeedShelf(app, extensionId, shelf.id).getOrNull()
                )

                is Shelf.Lists.Items -> shelf.copy(
                    more = getFeedShelf(app, extensionId, shelf.id).getOrNull()
                )

                is Shelf.Lists.Tracks -> shelf.copy(
                    more = getFeedShelf(app, extensionId, shelf.id).getOrNull()
                )
            }
        }
    }


    // FEED STUFF

    suspend inline fun <reified T : Any> getFeed(
        app: App, extensionId: String, feedId: String, crossinline transform: suspend (T) -> T,
    ): Feed<T> {
        val fileCache = app.fileCache.await()
        val tabId = "feed-$extensionId-$feedId"
        val tabs = fileCache.getData<List<Tab>>(tabId).getOrThrow()
        return Feed(tabs) { tab ->
            val id = "$tabId-${tab?.id}"
            val (buttons, bg) = fileCache.getData<Pair<Feed.Buttons?, ImageHolder?>>(id)
                .getOrThrow()
            PagedData.Continuous { token ->
                val id = "$id-$token"
                val page = fileCache.getData<Page<T>>(id).getOrThrow()
                page.copy(page.data.map { transform(it) })
            }.toFeedData(buttons, bg)
        }
    }

    suspend inline fun <reified T : Any> savingFeed(
        app: App, extension: Extension<*>, feedId: String, feed: Feed<T>,
    ): Feed<T> {
        val fileCache = app.fileCache.await()
        val tabId = "feed-${extension.id}-$feedId"
        fileCache.putData(tabId, feed.tabs)
        return Feed(feed.tabs) { tab ->
            val data = runCatching {
                feed.getPagedData(tab)
            }.getOrElse {
                throw it.toAppException(extension)
            }
            val (pagedData, buttons, bg) = data
            val id = "$tabId-${tab?.id}"
            fileCache.putData(id, Pair(buttons, bg))
            PagedData.Continuous { token ->
                val page = runCatching {
                    pagedData.loadPage(token)
                }.getOrElse {
                    throw it.toAppException(extension)
                }
                val id = "$id-$token"
                fileCache.putData(id, page)
                page
            }.toFeedData(buttons, bg)
        }
    }

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\db\ExtensionDao.kt ----------
package com.joaomagdaleno.music_hub.extensions.db

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.joaomagdaleno.music_hub.extensions.db.models.ExtensionEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface ExtensionDao {

    @Query("SELECT * FROM ExtensionEntity")
    fun getExtensionFlow(): Flow<List<ExtensionEntity>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun setExtension(extensionEntity: ExtensionEntity)
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\db\ExtensionDatabase.kt ----------
package com.joaomagdaleno.music_hub.extensions.db

import android.app.Application
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import com.joaomagdaleno.music_hub.common.models.User
import com.joaomagdaleno.music_hub.extensions.db.models.CurrentUser
import com.joaomagdaleno.music_hub.extensions.db.models.ExtensionEntity
import com.joaomagdaleno.music_hub.extensions.db.models.UserEntity

@Database(
    entities = [
        UserEntity::class,
        CurrentUser::class,
        ExtensionEntity::class,
    ],
    version = 1,
    exportSchema = false
)
abstract class ExtensionDatabase : RoomDatabase() {
    private val userDao by lazy { userDao() }
    val currentUsersFlow by lazy { userDao.observeCurrentUser() }
    private val extensionDao by lazy { extensionDao() }
    val extensionEnabledFlow by lazy { extensionDao.getExtensionFlow() }

    abstract fun userDao(): UserDao
    abstract fun extensionDao(): ExtensionDao

    suspend fun getUser(current: CurrentUser): User? {
        return userDao.getUser(current.type, current.extId, current.userId)?.user?.getOrNull()
    }

    companion object {
        private const val DATABASE_NAME = "extension-db"
        fun create(app: Application) = Room.databaseBuilder(
            app, ExtensionDatabase::class.java, DATABASE_NAME
        ).fallbackToDestructiveMigration(true).build()
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\db\UserDao.kt ----------
package com.joaomagdaleno.music_hub.extensions.db

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.extensions.db.models.CurrentUser
import com.joaomagdaleno.music_hub.extensions.db.models.UserEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface UserDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun setCurrentUser(currentUser: CurrentUser)

    @Query("SELECT * FROM CurrentUser")
    fun observeCurrentUser(): Flow<List<CurrentUser>>

    @Query("SELECT * FROM UserEntity WHERE type = :type AND extId = :extId")
    fun observeAllUsers(type: ExtensionType, extId: String): Flow<List<UserEntity>>

    @Query("SELECT * FROM CurrentUser WHERE extId = :extId AND type = :type")
    suspend fun getCurrentUser(type: ExtensionType, extId: String): CurrentUser?

    @Delete
    suspend fun deleteUser(user: UserEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUsers(users: List<UserEntity>)

    @Query("SELECT * FROM UserEntity WHERE type = :type AND extId = :extId AND id = :userId")
    suspend fun getUser(type: ExtensionType, extId: String, userId: String?): UserEntity?

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\db\models\CurrentUser.kt ----------
package com.joaomagdaleno.music_hub.extensions.db.models

import androidx.room.Entity
import com.joaomagdaleno.music_hub.common.models.ExtensionType

@Entity(primaryKeys = ["type", "extId"])
data class CurrentUser(
    val type : ExtensionType,
    val extId: String,
    val userId: String?
)

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\db\models\ExtensionEntity.kt ----------
package com.joaomagdaleno.music_hub.extensions.db.models

import androidx.room.Entity
import com.joaomagdaleno.music_hub.common.models.ExtensionType

@Entity(primaryKeys = ["id", "type"])
data class ExtensionEntity(
    val id: String,
    val type : ExtensionType,
    val enabled : Boolean
)

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\db\models\UserEntity.kt ----------
package com.joaomagdaleno.music_hub.extensions.db.models

import androidx.room.Entity
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.User
import com.joaomagdaleno.music_hub.utils.Serializer.toData
import com.joaomagdaleno.music_hub.utils.Serializer.toJson

@Entity(primaryKeys = ["id", "type", "extId"])
data class UserEntity(
    val type: ExtensionType,
    val extId: String,
    val id: String,
    val data: String
) {
    val user by lazy { data.toData<User>() }

    companion object {
        fun User.toEntity(type: ExtensionType, clientId: String) =
            UserEntity(type, clientId, id, toJson())

        fun UserEntity.toCurrentUser() =
            CurrentUser(type, extId, id)
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\exceptions\AppException.kt ----------
package com.joaomagdaleno.music_hub.extensions.exceptions

import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.helpers.ClientException
import com.joaomagdaleno.music_hub.common.models.Metadata

sealed class AppException : Exception() {

    abstract val extension: Metadata

    open class LoginRequired(
        override val extension: Metadata
    ) : AppException()

    class Unauthorized(
        override val extension: Metadata,
        val userId: String
    ) : LoginRequired(extension)

    class NotSupported(
        override val cause: Throwable,
        override val extension: Metadata,
        val operation: String
    ) : AppException() {
        override val message: String
            get() = "$operation is not supported in ${extension.name}"
    }

    class Other(
        override val cause: Throwable,
        override val extension: Metadata
    ) : AppException() {
        override val message: String
            get() = "${cause.message} error in ${extension.name}"
    }

    companion object {
        fun Throwable.toAppException(extension: Extension<*>) = toAppException(extension.metadata)
        fun Throwable.toAppException(extension: Metadata): AppException = when (this) {
            is ClientException.Unauthorized -> Unauthorized(extension, userId)
            is ClientException.LoginRequired -> LoginRequired(extension)
            is ClientException.NotSupported -> NotSupported(this, extension, operation)
            else -> Other(this, extension)
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\exceptions\ExtensionLoaderException.kt ----------
package com.joaomagdaleno.music_hub.extensions.exceptions

class ExtensionLoaderException(
    val clazz: String,
    val source: String,
    override val cause: Throwable
) : Exception()

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\exceptions\ExtensionNotFoundException.kt ----------
package com.joaomagdaleno.music_hub.extensions.exceptions

class ExtensionNotFoundException(val id: String?) : Exception("Extension not found: $id")

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\exceptions\InvalidExtensionListException.kt ----------
package com.joaomagdaleno.music_hub.extensions.exceptions

class InvalidExtensionListException(
    val link: String, override val cause: Throwable
) : Exception()

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\exceptions\RequiredExtensionsMissingException.kt ----------
package com.joaomagdaleno.music_hub.extensions.exceptions

class RequiredExtensionsMissingException(val required: List<String>) :
    Exception("Missing required extensions: ${required.joinToString(", ")}")

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\repo\AppRepository.kt ----------
package com.joaomagdaleno.music_hub.extensions.repo

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import androidx.core.content.ContextCompat
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.models.ImportType
import com.joaomagdaleno.music_hub.common.models.Metadata
import com.joaomagdaleno.music_hub.extensions.repo.ExtensionParser.Companion.FEATURE
import com.joaomagdaleno.music_hub.extensions.repo.ExtensionParser.Companion.PACKAGE_FLAGS
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.channelFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withContext
import java.io.File
import java.util.WeakHashMap
import kotlin.coroutines.suspendCoroutine

class AppRepository(
    private val scope: CoroutineScope,
    private val context: Context,
    private val parser: ExtensionParser
) : ExtensionRepository {
    private suspend fun Context.getStaticPackages() = withContext(Dispatchers.IO) {
        runCatching {
            packageManager.getInstalledPackages(PACKAGE_FLAGS).mapNotNull {
                runCatching {
                    val isExtension = it.reqFeatures.orEmpty().any { featureInfo ->
                        featureInfo?.name?.startsWith(FEATURE) ?: false
                    }
                    if (isExtension) File(it.applicationInfo!!.sourceDir!!) else null
                }.getOrNull()
            }
        }.getOrNull().orEmpty()
    }

    private val map =
        WeakHashMap<String, Pair<String, Result<Pair<Metadata, Lazy<ExtensionClient>>>>>()
    private val mutex = Mutex()

    override suspend fun loadExtensions() = mutex.withLock {
        parser.getAllDynamically(ImportType.App, map, context.getStaticPackages())
    }

    override val flow = channelFlow {
        send(null)
        send(loadExtensions())
        suspendCoroutine {
            val receiver = Receiver {
                scope.launch {
                    send(loadExtensions())
                }
            }
            val filter = IntentFilter().apply {
                addAction(Intent.ACTION_PACKAGE_ADDED)
                addAction(Intent.ACTION_PACKAGE_REMOVED)
                addAction(Intent.ACTION_PACKAGE_REPLACED)
                addAction(Intent.ACTION_PACKAGE_CHANGED)
                addDataScheme("package")
            }
            ContextCompat.registerReceiver(
                context, receiver, filter, ContextCompat.RECEIVER_NOT_EXPORTED
            )
        }
    }


    class Receiver(private val onReceive: () -> Unit) : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) = onReceive()
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\repo\CombinedRepository.kt ----------
package com.joaomagdaleno.music_hub.extensions.repo

import android.content.Context
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.models.Metadata
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.stateIn
import java.io.File

class CombinedRepository(
    scope: CoroutineScope,
    context: Context,
    fileIgnoreFlow: Flow<File?>,
    extensionParser: ExtensionParser,
    vararg builtIns: Pair<Metadata, Lazy<ExtensionClient>>
) : ExtensionRepository {

    private val list = builtIns.map { Result.success(it) }
    private val appRepository = AppRepository(scope, context, extensionParser)
    private val fileRepository = FileRepository(context, extensionParser, fileIgnoreFlow)

    override val flow = fileRepository.flow.combine(appRepository.flow) { file, app ->
        if (app == null) return@combine null
        list + file + app
    }.stateIn(scope, SharingStarted.Lazily, list)

    override suspend fun loadExtensions() = flow.first { it != null } ?: list
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\repo\DexLoader.kt ----------
package com.joaomagdaleno.music_hub.extensions.repo

import android.content.Context
import android.os.Build
import dalvik.system.DexClassLoader
import com.joaomagdaleno.music_hub.common.models.Metadata
import java.io.File
import java.io.FileOutputStream
import java.lang.ref.WeakReference
import java.util.zip.ZipFile

class DexLoader(
    metadata: Metadata,
    context: Context,
    librarySearchPath: String =
        unloadLibraries(metadata, File(context.cacheDir, "libs")).absolutePath
) : DexClassLoader(
    metadata.path, context.cacheDir.absolutePath, librarySearchPath, context.classLoader
) {

    private val preservedPackages = metadata.preservedPackages
    override fun loadClass(name: String?, resolve: Boolean): Class<*> {
        if (name != null && preservedPackages.any { name.startsWith(it) }) {
            val loadedClass = classMap[name]?.get()
            if (loadedClass != null) return loadedClass
            val clazz = super.loadClass(name, resolve)
            classMap[name] = WeakReference(clazz)
            return clazz
        }
        return super.loadClass(name, resolve)
    }

    companion object {
        private val classMap = mutableMapOf<String, WeakReference<Class<*>>>()

        private fun unloadLibraries(
            metadata: Metadata, libFolder: File
        ): File {
            val targetAbi = Build.SUPPORTED_ABIS.first()
            if (!libFolder.exists()) libFolder.mkdirs()
            val libs = File(libFolder, metadata.id)
            val version = File(libs, "version.txt")
            if (version.exists() && version.readText() == metadata.version) return libs
            libs.deleteRecursively()
            extractLibsFromApk(metadata.path, targetAbi, libs).getOrThrow()
            version.writeText(metadata.version)
            return libs
        }

        private fun extractLibsFromApk(
            apkPath: String, targetAbi: String, outputFolder: File
        ) = runCatching {
            outputFolder.mkdirs()
            val apkFile = ZipFile(apkPath)
            val extractedFiles = mutableListOf<File>()
            apkFile.entries().iterator().forEach { entry ->
                if (entry.name.startsWith("lib/$targetAbi/") && entry.name.endsWith(".so")) {
                    val fileName = entry.name.substringAfterLast("/")
                    val outputFile = File(outputFolder, fileName)
                    apkFile.getInputStream(entry).use { input ->
                        FileOutputStream(outputFile).use { output ->
                            input.copyTo(output)
                        }
                    }
                    extractedFiles.add(outputFile)
                }
            }
            apkFile.close()
            extractedFiles
        }
    }

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\repo\ExtensionParser.kt ----------
package com.joaomagdaleno.music_hub.extensions.repo

import android.content.Context
import android.content.pm.FeatureInfo
import android.content.pm.PackageManager
import android.os.Build
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.ImageHolder.Companion.toImageHolder
import com.joaomagdaleno.music_hub.common.models.ImportType
import com.joaomagdaleno.music_hub.common.models.Metadata
import com.joaomagdaleno.music_hub.extensions.exceptions.ExtensionLoaderException
import com.joaomagdaleno.music_hub.utils.ShaUtils.getSha256
import java.io.File
import java.util.WeakHashMap

class ExtensionParser(
    private val context: Context,
) {

    fun getAllDynamically(
        type: ImportType,
        map: WeakHashMap<String, Pair<String, Result<Pair<Metadata, Lazy<ExtensionClient>>>>>,
        files: List<File>
    ): List<Result<Pair<Metadata, Lazy<ExtensionClient>>>> {
        val new = files.associate {
            val sha = runCatching { getSha256(it) }.getOrNull().orEmpty()
            val entry = map[it.absolutePath]
            val value = if (entry != null && entry.first == sha) entry
            else sha to parse(it, type)
            it.absolutePath to value
        }
        map.clear()
        map.putAll(new)
        return map.values.map { it.second }
    }

    private fun parse(source: File, importType: ImportType) = runCatching {
        runCatching {
            val metadata = parseManifest(source, importType)
            val lazy = lazy { loadFrom(metadata) }
            metadata to lazy
        }.getOrElse {
            throw ExtensionLoaderException(javaClass.simpleName, source.toString(), it)
        }
    }


    fun parseManifest(file: File, importType: ImportType): Metadata {
        val packageInfo =
            context.packageManager.getPackageArchiveInfo(file.absolutePath, PACKAGE_FLAGS)
                ?: error("Failed to get package info for ${file.absolutePath}")
        val metadata = packageInfo.applicationInfo!!.metaData!!
        val type = packageInfo.reqFeatures!!.toExtensionType()
        fun getOrNull(key: String) = metadata.getString(key)?.takeIf { it.isNotBlank() }
        fun get(key: String) = getOrNull(key)
            ?: error("$key not found in Metadata for ${packageInfo.packageName}")
        return Metadata(
            path = file.absolutePath,
            preservedPackages = getOrNull("preserved_packages")
                .orEmpty().split(",").mapNotNull { it.trim().ifEmpty { null } },
            className = get("class"),
            importType = importType,
            type = type,
            id = get("id"),
            version = get("version"),
            icon = getOrNull("icon_url")?.toImageHolder(),
            name = get("name"),
            description = get("description"),
            author = get("author"),
            authorUrl = getOrNull("author_url"),
            repoUrl = getOrNull("repo_url"),
            updateUrl = getOrNull("update_url"),
            isEnabled = metadata.getBoolean("enabled", true)
        )
    }

    private fun loadFrom(metadata: Metadata): ExtensionClient {
        val dexLoader = DexLoader(metadata, context)
        val clazz = dexLoader.loadClass(metadata.className)
        return clazz.getConstructor().newInstance() as ExtensionClient
    }

    companion object {

        @Suppress("Deprecation")
        val PACKAGE_FLAGS = PackageManager.GET_CONFIGURATIONS or
                PackageManager.GET_META_DATA or
                PackageManager.GET_SIGNATURES or
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) PackageManager.GET_SIGNING_CERTIFICATES else 0

        const val FEATURE = "com.joaomagdaleno.music_hub."
        private fun Array<FeatureInfo>.toExtensionType(): ExtensionType {
            val feature = first { it.name.startsWith(FEATURE) }
            val type = feature.name.substringAfter(FEATURE)
            return ExtensionType.entries.first { it.feature == type }
        }


    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\repo\ExtensionRepository.kt ----------
package com.joaomagdaleno.music_hub.extensions.repo

import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.models.Metadata
import kotlinx.coroutines.flow.Flow

interface ExtensionRepository {
    val flow: Flow<List<Result<Pair<Metadata, Lazy<ExtensionClient>>>>?>
    suspend fun loadExtensions(): List<Result<Pair<Metadata, Lazy<ExtensionClient>>>>
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\extensions\repo\FileRepository.kt ----------
package com.joaomagdaleno.music_hub.extensions.repo

import android.content.Context
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.models.ImportType
import com.joaomagdaleno.music_hub.common.models.Metadata
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.channelFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.io.File
import java.util.WeakHashMap

class FileRepository(
    private val folder: File,
    private val parser: ExtensionParser,
    private val fileIgnoreFlow: Flow<File?>
) : ExtensionRepository {

    private val map =
        WeakHashMap<String, Pair<String, Result<Pair<Metadata, Lazy<ExtensionClient>>>>>()
    private val mutex = Mutex()

    private var toIgnoreFile: File? = null
    override val flow = channelFlow {
        send(loadExtensions())
        fileIgnoreFlow.collectLatest {
            toIgnoreFile = it
            send(loadExtensions())
        }
    }.flowOn(Dispatchers.IO)

    private fun loadAllApks() = folder.run {
        setReadOnly()
        listFiles()!!.filter {
            it != toIgnoreFile && it.extension == "apk"
        }.onEach { it.setWritable(false) }
    }

    override suspend fun loadExtensions() = mutex.withLock {
        parser.getAllDynamically(ImportType.File, map, loadAllApks())
    }

    constructor(
        context: Context, parser: ExtensionParser, fileIgnoreFlow: Flow<File?>
    ) : this(context.getExtensionsFileDir(), parser, fileIgnoreFlow)

    companion object {
        fun Context.getExtensionsFileDir() = File(filesDir, "extensions").apply { mkdirs() }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\AppShortcuts.kt ----------
package com.joaomagdaleno.music_hub.utils

import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.Canvas
import androidx.core.content.pm.ShortcutInfoCompat
import androidx.core.content.pm.ShortcutManagerCompat
import androidx.core.content.res.ResourcesCompat
import androidx.core.graphics.applyCanvas
import androidx.core.graphics.createBitmap
import androidx.core.graphics.drawable.IconCompat
import androidx.core.graphics.drawable.toBitmap
import androidx.core.net.toUri
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.MusicExtension
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadAsCircleDrawable
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import kotlin.math.roundToInt

object AppShortcuts {
    private suspend fun Context.applyAppShortcuts(extensions: List<MusicExtension>) {
        val max = ShortcutManagerCompat.getMaxShortcutCountPerActivity(this)
        val ext = extensions.take(max)
        val shortcuts = ext.map { extension ->
            val bitmap =
                extension.metadata.icon.loadAsCircleDrawable(this)
                    ?.toBitmap()?.addPadding()
                    ?: ResourcesCompat.getDrawable(resources, R.drawable.ic_extension, theme)!!
                        .toBitmap()
            ShortcutInfoCompat.Builder(this, extension.id)
                .setShortLabel(extension.name)
                .setIcon(IconCompat.createWithBitmap(bitmap))
                .setIntent(Intent(Intent.ACTION_VIEW, "echo://music/${extension.id}".toUri()))
                .build()
        }
        ShortcutManagerCompat.removeAllDynamicShortcuts(this)
        ShortcutManagerCompat.addDynamicShortcuts(this, shortcuts)
        ShortcutManagerCompat.disableShortcuts(
            this,
            ext.filter { !it.isEnabled }.map { it.id },
            getString(R.string.disabled)
        )
    }

    private fun Bitmap.addPadding(): Bitmap {
        val percentage = 0.05f
        val max = maxOf(width, height)
        val padding = (max * percentage).roundToInt().toFloat()
        val diameter = (max + padding * 2).toInt()
        val newBitmap = createBitmap(diameter, diameter, config ?: Bitmap.Config.ARGB_8888)
        val canvas = Canvas(newBitmap)
        newBitmap.applyCanvas {
//            canvas.drawColor(getCommonColor())
            canvas.drawBitmap(this@addPadding, padding, padding, null)
        }
        return newBitmap
    }

//    private fun Bitmap.circleCrop(): Bitmap {
//        val paint = Paint(Paint.ANTI_ALIAS_FLAG or Paint.FILTER_BITMAP_FLAG)
//
//        val minSize = minOf(width, height)
//        val radius = minSize / 2f
//        val output = createBitmap(minSize, minSize, config ?: Bitmap.Config.ARGB_8888)
//        output.applyCanvas {
//            drawCircle(radius, radius, radius, paint)
//            paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)
//            drawBitmap(this@circleCrop, radius - width / 2f, radius - height / 2f, paint)
//        }
//
//        return output
//    }

//    private fun Bitmap.getCommonColor(): Int {
//        val pixels = IntArray(width * height)
//        getPixels(pixels, 0, width, 0, 0, width, height)
//        val percent = 32
//        val groupedColors = pixels
//            .filter { (it shr 24 and 0xFF) > 64 }
//            .groupBy { color ->
//                val r = (color shr 16 and 0xFF) / percent * percent
//                val g = (color shr 8 and 0xFF) / percent * percent
//                val b = (color and 0xFF) / percent * percent
//                (0xFF shl 24) or (r shl 16) or (g shl 8) or b
//            }
//            .mapKeys { entry -> entry.value.groupBy { it }.maxByOrNull { it.value.size }?.key }
//            .mapValues { it.value.size }
//        return groupedColors.maxByOrNull { it.value }?.key ?: 0
//    }

    fun configureAppShortcuts(loader: ExtensionLoader) {
        val scope = loader.scope
        val musicExt = loader.music
        scope.launch {
            musicExt.collectLatest {
                loader.app.context.applyAppShortcuts(it)
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\AppUpdater.kt ----------
package com.joaomagdaleno.music_hub.utils

import android.content.Context
import android.os.Build
import com.joaomagdaleno.music_hub.BuildConfig
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.helpers.ContinuationCallback.Companion.await
import com.joaomagdaleno.music_hub.common.models.Message
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.utils.ContextUtils.appVersion
import com.joaomagdaleno.music_hub.utils.ContextUtils.getTempFile
import com.joaomagdaleno.music_hub.utils.Serializer.toData
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import okhttp3.OkHttpClient
import okhttp3.Request
import okio.use
import java.io.File
import java.util.zip.ZipFile

object AppUpdater {

    private val client = OkHttpClient()

    @Suppress("KotlinConstantConditions")
    suspend fun updateApp(app: App): File? {
        val throwableFlow = app.throwFlow
        val messageFlow = app.messageFlow
        val githubRepo = app.context.getString(R.string.app_github_repo)
        val appType = BuildConfig.BUILD_TYPE
        val version = appVersion()

        val url = runCatching {
            when (appType) {
                "stable" -> {
                    val currentVersion = version.substringBefore('_')
                    val updateUrl = "https://api.github.com/repos/$githubRepo/releases"
                    getGithubUpdateUrl(currentVersion, updateUrl, client) ?: return null
                }

                "nightly" -> {
                    val hash = version.substringBefore("(").substringAfter('_')
                    val id = getGithubWorkflowId(hash, githubRepo, client) ?: return null
                    "https://nightly.link/$githubRepo/actions/runs/$id/artifact.zip"
                }

                else -> return null
            }
        }.getOrElse {
            throwableFlow.emit(it)
            return null
        }

        messageFlow.emit(
            Message(
                app.context.run {
                    getString(R.string.downloading_update_for_x, getString(R.string.app_name))
                }
            )
        )
        return runCatching {
            val download = downloadUpdate(app.context, url, client).getOrThrow()
            if (appType == "stable") download else unzipApk(download)
        }.getOrElse {
            throwableFlow.emit(it)
            return null
        }
    }

    private val githubRegex = Regex("https://api\\.github\\.com/repos/([^/]*)/([^/]*)/")
    suspend fun getGithubUpdateUrl(
        currentVersion: String,
        updateUrl: String,
        client: OkHttpClient
    ) = run {
        val (user, repo) = githubRegex.find(updateUrl)?.destructured
            ?: throw Exception("Invalid Github URL")
        val url = "https://api.github.com/repos/$user/$repo/releases/latest"
        val request = Request.Builder().url(url).build()
        val res = runCatching {
            client.newCall(request).await().use {
                it.body.string().toData<GithubReleaseResponse>()
            }.getOrThrow()
        }.getOrElse {
            throw Exception("Failed to fetch latest release", it)
        }
        if (res.tagName != currentVersion) {
            res.assets.sortedByDescending {
                it.name.contains(Build.SUPPORTED_ABIS.first())
            }.firstOrNull {
                it.name.endsWith("apk")
            }?.browserDownloadUrl ?: throw Exception("No EApk assets found")
        } else {
            null
        }
    }

    private suspend fun getGithubWorkflowId(
        hash: String,
        githubRepo: String,
        client: OkHttpClient
    ) = runCatching {
        val url =
            "https://api.github.com/repos/$githubRepo/actions/workflows/nightly.yml/runs?per_page=1&conclusion=success"
        val request = Request.Builder().url(url).build()
        client.newCall(request).await().body.string().toData<GithubRunsResponse>().getOrThrow()
            .workflowRuns.firstOrNull { it.sha.take(7) != hash }?.id
    }.getOrElse {
        throw Exception("Failed to fetch workflow ID", it)
    }

    @Serializable
    data class GithubReleaseResponse(
        @SerialName("tag_name")
        val tagName: String,
        @SerialName("created_at")
        val createdAt: String,
        val assets: List<Asset>
    ) {
        @Serializable
        data class Asset(
            val name: String,
            @SerialName("browser_download_url")
            val browserDownloadUrl: String
        )
    }

    @Serializable
    data class GithubRunsResponse(
        @SerialName("workflow_runs")
        val workflowRuns: List<Run>
    ) {
        @Serializable
        data class Run(
            val id: Long,
            @SerialName("head_sha")
            val sha: String,
        )
    }

    suspend fun downloadUpdate(
        context: Context,
        url: String,
        client: OkHttpClient
    ) = runIOCatching {
        val request = Request.Builder().url(url).build()
        val res = client.newCall(request).await().body.byteStream()
        val file = context.getTempFile()
        res.use { input -> file.outputStream().use { output -> input.copyTo(output) } }
        file
    }

    private fun unzipApk(file: File): File {
        val zipFile = ZipFile(file)
        val apkFile = File.createTempFile("temp", ".apk", file.parentFile!!)
        zipFile.use { zip ->
            val apkEntry = zip.entries().asSequence().firstOrNull {
                !it.isDirectory && it.name.endsWith(".apk")
            } ?: throw Exception("No APK file found in the zip")
            zip.getInputStream(apkEntry).use { input ->
                apkFile.outputStream().use { output ->
                    input.copyTo(output)
                }
            }
        }
        return apkFile
    }

    suspend fun getUpdateFileUrl(
        currentVersion: String,
        updateUrl: String,
        client: OkHttpClient
    ) = runIOCatching {
        if (updateUrl.isEmpty()) return@runIOCatching null
        if (updateUrl.startsWith("https://api.github.com/repos/")) {
            getGithubUpdateUrl(currentVersion, updateUrl, client)
        } else {
            throw Exception("Unsupported update url")
        }
    }

    private suspend fun <T> runIOCatching(
        block: suspend () -> T
    ) = withContext(Dispatchers.IO) {
        runCatching { runCatching { block() }.getOrElse { throw UpdateException(it) } }
    }

    class UpdateException(override val cause: Throwable) : Exception(cause) {
        override val message: String
            get() = "Update failed: ${cause.message}"
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\CacheUtils.kt ----------
package com.joaomagdaleno.music_hub.utils

import android.content.Context
import com.joaomagdaleno.music_hub.utils.Serializer.toData
import com.joaomagdaleno.music_hub.utils.Serializer.toJson
import java.io.File

object CacheUtils {

    fun cacheDir(context: Context, folderName: String) =
        File(context.cacheDir, "context/$folderName").apply { mkdirs() }

    const val CACHE_FOLDER_SIZE = 50 * 1024 * 1024 //50MB

    inline fun <reified T> Context.saveToCache(
        id: String, data: T?, folderName: String = T::class.java.simpleName
    ) = runCatching {
        val fileName = id.hashCode().toString()
        val cacheDir = cacheDir(this, folderName)
        val file = File(cacheDir, fileName)

        var size = cacheDir.walk().sumOf { it.length().toInt() }
        while (size > CACHE_FOLDER_SIZE) {
            val files = cacheDir.listFiles()
            files?.sortBy { it.lastModified() }
            files?.firstOrNull()?.delete()
            size = cacheDir.walk().sumOf { it.length().toInt() }
        }
        file.writeText(data.toJson())
    }

    inline fun <reified T> Context.getFromCache(
        id: String, folderName: String = T::class.java.simpleName
    ): T? {
        val fileName = id.hashCode().toString()
        val cacheDir = cacheDir(this, folderName)
        val file = File(cacheDir, fileName)
        return if (file.exists()) runCatching {
            file.readText().toData<T>().getOrThrow()
        }.getOrNull() else null
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ContextUtils.kt ----------
package com.joaomagdaleno.music_hub.utils

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.os.Build.SUPPORTED_ABIS
import androidx.core.content.ContextCompat
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.flowWithLifecycle
import androidx.lifecycle.lifecycleScope
import com.google.common.util.concurrent.ListenableFuture
import com.joaomagdaleno.music_hub.BuildConfig
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import java.io.File

object ContextUtils {
    fun appVersion() = BuildConfig.VERSION_NAME + " " + BuildConfig.BUILD_TYPE
    fun getArch(): String {
        SUPPORTED_ABIS.firstOrNull()?.let { return it }
        return System.getProperty("os.arch")
            ?: System.getProperty("os.product.cpu.abi")
            ?: "Unknown"
    }

    fun Context.copyToClipboard(label: String?, string: String) {
        val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        val clip = ClipData.newPlainText(label, string)
        clipboard.setPrimaryClip(clip)
    }

    fun <T> LifecycleOwner.observe(flow: Flow<T>, block: suspend (T) -> Unit) =
        lifecycleScope.launch {
            flow.flowWithLifecycle(lifecycle).collectLatest(block)
        }

    fun <T> LifecycleOwner.collect(flow: Flow<T>, block: suspend (T) -> Unit) =
        lifecycleScope.launch {
            flow.collect {
                runCatching { block(it) }
            }
        }

    fun <T> Context.listenFuture(future: ListenableFuture<T>, block: (Result<T>) -> Unit) {
        future.addListener({
            val result = runCatching { future.get() }
            block(result)
        }, ContextCompat.getMainExecutor(this))
    }

    fun <T> LifecycleOwner.emit(flow: MutableSharedFlow<T>, value: T) {
        lifecycleScope.launch {
            flow.emit(value)
        }
    }

    const val SETTINGS_NAME = "settings"
    fun Context.getSettings() = getSharedPreferences(SETTINGS_NAME, Context.MODE_PRIVATE)!!

    private fun Context.getTempDir() = cacheDir.resolve("apks").apply { mkdirs() }
    fun Context.getTempFile(ext: String = "apk"): File =
        File.createTempFile("temp", ".$ext", getTempDir())

    fun Context.cleanupTempApks() {
        getTempDir().deleteRecursively()
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\CoroutineUtils.kt ----------
package com.joaomagdaleno.music_hub.utils

import android.content.Context
import androidx.core.content.ContextCompat
import com.google.common.util.concurrent.ListenableFuture
import com.google.common.util.concurrent.SettableFuture
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.FlowCollector
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.conflate
import kotlinx.coroutines.flow.transform
import kotlinx.coroutines.flow.transformLatest
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlin.coroutines.CoroutineContext
import kotlin.experimental.ExperimentalTypeInference

object CoroutineUtils {
    fun setDebug() {
        System.setProperty(
            kotlinx.coroutines.DEBUG_PROPERTY_NAME,
            kotlinx.coroutines.DEBUG_PROPERTY_VALUE_ON
        )
    }

    suspend fun <T, R> Flow<T>.collectWith(flow: Flow<R>, block: suspend (T, R) -> Unit) {
        this.combine(flow) { t, r -> t to r }.collectLatest { (t, r) -> block(t, r) }
    }

    fun <T> Flow<T>.throttleLatest(delayMillis: Long): Flow<T> = conflate().transform {
        emit(it)
        delay(delayMillis)
    }

    @OptIn(ExperimentalCoroutinesApi::class, ExperimentalTypeInference::class)
    inline fun <reified T, R> combineTransformLatest(
        vararg flows: Flow<T>,
        @BuilderInference noinline transform: suspend FlowCollector<R>.(Array<T>) -> Unit
    ): Flow<R> {
        return combine(*flows) { it }
            .transformLatest(transform)
    }

    @OptIn(ExperimentalTypeInference::class)
    fun <T1, T2, R> Flow<T1>.combineTransformLatest(
        flow2: Flow<T2>,
        @BuilderInference transform: suspend FlowCollector<R>.(T1, T2) -> Unit
    ): Flow<R> {
        return combineTransformLatest(this, flow2) { args ->
            @Suppress("UNCHECKED_CAST")
            transform(
                args[0] as T1,
                args[1] as T2
            )
        }
    }

    fun <T> CoroutineScope.future(
        context: CoroutineContext = Dispatchers.IO, block: suspend () -> T
    ): ListenableFuture<T> {
        val future = SettableFuture.create<T>()
        launch(context) {
            future.set(block())
        }
        return future
    }

    fun <T> CoroutineScope.futureCatching(
        context: CoroutineContext = Dispatchers.IO, block: suspend () -> T
    ): ListenableFuture<T> {
        val future = SettableFuture.create<T>()
        launch(context) {
            runCatching {
                future.set(block())
            }.getOrElse {
                future.setException(it)
            }
        }
        return future
    }


    suspend fun <T> ListenableFuture<T>.await(context: Context) = suspendCancellableCoroutine {
        it.invokeOnCancellation {
            cancel(true)
        }
        addListener({
            it.resumeWith(runCatching { get()!! })
        }, ContextCompat.getMainExecutor(context))
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\PauseTimer.kt ----------
package com.joaomagdaleno.music_hub.utils

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

class PauseTimer(
    private val scope: CoroutineScope,
    private var millisInFuture: Long,
    private val onTimerFinish: () -> Unit,
) {
    private var job: Job? = null
    private var lastPauseTime: Long = System.currentTimeMillis()
    private var isTimerPaused: Boolean = true

    fun resume() {
        if (isTimerPaused) {
            val diff = System.currentTimeMillis() - lastPauseTime
            val remainingTime =  millisInFuture - diff
            if (remainingTime < 0) return
            job = scope.launch {
                delay(remainingTime)
                onTimerFinish()
            }
            isTimerPaused = false
        }
    }

    fun pause() {
        job?.cancel()
        lastPauseTime = System.currentTimeMillis()
        isTimerPaused = true
    }

    init {
        resume()
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\PermsUtils.kt ----------
package com.joaomagdaleno.music_hub.utils

import android.Manifest
import android.Manifest.permission.READ_MEDIA_AUDIO
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.provider.Settings
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.result.ActivityResultCallback
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContract
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.joaomagdaleno.music_hub.R
import kotlinx.coroutines.launch
import java.util.UUID

object PermsUtils {

    fun ComponentActivity.checkAppPermissions(onGranted: suspend () -> Unit) {
        val perms = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) listOfNotNull(
            Triple(
                Manifest.permission.POST_NOTIFICATIONS,
                getString(R.string.notifications),
                getString(R.string.notifications_permission_summary)
            ),
            Triple(
                READ_MEDIA_AUDIO,
                getString(R.string.audio),
                getString(R.string.audio_permission_summary)
            ),
//            Triple(
//                Manifest.permission.READ_MEDIA_VIDEO,
//                getString(R.string.video),
//                getString(R.string.video_permission_summary)
//            ),
//            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) Triple(
//                Manifest.permission.READ_MEDIA_VISUAL_USER_SELECTED,
//                getString(R.string.video),
//                getString(R.string.video_permission_summary)
//            ) else null
        ) else listOfNotNull(
            Triple(
                Manifest.permission.READ_EXTERNAL_STORAGE,
                getString(R.string.read_storage),
                getString(R.string.audio_permission_summary)
            ),
            if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.Q) Triple(
                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                getString(R.string.write_storage),
                getString(R.string.write_storage_permission_summary)
            ) else null
        )
        getPermissionsLauncher(perms, onGranted = {
            if (it == READ_MEDIA_AUDIO) lifecycleScope.launch {
                onGranted()
            }
        })
    }

    private fun ComponentActivity.getPermissionsLauncher(
        perms: List<Triple<String, String, String>>,
        onCancel: (String) -> Unit = {},
        onGranted: (String) -> Unit = {},
        onRequest: (String) -> Unit = {
            Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                data = Uri.fromParts("package", packageName, null)
                startActivity(this)
            }
        }
    ) = run {
        val contract = ActivityResultContracts.RequestMultiplePermissions()
        val notGranted = perms.filterNot {
            ContextCompat.checkSelfPermission(this, it.first) == PackageManager.PERMISSION_GRANTED
        }
        val launcher = if (notGranted.isNotEmpty())
            registerActivityResultLauncher(contract) { result ->
                val map = perms.associateBy { it.first }
                result.forEach { (p, granted) ->
                    val perm = map[p]!!
                    if (granted) onGranted(p)
                    else MaterialAlertDialogBuilder(this)
                        .setTitle(getString(R.string.x_permission_required, perm.second))
                        .setMessage(perm.third)
                        .setPositiveButton(getString(R.string.okay)) { _, _ -> onRequest(p) }
                        .setNegativeButton(getString(R.string.cancel)) { _, _ ->
                            Toast.makeText(
                                this,
                                getString(R.string.x_was_not_granted, perm.second),
                                Toast.LENGTH_SHORT
                            ).show()
                            onCancel(p)
                        }.show()
                }
            }
        else {
            perms.forEach { onGranted(it.first) }
            null
        }
        launcher?.launch(perms.map { it.first }.toTypedArray())
    }

    fun <I, O> ComponentActivity.registerActivityResultLauncher(
        contract: ActivityResultContract<I, O>,
        block: (O) -> Unit
    ): ActivityResultLauncher<I> {
        val key = UUID.randomUUID().toString()
        var launcher: ActivityResultLauncher<I>? = null
        val callback = ActivityResultCallback<O> {
            block.invoke(it)
            launcher?.unregister()
        }

        lifecycle.addObserver(object : androidx.lifecycle.DefaultLifecycleObserver {
            override fun onDestroy(owner: androidx.lifecycle.LifecycleOwner) {
                launcher?.unregister()
            }
        })

        launcher = activityResultRegistry.register(key, contract, callback)
        return launcher
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\PrefsUtils.kt ----------
package com.joaomagdaleno.music_hub.utils


import android.content.Context
import android.net.Uri
import androidx.core.content.edit
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.extensionPrefId
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener.Companion.CUSTOM_EFFECTS
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener.Companion.GLOBAL_FX
import com.joaomagdaleno.music_hub.utils.ContextUtils.SETTINGS_NAME
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.booleanOrNull
import kotlinx.serialization.json.contentOrNull
import kotlinx.serialization.json.floatOrNull
import kotlinx.serialization.json.intOrNull
import kotlinx.serialization.json.longOrNull
import java.io.BufferedReader
import java.io.InputStreamReader


private fun Map<String, Any?>.toJsonElementMap(): Map<String, JsonElement> {
    return this.mapValues { (_, value) ->
        when (value) {
            is Boolean -> JsonPrimitive(value)
            is Float -> JsonPrimitive(value)
            is Int -> JsonPrimitive(value)
            is Long -> JsonPrimitive(value)
            is String -> JsonPrimitive(value)
            is Set<*> -> JsonArray(value.filterIsInstance<String>().map { JsonPrimitive(it) })
            null -> JsonNull
            else -> throw IllegalArgumentException("Unsupported type for serialization: ${value::class.java}")
        }
    }
}


fun Context.exportSettings(uri: Uri) {
    val settingsPrefs = getSharedPreferences(SETTINGS_NAME, Context.MODE_PRIVATE)
    val globalFxPrefs = getSharedPreferences(GLOBAL_FX, Context.MODE_PRIVATE)

    val settingsJson = settingsPrefs.all.toJsonElementMap()
    val globalFxJson = globalFxPrefs.all.toJsonElementMap()
    val customFxJson = globalFxPrefs.getStringSet(CUSTOM_EFFECTS, emptySet())?.map { fxName ->
        fxName to getSharedPreferences("fx_$fxName", Context.MODE_PRIVATE).all.toJsonElementMap()
    }

    val allPrefsJson = mutableMapOf(SETTINGS_NAME to settingsJson, GLOBAL_FX to globalFxJson)
    customFxJson?.forEach { (name, map) -> allPrefsJson["fx_$name"] = map }

    contentResolver.openOutputStream(uri, "w")?.use { out ->
        out.write(Json.encodeToString(allPrefsJson).toByteArray())
    }
}


fun Context.importSettings(uri: Uri) {
    val jsonString = contentResolver.openInputStream(uri)?.use { inputStream ->
        BufferedReader(InputStreamReader(inputStream)).readText()
    } ?: return

    val allPrefsJson = Json.decodeFromString<Map<String, JsonObject>>(jsonString)

    allPrefsJson.forEach { (prefName, prefMap) ->
        getSharedPreferences(prefName, Context.MODE_PRIVATE).edit {
            prefMap.forEach { (key, value) ->
                when (value) {
                    is JsonPrimitive if value.booleanOrNull != null -> putBoolean(
                        key,
                        value.booleanOrNull!!
                    )

                    is JsonPrimitive if value.intOrNull != null -> putInt(key, value.intOrNull!!)
                    is JsonPrimitive if value.longOrNull != null -> putLong(key, value.longOrNull!!)
                    is JsonPrimitive if value.floatOrNull != null -> putFloat(
                        key,
                        value.floatOrNull!!
                    )

                    is JsonPrimitive if value.isString -> putString(key, value.content)
                    is JsonArray -> putStringSet(
                        key,
                        value.mapNotNull { (it as? JsonPrimitive)?.contentOrNull }.toSet()
                    )

                    is JsonNull -> remove(key)
                    else -> throw IllegalArgumentException("Unsupported type for deserialization: ${value::class.java}")
                }
            }
        }
    }
}


fun Context.exportExtensionSettings(extensionType: String, extensionId: String, uri: Uri) {
    val prefName = extensionPrefId(extensionType, extensionId)
    val settingsPrefs = getSharedPreferences(prefName, Context.MODE_PRIVATE)
    val settingsJson = settingsPrefs.all.toJsonElementMap()

    contentResolver.openOutputStream(uri, "w")?.use { out ->
        out.write(Json.encodeToString(settingsJson).toByteArray())
    }
}


fun Context.importExtensionSettings(extensionType: String, extensionId: String, uri: Uri) {
    val jsonString = contentResolver.openInputStream(uri)?.use { inputStream ->
        BufferedReader(InputStreamReader(inputStream)).readText()
    } ?: return

    val settingsJson = Json.decodeFromString<Map<String, JsonElement>>(jsonString)
    val prefName = extensionPrefId(extensionType, extensionId)

    getSharedPreferences(prefName, Context.MODE_PRIVATE).edit {
        settingsJson.forEach { (key, value) ->
            when (value) {
                is JsonPrimitive if value.booleanOrNull != null -> putBoolean(
                    key,
                    value.booleanOrNull!!
                )

                is JsonPrimitive if value.intOrNull != null -> putInt(key, value.intOrNull!!)
                is JsonPrimitive if value.longOrNull != null -> putLong(key, value.longOrNull!!)
                is JsonPrimitive if value.floatOrNull != null -> putFloat(
                    key,
                    value.floatOrNull!!
                )

                is JsonPrimitive if value.isString -> putString(key, value.content)
                is JsonArray -> putStringSet(
                    key,
                    value.mapNotNull { (it as? JsonPrimitive)?.contentOrNull }.toSet()
                )

                is JsonNull -> remove(key)
                else -> throw IllegalArgumentException("Unsupported type for deserialization: ${value::class.java}")
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\Serializer.kt ----------
package com.joaomagdaleno.music_hub.utils

import android.os.Build
import android.os.Bundle
import android.os.Parcelable
import kotlinx.serialization.json.Json

object Serializer {
    val json = Json {
        ignoreUnknownKeys = true
    }

    inline fun <reified T> String.toData() = runCatching {
        json.decodeFromString<T>(this)
    }.recoverCatching {
        throw DecodingException(this, it)
    }

    inline fun <reified T> T.toJson() = json.encodeToString(this)

    inline fun <reified T> Bundle.putSerialized(key: String, value: T) {
        putString(key, value.toJson())
    }

    inline fun <reified T> Bundle.getSerialized(key: String): Result<T>? {
        return getString(key)?.toData<T>()
    }

    @Suppress("DEPRECATION")
    inline fun <reified T : Parcelable> Bundle.getParcel(key: String?) =
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU)
            getParcelable(key, T::class.java)
        else getParcelable(key)

    val Throwable.rootCause: Throwable
        get() = generateSequence(this) { it.cause }.last()

    data class DecodingException(val json: String, val error: Throwable) : Exception(error)
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ShaUtils.kt ----------
package com.joaomagdaleno.music_hub.utils

import java.io.File
import java.security.MessageDigest

object ShaUtils {

    fun getSha256(file: File): String {
        val digest = MessageDigest.getInstance("SHA-256")
        file.inputStream().use { inputStream ->
            val buffer = ByteArray(8192)
            var bytesRead: Int
            while (inputStream.read(buffer).also { bytesRead = it } != -1) {
                digest.update(buffer, 0, bytesRead)
            }
        }
        return digest.digest().joinToString("") { "%02x".format(it) }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\TagInjector.kt ----------
package com.joaomagdaleno.music_hub.utils

import okhttp3.OkHttpClient
import okhttp3.Request
import org.jaudiotagger.audio.AudioFileIO
import org.jaudiotagger.tag.FieldKey
import org.jaudiotagger.tag.TagOptionSingleton
import org.jaudiotagger.tag.images.ArtworkFactory
import java.io.File
import java.io.FileOutputStream
import com.joaomagdaleno.music_hub.common.helpers.ContinuationCallback.Companion.await

object TagInjector {

    private val client = OkHttpClient()

    suspend fun writeMetadata(
        file: File,
        title: String,
        artist: String,
        album: String?,
        coverUrl: String?,
        lyrics: String? = null
    ) {
        try {
            // Important for Android compatibility
            TagOptionSingleton.getInstance().isAndroid = true

            val audioFile = AudioFileIO.read(file)
            val tag = audioFile.tagOrCreateAndSetDefault

            tag.setField(FieldKey.TITLE, title)
            tag.setField(FieldKey.ARTIST, artist)
            album?.let { tag.setField(FieldKey.ALBUM, it) }
            lyrics?.let { tag.setField(FieldKey.LYRICS, it) }

            coverUrl?.let { url ->
                val artworkFile = downloadImage(url)
                if (artworkFile != null) {
                    val artwork = ArtworkFactory.createArtworkFromFile(artworkFile)
                    tag.deleteArtworkField()
                    tag.setField(artwork)
                    artworkFile.delete()
                }
            }

            audioFile.commit()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private suspend fun downloadImage(url: String): File? {
        return try {
            val request = Request.Builder().url(url).build()
            val response = client.newCall(request).await()
            if (!response.isSuccessful) return null

            val tempFile = File.createTempFile("cover", ".jpg")
            val outputStream = FileOutputStream(tempFile)
            response.body?.byteStream()?.copyTo(outputStream)
            outputStream.close()
            tempFile
        } catch (e: Exception) {
            null
        }
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\image\BlurTransformation.kt ----------
@file:Suppress("DEPRECATION")

package com.joaomagdaleno.music_hub.utils.image

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Paint
import android.renderscript.Allocation
import android.renderscript.Element
import android.renderscript.RenderScript
import android.renderscript.ScriptIntrinsicBlur
import androidx.core.graphics.applyCanvas
import androidx.core.graphics.createBitmap
import coil3.size.Size
import coil3.transform.Transformation

class BlurTransformation(
    private val context: Context,
    private val radius: Float = DEFAULT_RADIUS
) : Transformation() {

    override val cacheKey = "${BlurTransformation::class.simpleName}-$radius"

    override suspend fun transform(input: Bitmap, size: Size) =
        input.blurred(context, radius)

    companion object {
        private const val DEFAULT_RADIUS = 20f
        private const val MAX_WIDTH = 256
        fun Bitmap.blurred(
            context: Context,
            radius: Float = DEFAULT_RADIUS
        ): Bitmap {
            require(radius in 0.0..25.0) { "radius must be in [0, 25]." }

            val paint = Paint(Paint.ANTI_ALIAS_FLAG or Paint.FILTER_BITMAP_FLAG)
            val scale = width.toFloat() / MAX_WIDTH
            val scaledHeight = (height / scale).toInt()
            val output =
                createBitmap(MAX_WIDTH, scaledHeight, config ?: Bitmap.Config.ARGB_8888)
            output.applyCanvas {
                scale(1 / scale, 1 / scale)
                drawBitmap(this@blurred, 0f, 0f, paint)
            }

            var script: RenderScript? = null
            var tmpInt: Allocation? = null
            var tmpOut: Allocation? = null
            var blur: ScriptIntrinsicBlur? = null
            try {
                script = RenderScript.create(context)
                tmpInt = Allocation.createFromBitmap(
                    script,
                    output,
                    Allocation.MipmapControl.MIPMAP_NONE,
                    Allocation.USAGE_SCRIPT
                )
                tmpOut = Allocation.createTyped(script, tmpInt.type)
                blur = ScriptIntrinsicBlur.create(script, Element.U8_4(script))
                blur.setRadius(radius)
                blur.setInput(tmpInt)
                blur.forEach(tmpOut)
                tmpOut.copyTo(output)
            } finally {
                script?.destroy()
                tmpInt?.destroy()
                tmpOut?.destroy()
                blur?.destroy()
            }

            return output
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\image\ImageUtils.kt ----------
package com.joaomagdaleno.music_hub.utils.image

import android.content.Context
import android.graphics.drawable.Drawable
import android.view.View
import android.widget.ImageView
import androidx.core.graphics.drawable.toDrawable
import androidx.core.graphics.toColorInt
import coil3.Image
import coil3.asDrawable
import coil3.imageLoader
import coil3.load
import coil3.network.NetworkHeaders
import coil3.network.httpHeaders
import coil3.request.ImageRequest
import coil3.request.error
import coil3.request.placeholder
import coil3.request.target
import coil3.request.transformations
import coil3.transform.CircleCropTransformation
import coil3.transform.Transformation
import com.joaomagdaleno.music_hub.common.models.ImageHolder

object ImageUtils {

    private fun <T> tryWith(print: Boolean = false, block: () -> T): T? {
        return try {
            block()
        } catch (e: Throwable) {
            if (print) e.printStackTrace()
            null
        }
    }

    private suspend fun <T> tryWithSuspend(print: Boolean = true, block: suspend () -> T): T? {
        return try {
            block()
        } catch (e: Throwable) {
            if (print) e.printStackTrace()
            null
        }
    }

    private fun View.enqueue(builder: ImageRequest.Builder) =
        context.imageLoader.enqueue(builder.build())

    fun ImageHolder?.loadInto(
        imageView: ImageView, placeholder: Int? = null, errorDrawable: Int? = null
    ) = tryWith {
        val request = createRequest(imageView.context, placeholder, errorDrawable)
        request.target(imageView)
        imageView.enqueue(request)
    }

    fun ImageHolder.getCachedDrawable(context: Context): Drawable? {
        val key = diskId ?: return null
        return context.imageLoader.diskCache?.openSnapshot(key)?.use {
            Drawable.createFromPath(it.data.toFile().absolutePath)
        }
    }

    fun <T : View> ImageHolder?.loadWithThumb(
        view: T, thumbnail: Drawable? = null,
        error: Int? = null, onDrawable: T.(Drawable?) -> Unit
    ) = tryWith(true) {
        tryWith(false) { onDrawable(view, thumbnail) }
        val request = createRequest(view.context, null, error)
        fun setDrawable(image: Image?) {
            val drawable = image?.asDrawable(view.resources)
            tryWith(false) { onDrawable(view, drawable) }
        }
        request.target({}, ::setDrawable, ::setDrawable)
        view.enqueue(request)
    }

    private val circleCrop = CircleCropTransformation()
    private val squareCrop = SquareCropTransformation()
    fun <T : View> ImageHolder?.loadAsCircle(
        view: T,
        placeholder: Int? = null,
        error: Int? = null,
        onDrawable: (Drawable?) -> Unit
    ) = tryWith {
        val request = createRequest(view.context, placeholder, error, circleCrop)
        fun setDrawable(image: Image?) {
            val drawable = image?.asDrawable(view.resources)
            tryWith(false) { onDrawable(drawable) }
        }
        request.target(::setDrawable, ::setDrawable, ::setDrawable)
        view.enqueue(request)
    }

    suspend fun ImageHolder?.loadDrawable(
        context: Context
    ) = tryWithSuspend {
        val request = createRequest(context, null, null)
        context.imageLoader.execute(request.build()).image?.asDrawable(context.resources)
    }

    suspend fun ImageHolder?.loadAsCircleDrawable(
        context: Context
    ) = tryWithSuspend {
        val request = createRequest(context, null, null, circleCrop)
        context.imageLoader.execute(request.build()).image?.asDrawable(context.resources)
    }

    fun ImageView.loadBlurred(drawable: Drawable?, radius: Float) = tryWith {
        if (drawable == null) setImageDrawable(null)
        load(drawable) {
            transformations(BlurTransformation(context, radius))
        }
    }

    private val ImageHolder.diskId
        get() = when (this) {
            is ImageHolder.NetworkRequestImageHolder -> request.toString().hashCode().toString()
            else -> null
        }

    private fun createRequest(
        imageHolder: ImageHolder,
        builder: ImageRequest.Builder,
    ) = imageHolder.run {
        builder.diskCacheKey(diskId)
        when (this) {
            is ImageHolder.ResourceUriImageHolder -> builder.data(uri)
            is ImageHolder.NetworkRequestImageHolder -> {
                val headerBuilder = NetworkHeaders.Builder()
                request.headers.forEach { (key, value) ->
                    headerBuilder[key] = value
                }
                builder.httpHeaders(headerBuilder.build())
                builder.data(request.url)
            }

            is ImageHolder.ResourceIdImageHolder -> builder.data(resId)
            is ImageHolder.HexColorImageHolder -> builder.data(hex.toColorInt().toDrawable())
        }
    }

    private fun ImageHolder?.createRequest(
        context: Context,
        placeholder: Int?,
        errorDrawable: Int?,
        vararg transformations: Transformation
    ): ImageRequest.Builder {
        val builder = ImageRequest.Builder(context)
        var error = errorDrawable
        if (error == null) error = placeholder

        if (this == null) {
            if (error != null) builder.data(error)
            return builder
        }
        createRequest(this, builder)
        placeholder?.let { builder.placeholder(it) }
        error?.let { builder.error(it) }
        val list = if (crop) listOf(squareCrop, *transformations) else transformations.toList()
        if (list.isNotEmpty()) builder.transformations(list)
        return builder
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\image\SquareCropTransformation.kt ----------
package com.joaomagdaleno.music_hub.utils.image

import android.graphics.Bitmap
import coil3.size.Size
import coil3.transform.Transformation

class SquareCropTransformation : Transformation() {
    val version = 1
    override val cacheKey = "${javaClass.simpleName}.$version"
    override suspend fun transform(input: Bitmap, size: Size): Bitmap {
        val max = input.width.coerceAtMost(input.height)
        val x = (input.width - max) / 2
        val y = (input.height - max) / 2
        return Bitmap.createBitmap(input, x, y, max, max)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\AnimationUtils.kt ----------
package com.joaomagdaleno.music_hub.utils.ui

import android.animation.ValueAnimator
import android.content.Context
import android.content.Context.MODE_PRIVATE
import android.view.View
import android.view.ViewGroup
import android.view.ViewPropertyAnimator
import android.view.animation.AlphaAnimation
import android.view.animation.Animation
import android.view.animation.AnimationSet
import android.view.animation.Interpolator
import android.view.animation.RotateAnimation
import android.view.animation.ScaleAnimation
import android.view.animation.TranslateAnimation
import androidx.core.animation.doOnEnd
import androidx.core.view.doOnLayout
import androidx.core.view.doOnPreDraw
import androidx.core.view.forEach
import androidx.core.view.forEachIndexed
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import com.google.android.material.color.MaterialColors
import com.google.android.material.motion.MotionUtils
import com.google.android.material.navigation.NavigationBarView
import com.google.android.material.transition.MaterialSharedAxis
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.utils.ContextUtils.SETTINGS_NAME
import kotlin.math.absoluteValue
import kotlin.math.sign

object AnimationUtils {

    private fun startAnimation(
        view: View, animation: ViewPropertyAnimator, durationMultiplier: Float = 1f
    ) = view.run {
        clearAnimation()
        val interpolator = getInterpolator(context)
        val duration = animationDuration * durationMultiplier
        animation.setInterpolator(interpolator).setDuration(duration.toLong()).start()
    }

    private fun getInterpolator(context: Context) = MotionUtils.resolveThemeInterpolator(
        context, com.google.android.material.R.attr.motionEasingStandardInterpolator,
        FastOutSlowInInterpolator()
    )

    fun View.animateMarginTop(hide: Boolean, onEnd: (() -> Unit)? = null) {
        if (!animations) {
            isVisible = hide
            return
        }
        isVisible = true
        val fromMargin = (layoutParams as ViewGroup.MarginLayoutParams).topMargin
        val toMargin = if (hide) 0 else -height
        val fromAlpha = alpha
        val toAlpha = if (hide) 1f else 0f

        val animator = ValueAnimator.ofFloat(0f, 1f)
        animator.addUpdateListener { valueAnimator ->
            val fraction = valueAnimator.animatedFraction
            val params = layoutParams as ViewGroup.MarginLayoutParams
            params.topMargin = (fromMargin + (toMargin - fromMargin) * fraction).toInt()
            layoutParams = params
            alpha = fromAlpha + (toAlpha - fromAlpha) * fraction
        }
        animator.duration = animationDuration
        animator.interpolator = getInterpolator(context)
        animator.doOnEnd {
            isVisible = hide
            onEnd?.invoke()
        }
        animator.start()
    }

    fun NavigationBarView.animateTranslation(
        isRail: Boolean,
        isMainFragment: Boolean,
        isPlayerCollapsed: Boolean,
        animate: Boolean = true,
        action: (Float) -> Unit
    ) = doOnLayout {
        val visible = isMainFragment && isPlayerCollapsed
        val value = if (visible) 0f
        else if (isRail) -width.toFloat() else height.toFloat()
        if (animations && animate) {
            var animation = if (isRail) animate().translationX(value)
            else animate().translationY(value)
            animation = if (visible) animation.withStartAction { action(value) }
            else animation.withEndAction { action(value) }
            startAnimation(this, animation)

            val delay = if (!visible) 0L else animationDurationSmall
            menu.forEachIndexed { index, item ->
                val view = findViewById<View>(item.itemId)
                val anim = view.animate().setStartDelay(index * delay)
                if (isRail) anim.translationX(value)
                else anim.translationY(value)
                startAnimation(view, anim, 0.5f)
            }
        } else {
            if (isRail) translationX = value
            else translationY = value

            menu.forEach {
                findViewById<View>(it.itemId).apply {
                    translationX = 0f
                    translationY = 0f
                }
            }
            action(value)
        }
    }

    fun View.animateVisibility(visible: Boolean, animate: Boolean = true) {
        if (animations && animate && isVisible != visible) {
            isVisible = true
            startAnimation(
                this,
                animate().alpha(if (visible) 1f else 0f).withEndAction {
                    alpha = if (visible) 1f else 0f
                    isVisible = visible
                }
            )
        } else {
            alpha = if (visible) 1f else 0f
            isVisible = visible
        }
    }

    fun animateTranslation(view: View, old: Int, newHeight: Int) = view.run {
        if (view.animations) {
            clearAnimation()
            view.translationY = newHeight.toFloat() - old
            startAnimation(this, animate().translationY(0f))
        }
    }

    private val View.animationDuration: Long
        get() = context.applicationContext.run {
            MotionUtils.resolveThemeDuration(
                this, com.google.android.material.R.attr.motionDurationMedium1, 350
            ).toLong()
        }

    private val View.animationDurationSmall: Long
        get() = context.applicationContext.run {
            MotionUtils.resolveThemeDuration(
                this, com.google.android.material.R.attr.motionDurationShort1, 100
            ).toLong()
        }

    const val ANIMATIONS_KEY = "animations"
    const val SCROLL_ANIMATIONS_KEY = "shared_element"

    private val View.animations
        get() = context.applicationContext.run {
            getSharedPreferences(SETTINGS_NAME, MODE_PRIVATE).getBoolean(ANIMATIONS_KEY, true)
        }

    private val View.scrollAnimations
        get() = context.applicationContext.run {
            getSharedPreferences(SETTINGS_NAME, MODE_PRIVATE)
                .getBoolean(SCROLL_ANIMATIONS_KEY, false)
        }

    fun Fragment.setupTransition(
        view: View, applyBackground: Boolean = true, axis: Int = MaterialSharedAxis.Z
    ) {
        if (applyBackground) {
            val color = MaterialColors.getColor(view, R.attr.echoBackground, 0)
            view.setBackgroundColor(color)
        }

        if (view.animations) {
//        val transitionName = arguments?.getString("transitionName")
//        if (transitionName != null) {
//            view.transitionName = transitionName
//            val transition = MaterialContainerTransform().apply {
//                drawingViewId = id
//                setAllContainerColors(color)
//                duration = view.animationDuration
//            }
//            sharedElementEnterTransition = transition
//        }
            (view as? ViewGroup)?.isTransitionGroup = true
            exitTransition = MaterialSharedAxis(axis, true)
            reenterTransition = MaterialSharedAxis(axis, false)
            enterTransition = MaterialSharedAxis(axis, true)
            returnTransition = MaterialSharedAxis(axis, false)

            postponeEnterTransition()
            view.doOnPreDraw { startPostponedEnterTransition() }
        }
    }

    fun View.animatedWithAlpha(delay: Long = 0, vararg anim: Animation) {
        if (!animations) return
        val set = AnimationSet(true)
        set.interpolator = getInterpolator(context) as Interpolator
        val alpha = AlphaAnimation(0.0f, 1.0f)
        alpha.duration = animationDurationSmall
        alpha.startOffset = delay
        set.addAnimation(alpha)
        anim.forEach { set.addAnimation(it) }
        startAnimation(set)
    }

    fun View.applyTranslationAndScaleAnimation(
        amount: Int, delay: Long = 0
    ) {
        if (!animations) return
        if (!scrollAnimations) return
        val multiplier = amount.sign
        val rotateAnimation = RotateAnimation(
            5f * multiplier, 0f,
            width.toFloat() / 2, height.toFloat() / 2
        )
        rotateAnimation.duration = animationDuration
        val translate = TranslateAnimation(
            Animation.RELATIVE_TO_SELF, multiplier * 0.5f,
            Animation.RELATIVE_TO_SELF, 0f,
            Animation.RELATIVE_TO_SELF, 0f,
            Animation.RELATIVE_TO_SELF, 0f,
        )
        translate.duration = animationDuration
        val from = 1f - 0.5f * multiplier.absoluteValue
        val scale = ScaleAnimation(
            from, 1f, from, 1f,
            Animation.RELATIVE_TO_SELF, 0.5f,
            Animation.RELATIVE_TO_SELF, 0.5f
        )
        scale.duration = animationDuration
        animatedWithAlpha(delay, rotateAnimation, translate, scale)
    }

    fun View.applyTranslationYAnimation(amount: Int, delay: Long = 0) {
        if (!animations) return
        if (!scrollAnimations) return
        val multiplier = amount.sign
        val translate = TranslateAnimation(
            Animation.RELATIVE_TO_SELF, 0f,
            Animation.RELATIVE_TO_SELF, 0f,
            Animation.RELATIVE_TO_SELF, multiplier * 1.5f,
            Animation.RELATIVE_TO_SELF, 0f,
        )
        translate.duration = animationDuration
        translate.startOffset = delay
        animatedWithAlpha(delay, translate)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\AutoClearedValue.kt ----------
package com.joaomagdaleno.music_hub.utils.ui

import androidx.fragment.app.Fragment
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import kotlin.properties.ReadWriteProperty
import kotlin.reflect.KProperty

class AutoClearedValue<T : Any>(val fragment: Fragment) : ReadWriteProperty<Fragment, T> {
    private var _value: T? = null

    init {
        fragment.addOnDestroyObserver { _value = null }
    }

    override fun getValue(thisRef: Fragment, property: KProperty<*>): T {
        return _value ?: throw IllegalStateException(
            "should never call auto-cleared-value get when it might not be available"
        )
    }

    override fun setValue(thisRef: Fragment, property: KProperty<*>, value: T) {
        _value = value
    }

    class Nullable<T : Any>(val fragment: Fragment) : ReadWriteProperty<Fragment, T?> {
        private var _value: T? = null

        override fun getValue(thisRef: Fragment, property: KProperty<*>) = _value

        override fun setValue(thisRef: Fragment, property: KProperty<*>, value: T?) {
            _value = value
        }

    }

    companion object {
        fun Fragment.addOnDestroyObserver(onDestroy: () -> Unit) {
            lifecycle.addObserver(object : DefaultLifecycleObserver {
                override fun onCreate(owner: LifecycleOwner) {
                    viewLifecycleOwnerLiveData.observe(this@addOnDestroyObserver) {
                        it?.lifecycle?.addObserver(
                            object : DefaultLifecycleObserver {
                                override fun onDestroy(owner: LifecycleOwner) {
                                    onDestroy()
                                }
                            }
                        )
                    }
                }
            })
        }

        fun <T : Any> Fragment.autoCleared() = AutoClearedValue<T>(this)
        fun <T : Any> Fragment.autoClearedNullable() = Nullable<T>(this)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\CheckBoxListener.kt ----------
package com.joaomagdaleno.music_hub.utils.ui

import com.google.android.material.checkbox.MaterialCheckBox

class CheckBoxListener(private val block: (Boolean) -> Unit) :
    MaterialCheckBox.OnCheckedStateChangedListener {
    var enabled = true
    private var checked = false
    private fun check(isChecked: Boolean) {
        if (checked == isChecked) return
        block(isChecked)
    }

    override fun onCheckedStateChangedListener(checkBox: MaterialCheckBox, state: Int) {
        val isChecked = checkBox.isChecked
        if (enabled) check(isChecked)
        checked = isChecked
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\FastScrollerHelper.kt ----------
package com.joaomagdaleno.music_hub.utils.ui

import android.view.View
import androidx.core.widget.NestedScrollView
import androidx.recyclerview.widget.RecyclerView
import com.joaomagdaleno.music_hub.utils.ContextUtils.getSettings
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.dpToPx
import me.zhanghai.android.fastscroll.FastScroller
import me.zhanghai.android.fastscroll.FastScrollerBuilder


object FastScrollerHelper {
    const val SCROLL_BAR = "scroll_bar"
    fun View.isScrollBarEnabled() = context.getSettings().getBoolean(SCROLL_BAR, false)

    fun applyTo(view: RecyclerView): FastScroller? {
        view.isVerticalScrollBarEnabled = false
        if (!view.isScrollBarEnabled()) return null
        return FastScrollerBuilder(view).apply {
            useMd2Style()
            val pad = 8.dpToPx(view.context)
            setPadding(pad, pad, pad, pad)
        }.build()
    }

    fun applyTo(view: NestedScrollView): FastScroller? {
        view.isVerticalScrollBarEnabled = false
        if (!view.isScrollBarEnabled()) return null
        return FastScrollerBuilder(view).apply {
            useMd2Style()
            val pad = 8.dpToPx(view.context)
            setPadding(pad, pad, pad, pad)
        }.build()
    }

}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\GestureListener.kt ----------
package com.joaomagdaleno.music_hub.utils.ui

import android.graphics.drawable.RippleDrawable
import android.view.GestureDetector
import android.view.MotionEvent
import android.view.View
import java.util.Timer
import kotlin.concurrent.schedule

interface GestureListener {
    val onClick: () -> Unit
    val onLongClick: (() -> Unit)?
    val onDoubleClick: (() -> Unit)?

    companion object {
        fun View.handleGestures(listener: GestureListener) {
            val gestureListener = object : GestureDetector.SimpleOnGestureListener() {
                private var timer: Timer? = null
                private var beingDoubleClicked = false
                override fun onSingleTapConfirmed(e: MotionEvent): Boolean {
                    if (!beingDoubleClicked) listener.onClick()
                    else return onDoubleTap(e)
                    return true
                }

                override fun onDoubleTap(e: MotionEvent): Boolean {
                    val onDoubleClick = listener.onDoubleClick ?: return false
                    isPressed = true
                    isPressed = false
                    (background as? RippleDrawable)?.setHotspot(e.x, e.y)
                    onDoubleClick.invoke()
                    beingDoubleClicked = true
                    timer?.cancel()
                    val timer = Timer()
                    this.timer = timer
                    timer.schedule(1000) { beingDoubleClicked = false }
                    return true
                }

                override fun onLongPress(e: MotionEvent) {
                    listener.onLongClick?.invoke()
                }
            }
            val detector = GestureDetector(context, gestureListener)
            setOnTouchListener { _, event ->
                detector.onTouchEvent(event)
                performClick()
                true
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\GradientDrawable.kt ----------
package com.joaomagdaleno.music_hub.utils.ui

import android.R.attr.colorPrimary
import android.graphics.BitmapShader
import android.graphics.Color
import android.graphics.ComposeShader
import android.graphics.LinearGradient
import android.graphics.Matrix
import android.graphics.PorterDuff
import android.graphics.Shader
import android.graphics.drawable.Drawable
import android.graphics.drawable.PaintDrawable
import android.graphics.drawable.ShapeDrawable
import android.graphics.drawable.shapes.RectShape
import android.view.View
import androidx.core.content.res.ResourcesCompat
import androidx.core.graphics.ColorUtils
import androidx.core.graphics.drawable.toBitmap
import androidx.core.graphics.drawable.toDrawable
import com.google.android.material.color.MaterialColors
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.utils.image.BlurTransformation.Companion.blurred
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.isRTL

object GradientDrawable {
    fun applyNav(
        view: View,
        isRail: Boolean,
        bottom: Int = 0,
        full: Boolean = true,
    ) {
        val color = MaterialColors.getColor(view, R.attr.navBackground)
        val isRTL = !view.context.isRTL()
        view.background = PaintDrawable().apply {
            setShape(RectShape())
            shaderFactory = object : ShapeDrawable.ShaderFactory() {
                override fun resize(width: Int, height: Int): Shader {
                    val centerY = if (isRail) 1f else (height * 0.5f + bottom) / (height + bottom)
                    val startX = if (isRail) if (isRTL) width.toFloat() else 0f else width / 2f
                    val startY = if (isRail) height / 2f else 0f
                    val endX = if (isRail) if (isRTL) 0f else width.toFloat() else width / 2f
                    val endY = if (isRail) height / 2f else height.toFloat()
                    return LinearGradient(
                        startX,
                        startY,
                        endX,
                        endY,
                        intArrayOf(if (full) color else Color.TRANSPARENT, color, color),
                        floatArrayOf(0f, centerY, 1f),
                        Shader.TileMode.CLAMP
                    )
                }
            }
        }
    }

    private const val RATIO = 0.33f
    private val maxColor = Color.argb(128, 0, 0, 0)
    fun createBlurred(view: View, toBlur: Drawable?): Drawable {
        val background = MaterialColors.getColor(view, R.attr.echoBackground)
        val primary = MaterialColors.getColor(view, colorPrimary)
        if (toBlur == null) return background.toDrawable()
        val noise = ResourcesCompat.getDrawable(
            view.resources, R.drawable.grain_noise, view.context.theme
        )!!.toBitmap()
        val bitmap = toBlur.run {
            toBitmap(
                intrinsicWidth.coerceAtLeast(1),
                intrinsicHeight.coerceAtLeast(1),
            )
        }.blurred(view.context)
        return PaintDrawable().apply {
            setShape(RectShape())
            paint.shader = null
            shaderFactory = object : ShapeDrawable.ShaderFactory() {
                override fun resize(width: Int, height: Int): Shader {
                    val bitmapShader =
                        BitmapShader(bitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR)
                    val cropHeight = (height * RATIO).toInt().coerceAtLeast(1)
                    val scale = maxOf(
                        width.toFloat() / bitmap.width,
                        cropHeight.toFloat() / bitmap.height
                    )
                    val matrix = Matrix().apply {
                        setScale(scale, scale)
                    }
                    bitmapShader.setLocalMatrix(matrix)

                    val primaryOverlay = LinearGradient(
                        0f, 0f, 0f, height.toFloat(),
                        intArrayOf(ColorUtils.setAlphaComponent(primary, 84), Color.TRANSPARENT),
                        floatArrayOf(0f, 1f),
                        Shader.TileMode.CLAMP
                    )
                    val blurredWithPrimary = ComposeShader(
                        bitmapShader,
                        primaryOverlay,
                        PorterDuff.Mode.SRC_OVER
                    )
                    val composed = ComposeShader(
                        blurredWithPrimary,
                        LinearGradient(
                            0f,
                            0f,
                            0f,
                            height.toFloat(),
                            intArrayOf(maxColor, Color.TRANSPARENT, Color.TRANSPARENT),
                            floatArrayOf(0f, RATIO, 1f),
                            Shader.TileMode.CLAMP
                        ),
                        PorterDuff.Mode.DST_IN
                    )
                    val withNoise = ComposeShader(
                        composed,
                        BitmapShader(noise, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT),
                        PorterDuff.Mode.DST_IN
                    )
                    val backgroundShader = LinearGradient(
                        0f,
                        0f,
                        0f,
                        height.toFloat(),
                        intArrayOf(background, background),
                        null,
                        Shader.TileMode.CLAMP
                    )
                    return ComposeShader(
                        backgroundShader,
                        withNoise,
                        PorterDuff.Mode.SRC_OVER
                    )
                }
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\RulerAdapter.kt ----------
package com.joaomagdaleno.music_hub.utils.ui

import android.annotation.SuppressLint
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.HapticFeedbackConstantsCompat
import androidx.core.view.doOnLayout
import androidx.core.view.marginLeft
import androidx.core.view.marginRight
import androidx.core.view.updateLayoutParams
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.PagerSnapHelper
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.R
import com.google.android.material.color.MaterialColors
import com.joaomagdaleno.music_hub.databinding.ItemRulerBinding
import com.joaomagdaleno.music_hub.databinding.ItemRulerEmptyBinding
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.dpToPx

class RulerAdapter<T>(
    private val listener: Listener<T>
) : RecyclerView.Adapter<RulerAdapter.ViewHolder>() {

    interface Listener<T> {
        fun intervalText(value: T): String
        fun onSelectItem(value: T)

        val selectedColor get() = androidx.appcompat.R.attr.colorPrimary
        val unselectedColor get() = R.attr.colorOnSurface
    }

    sealed class ViewHolder(root: View) : RecyclerView.ViewHolder(root) {
        open fun bind(position: Int) {}

        class Empty(
            parent: ViewGroup, binding: ItemRulerEmptyBinding = ItemRulerEmptyBinding.inflate(
                LayoutInflater.from(parent.context), parent, false
            )
        ) : ViewHolder(binding.root) {
            init {
                parent.doOnLayout {
                    binding.root.updateLayoutParams {
                        val itemWidth = 24.dpToPx(it.context)
                        width = (it.width - itemWidth) / 2
                    }
                }
            }
        }

        class Item<T>(
            parent: ViewGroup,
            private val getItem: (Int) -> Pair<T, Boolean>?,
            private val listener: Listener<T>,
            private val binding: ItemRulerBinding = ItemRulerBinding.inflate(
                LayoutInflater.from(parent.context), parent, false
            )
        ) : ViewHolder(binding.root) {
            override fun bind(position: Int) {
                val (value, showText) = getItem(position) ?: return
                binding.rulerText.text = if (showText) listener.intervalText(value) else ""
                unselect()
            }

            fun select() {
                binding.rulerCard.setCardBackgroundColor(
                    MaterialColors.getColor(itemView, listener.selectedColor, 0)
                )
            }

            fun unselect() {
                binding.rulerCard.setCardBackgroundColor(
                    MaterialColors.getColor(itemView, listener.unselectedColor, 0)
                )
            }
        }
    }

    override fun getItemViewType(position: Int) = when (position) {
        0, itemCount - 1 -> 0
        else -> 1
    }

    private var currentList = listOf<Pair<T, Boolean>?>(null, null)
    private fun getItem(position: Int): Pair<T, Boolean>? {
        return currentList.getOrNull(position)
    }

    override fun getItemCount() = currentList.size

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        return when (viewType) {
            0 -> ViewHolder.Empty(parent)
            else -> ViewHolder.Item(parent, ::getItem, listener)
        }
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(position)
    }

    private var selectedIndex: Int = -1
    @SuppressLint("NotifyDataSetChanged")
    fun submitList(list: List<Pair<T, Boolean>>, selected: T) {
        currentList = buildList {
            add(null)
            addAll(list)
            add(null)
        }
        val index = list.indexOfFirst { it.first == selected }
        selectedIndex = index + 1
        notifyDataSetChanged()
    }

    private var recyclerView: RecyclerView? = null
    private var selectedVH: ViewHolder.Item<*>? = null
    private fun select() {
        val (vh, newIndex) = getMiddleItem() ?: return
        if (vh == selectedVH) return
        selectedIndex = newIndex
        selectedVH?.unselect()
        vh.select()
        selectedVH = vh
        vh.itemView.run {
            isHapticFeedbackEnabled = true
            performHapticFeedback(HapticFeedbackConstantsCompat.CLOCK_TICK)
        }
        listener.onSelectItem(getItem(newIndex)!!.first)
    }

    private val recyclerListener = object : RecyclerView.OnScrollListener() {
        override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
            select()
        }
    }

    private fun scrollToMiddle(after: () -> Unit = {}) {
        recyclerView?.run {
            val manager = layoutManager as LinearLayoutManager
            doOnLayout {
                val itemWidth = 24.dpToPx(context)
                val pad = (width - itemWidth) / 2
                manager.scrollToPositionWithOffset(selectedIndex, pad)
                post {
                    after()
                }
            }
        }
    }

    private val snapHelper = PagerSnapHelper()
    override fun onAttachedToRecyclerView(recyclerView: RecyclerView) {
        this.recyclerView = recyclerView
        snapHelper.attachToRecyclerView(recyclerView)
        scrollToMiddle {
            select()
            recyclerView.addOnScrollListener(recyclerListener)
        }
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        this.recyclerView?.removeOnScrollListener(recyclerListener)
        snapHelper.attachToRecyclerView(null)
        this.recyclerView = null
    }

    private fun getMiddleItem() = recyclerView?.run {
        val middle = width * .5f
        val layoutManager = layoutManager as LinearLayoutManager

        val firstVisibleIndex = layoutManager.findFirstVisibleItemPosition()
        val lastVisibleIndex = layoutManager.findLastVisibleItemPosition()
        val visibleIndexes = firstVisibleIndex..lastVisibleIndex

        visibleIndexes.forEach {
            if (it == 0 || it == itemCount - 1) return@forEach
            val vh = findViewHolderForLayoutPosition(it) ?: return@forEach
            val location = IntArray(2)
            vh.itemView.getLocationOnScreen(location)
            val x = location[0]
            val halfWidth = vh.itemView.run { width + marginLeft + marginRight } * .5f
            val rightSide = x + halfWidth
            val leftSide = x - halfWidth
            val isInMiddle = middle in leftSide..rightSide
            if (isInMiddle) {
                return@run vh as ViewHolder.Item<*> to it
            }
        }
        null
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\SimpleItemSpan.kt ----------
package com.joaomagdaleno.music_hub.utils.ui

import android.content.Context
import android.text.TextPaint
import android.text.style.ClickableSpan
import android.view.View
import com.joaomagdaleno.music_hub.R

class SimpleItemSpan(
    val context: Context,
    private val onItemClicked: () -> Unit
) : ClickableSpan() {

    override fun onClick(widget: View) {
        onItemClicked()
    }

    override fun updateDrawState(ds: TextPaint) {
        super.updateDrawState(ds)
        ds.isUnderlineText = false
        context.run {
            ds.color = resources.getColor(R.color.button_player, theme)
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\UiUtils.kt ----------
package com.joaomagdaleno.music_hub.utils.ui

import android.app.Activity
import android.content.Context
import android.content.res.Configuration.ORIENTATION_LANDSCAPE
import android.content.res.Configuration.UI_MODE_NIGHT_MASK
import android.content.res.Configuration.UI_MODE_NIGHT_NO
import android.text.TextUtils
import android.view.View
import android.view.WindowManager
import android.widget.TextView
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.WindowInsetsControllerCompat
import com.google.android.material.appbar.AppBarLayout
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.BACKGROUND_GRADIENT
import com.joaomagdaleno.music_hub.utils.ContextUtils.getSettings
import java.util.Locale
import kotlin.math.max
import kotlin.math.roundToLong

object UiUtils {

    fun Activity.hideSystemUi(hide: Boolean) {
        val controller = WindowCompat.getInsetsController(window, window.decorView)
        controller.systemBarsBehavior =
            WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE

        if (hide) {
            controller.hide(WindowInsetsCompat.Type.systemBars())
            window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        } else {
            controller.show(WindowInsetsCompat.Type.systemBars())
            window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        }
    }

    fun AppBarLayout.configureAppBar(block: (offset: Float) -> Unit) {
        val settings = context.getSettings()
        val isGradient = settings.getBoolean(BACKGROUND_GRADIENT, true)
        val extra = if (isGradient) -191 else 0
        addOnOffsetChangedListener { _, verticalOffset ->
            val offset = -verticalOffset / totalScrollRange.toFloat()
            background?.mutate()?.alpha = max(0, extra + (offset * 255).toInt())
            runCatching { block(offset) }
        }
    }

    fun Context.isRTL() =
        resources.configuration.layoutDirection == View.LAYOUT_DIRECTION_RTL

    fun Context.isLandscape() =
        resources.configuration.orientation == ORIENTATION_LANDSCAPE

    fun Context.isNightMode() =
        resources.configuration.uiMode and UI_MODE_NIGHT_MASK != UI_MODE_NIGHT_NO

    fun Int.dpToPx(context: Context) = (this * context.resources.displayMetrics.density).toInt()

    fun Context.resolveStyledDimension(attr: Int): Int {
        val typed = theme.obtainStyledAttributes(intArrayOf(attr))
        val itemWidth = typed.getDimensionPixelSize(typed.getIndex(0), 0)
        return itemWidth
    }

    fun Long.toTimeString(): String {
        val seconds = (this.toFloat() / 1000).roundToLong()
        val minutes = seconds / 60
        val hours = minutes / 60
        return if (hours > 0) {
            String.format(Locale.ENGLISH, "%02d:%02d:%02d", hours, minutes % 60, seconds % 60)
        } else {
            String.format(Locale.ENGLISH, "%02d:%02d", minutes, seconds % 60)
        }
    }

    fun TextView.marquee() {
        isSelected = true
        ellipsize = TextUtils.TruncateAt.MARQUEE
        maxLines = 1
        marqueeRepeatLimit = -1
        setHorizontallyScrolling(true)
    }

    fun BottomSheetDialogFragment.configureBottomBar(bar: View) {
        val view = requireView()
        val dialog = requireDialog() as BottomSheetDialog
        val behavior = dialog.behavior
        val barHeight = 72.dpToPx(requireContext())
        var peek = 0
        var toScroll = 0
        var offset = 0f

        val callback = object : BottomSheetBehavior.BottomSheetCallback() {
            override fun onStateChanged(p0: View, p1: Int) {}
            override fun onSlide(p0: View, p1: Float) {
                offset = p1.coerceAtLeast(0f)
                bar.y = peek + toScroll * offset
            }
        }
        view.addOnLayoutChangeListener { v, _, _, _, _, _, _, _, _ ->
            val screen = v.height - barHeight
            peek = (behavior.peekHeight - barHeight).coerceAtMost(screen)
            toScroll = screen - peek
            bar.y = peek + toScroll * offset
        }
        behavior.addBottomSheetCallback(callback)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\ViewPager2Utils.kt ----------
package com.joaomagdaleno.music_hub.utils.ui

import android.view.View
import androidx.recyclerview.widget.RecyclerView
import androidx.viewpager.widget.ViewPager
import androidx.viewpager2.widget.ViewPager2
import androidx.viewpager2.widget.ViewPager2.OnPageChangeCallback

object ViewPager2Utils {

    fun ViewPager2.supportBottomSheetBehavior() {
        val recycler = getChildAt(0) as RecyclerView
        recycler.run {
            isNestedScrollingEnabled = false
            overScrollMode = View.OVER_SCROLL_NEVER
        }
    }

    fun ViewPager2.registerOnUserPageChangeCallback(
        listener: (position: Int, userInitiated: Boolean) -> Unit
    ) {
        var previousState: Int = -1
        var userScrollChange = false
        registerOnPageChangeCallback(object : OnPageChangeCallback() {

            override fun onPageSelected(position: Int) {
                listener(position, userScrollChange)
            }

            override fun onPageScrollStateChanged(state: Int) {
                if (previousState == ViewPager.SCROLL_STATE_DRAGGING &&
                    state == ViewPager.SCROLL_STATE_SETTLING
                ) {
                    userScrollChange = true
                } else if (previousState == ViewPager.SCROLL_STATE_SETTLING &&
                    state == ViewPager.SCROLL_STATE_IDLE
                ) {
                    userScrollChange = false
                }
                previousState = state
            }
        })
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\prefs\ColorListPreference.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.prefs

import android.annotation.SuppressLint
import android.content.SharedPreferences
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.edit
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.preference.Preference
import androidx.preference.PreferenceViewHolder
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.card.MaterialCardView
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.databinding.ItemColorCardBinding

class ColorListPreference(val fragment: Fragment, var listener: Listener? = null) :
    Preference(fragment.requireContext()) {

    fun interface Listener {
        fun onColorSelected(color: Int)
    }

    private lateinit var colorCardAdapter: ColorCardAdapter
    private lateinit var sharedPreferences: SharedPreferences

    init {
        layoutResource = R.layout.preference_color_list
    }

    private var defaultValue: Int? = null
    override fun onSetInitialValue(defaultValue: Any?) {
        this.defaultValue = defaultValue as? Int
    }

    @SuppressLint("NotifyDataSetChanged")
    override fun onBindViewHolder(holder: PreferenceViewHolder) {
        super.onBindViewHolder(holder)
        val view: View = holder.itemView
        view.alpha = if (isEnabled) 1f else 0.66f

        sharedPreferences = preferenceManager.sharedPreferences!!
        val addColorCard: MaterialCardView = view.findViewById(R.id.addColor)
        val recentColorsRecyclerView: RecyclerView = view.findViewById(R.id.recentColors)

        colorCardAdapter = ColorCardAdapter(getSavedColors(), adapterListener)
        recentColorsRecyclerView.adapter = colorCardAdapter

        addColorCard.setOnClickListener {
            if (!isEnabled) return@setOnClickListener
            ColorPickerDialog().show(fragment.parentFragmentManager, null)
        }

        fragment.parentFragmentManager
            .setFragmentResultListener("colorPicker", fragment) { _, bundle ->
                val color = bundle.getInt("color").takeIf { it != -1 }
                    ?: return@setFragmentResultListener
                addColor(color)
                colorCardAdapter.colors = getSavedColors()
                colorCardAdapter.notifyDataSetChanged()
            }
    }

    private val adapterListener = object : ColorCardAdapter.Listener {
        @SuppressLint("NotifyDataSetChanged")
        override fun onColorSelected(color: Int) {
            if (!isEnabled) return
            saveSelectedColor(color)
            colorCardAdapter.colors = getSavedColors()
            colorCardAdapter.notifyDataSetChanged()
            listener?.onColorSelected(color)
        }

        @SuppressLint("NotifyDataSetChanged")
        override fun onColorRemoved(color: Int): Boolean {
            if (!isEnabled) return false
            removeColor(color)
            colorCardAdapter.colors = getSavedColors()
            colorCardAdapter.notifyDataSetChanged()
            return true
        }
    }

    class ColorCardAdapter(var colors: List<Pair<Boolean, Int>>, val listener: Listener) :
        RecyclerView.Adapter<ColorCardAdapter.ViewHolder>() {
        interface Listener {
            fun onColorSelected(color: Int)
            fun onColorRemoved(color: Int): Boolean
        }

        inner class ViewHolder(val binding: ItemColorCardBinding) :
            RecyclerView.ViewHolder(binding.root) {
            init {
                binding.root.setOnClickListener {
                    listener.onColorSelected(colors[bindingAdapterPosition].second)
                }
                binding.root.setOnLongClickListener {
                    listener.onColorRemoved(colors[bindingAdapterPosition].second)
                }
            }
        }

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
            val inflater = LayoutInflater.from(parent.context)
            val binding = ItemColorCardBinding.inflate(inflater, parent, false)
            return ViewHolder(binding)
        }

        override fun getItemCount() = colors.size

        override fun onBindViewHolder(holder: ViewHolder, position: Int) {
            val color = colors[position]
            holder.binding.root.setCardBackgroundColor(color.second)
            holder.binding.colorSelected.isVisible = color.first
        }

    }

    private fun getSelectedColor(): Int? {
        val color = sharedPreferences.getInt(key, defaultValue ?: -1)
        return color.takeIf { it != -1 }
    }

    private fun saveSelectedColor(color: Int?) {
        sharedPreferences.edit {
            putInt(key, color ?: -1)
        }
    }

    private fun getSavedColors(): List<Pair<Boolean, Int>> {
        val selectedColor = getSelectedColor()
        val colorString = sharedPreferences.getString("${key}_colors", "")
            ?.split(",").orEmpty()
            .map { it.toIntOrNull() } - selectedColor
        val colors = colorString.mapNotNull { it?.let { false to it } }
        return listOfNotNull(selectedColor?.let { true to it }) + colors
    }

    private fun List<Pair<Boolean, Int>>.inString() = joinToString(",") { it.second.toString() }

    private fun addColor(color: Int) {
        val colorList = getSavedColors().toMutableList()
        colorList.add(false to color)
        sharedPreferences.edit {
            putString("${key}_colors", colorList.inString())
        }
    }

    private fun removeColor(color: Int) {
        val colorList = getSavedColors().toMutableList()
        colorList.removeAll { it.second == color }
        sharedPreferences.edit {
            putString("${key}_colors", colorList.inString())
        }
    }

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\prefs\ColorPickerDialog.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.prefs

import android.graphics.Color
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.DialogFragment
import com.madrapps.pikolo.listeners.OnColorSelectionListener
import com.joaomagdaleno.music_hub.databinding.DialogColorPickerBinding
import com.joaomagdaleno.music_hub.utils.ui.AutoClearedValue.Companion.autoCleared
import kotlin.random.Random

class ColorPickerDialog : DialogFragment() {

    var binding by autoCleared<DialogColorPickerBinding>()
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        binding = DialogColorPickerBinding.inflate(inflater, container, false)
        return binding.root
    }

    var currentColor: Int? = null
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        binding.colorPickerView.setColorSelectionListener(object : OnColorSelectionListener {
            override fun onColorSelected(color: Int) {
                currentColor = color
                binding.colorCard.setCardBackgroundColor(color)
            }

            override fun onColorSelectionEnd(color: Int) {}
            override fun onColorSelectionStart(color: Int) {}
        })
        binding.addColorButton.setOnClickListener { dismiss() }
        binding.randomColorButton.setOnClickListener { setColor(generateRandomColor()) }
        setColor(generateRandomColor())
    }

    private fun setColor(color: Int){
        currentColor = color
        binding.colorCard.setCardBackgroundColor(color)
        binding.colorPickerView.setColor(color)
    }

    private fun generateRandomColor(): Int {
        val red = Random.nextInt(256)
        val green = Random.nextInt(256)
        val blue = Random.nextInt(256)
        return Color.rgb(red, green, blue)
    }

    override fun onDestroy() {
        super.onDestroy()
        parentFragmentManager.setFragmentResult("colorPicker", Bundle().apply {
            putInt("color", currentColor!!)
        })
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\prefs\LoadingPreference.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.prefs

import android.content.Context
import androidx.preference.Preference
import com.joaomagdaleno.music_hub.R

class LoadingPreference(context: Context) : Preference(context) {
    init {
        layoutResource = R.layout.item_loading
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\prefs\LongClickPreference.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.prefs

import android.content.Context
import androidx.preference.Preference
import androidx.preference.PreferenceViewHolder

open class LongClickPreference(context:Context) : Preference(context) {
    private var onLongClickListener: (() -> Unit)? = null

    fun setOnLongClickListener(listener: () -> Unit) {
        onLongClickListener = listener
    }
    override fun onBindViewHolder(holder: PreferenceViewHolder) {
        super.onBindViewHolder(holder)

        val listener = onLongClickListener ?: return
        holder.itemView.setOnLongClickListener {
            listener.invoke()
            true
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\prefs\MaterialListPreference.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.prefs

import android.content.Context
import androidx.preference.ListPreference
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.joaomagdaleno.music_hub.R

class MaterialListPreference(context: Context) : ListPreference(context) {

    private var customSummary: CharSequence? = null

    override fun onSetInitialValue(defaultValue: Any?) {
        super.onSetInitialValue(defaultValue)
        customSummary = summary
        updateSummary()
    }

    override fun onClick() {
        MaterialAlertDialogBuilder(context)
            .setSingleChoiceItems(entries, entryValues.indexOf(value)) { dialog, index ->
                if (callChangeListener(entryValues[index].toString())) runCatching {
                    setValueIndex(index)
                    updateSummary()
                }
                dialog.dismiss()
            }
            .setNegativeButton(R.string.cancel) { dialog, _ -> dialog.dismiss() }.setTitle(title)
            .create()
            .show()
    }

    private fun updateSummary() {
        val value = context.getString(R.string.value)
        val entry = entry.takeIf { !it.isNullOrEmpty() } ?: context.getString(R.string.value_not_set)
        val sum = customSummary?.let { "\n\n$it" } ?: ""
        summary = "$value : $entry$sum"
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\prefs\MaterialMultipleChoicePreference.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.prefs

import android.content.Context
import androidx.preference.MultiSelectListPreference
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.joaomagdaleno.music_hub.R

class MaterialMultipleChoicePreference(context: Context) : MultiSelectListPreference(context) {

    private var customSummary: CharSequence? = null

    override fun onSetInitialValue(defaultValue: Any?) {
        super.onSetInitialValue(defaultValue)
        customSummary = summary
        updateSummary()
    }

    override fun onClick() {
        val selectedIndices = BooleanArray(entries.size) { index ->
            values.contains(entryValues.getOrNull(index))
        }

        MaterialAlertDialogBuilder(context)
            .setMultiChoiceItems(entries, selectedIndices) { _, which, isChecked ->
                val value = entryValues.getOrNull(which)
                if (isChecked && value != null) {
                    values.add(value.toString())
                } else {
                    values.remove(value)
                }
            }
            .setPositiveButton(R.string.okay) { dialog, _ ->
                if (callChangeListener(values)) {
                    setValues(values.toSet())
                    updateSummary()
                }
                dialog.dismiss()
            }
            .setNegativeButton(R.string.cancel) { dialog, _ -> dialog.dismiss() }
            .setTitle(title)
            .create()
            .show()
    }

    private fun updateSummary() {
        val value = context.getString(R.string.value)
        val entry = values.takeIf { it.isNotEmpty() }?.joinToString(", ") { v ->
            val index = entryValues.indexOf(v)
            if (index >= 0) entries.getOrNull(index).toString() else v
        } ?: context.getString(R.string.value_not_set)
        val sum = customSummary?.let { "\n\n$it" } ?: ""
        summary = "$value : $entry$sum"
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\prefs\MaterialSliderPreference.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.prefs

import android.app.AlertDialog
import android.content.Context
import android.widget.EditText
import androidx.preference.Preference
import androidx.preference.PreferenceViewHolder
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.google.android.material.slider.Slider
import com.joaomagdaleno.music_hub.R
import kotlin.math.max
import kotlin.math.min

class MaterialSliderPreference(
    context: Context,
    private val from: Int,
    private val to: Int,
    private val steps: Int? = null,
    private val allowOverride: Boolean = false
) : Preference(context) {
    init {
        layoutResource = R.layout.preference_slider
    }

    private var customSummary: CharSequence? = null
    private var defaultValue: Int? = null

    override fun onSetInitialValue(defaultValue: Any?) {
        customSummary = summary
        this.defaultValue = defaultValue as? Int
        updateSummary()
    }

    override fun onBindViewHolder(holder: PreferenceViewHolder) {
        super.onBindViewHolder(holder)
        val slider = holder.itemView.findViewById<Slider>(R.id.preferences_slider)
        val current = getPersistedInt(defaultValue ?: from)
        val min = if (allowOverride) min(from, current) else from
        slider.valueFrom = min.toFloat()
        val max = if (allowOverride) max(to, current) else to
        slider.valueTo = max.toFloat()
        slider.value = min(max(current, min), max).toFloat()
        slider.stepSize = steps?.toFloat() ?: 1f

        slider.addOnChangeListener { _, value, byUser ->
            persistInt(value.toInt())
            slider.post {
                runCatching {
                    updateSummary()
                    if (allowOverride && !dialogOpened && byUser && value == slider.valueTo)
                        showOverrideDialog(slider, value)
                }
            }
        }

        if (allowOverride) holder.itemView.setOnClickListener {
            showOverrideDialog(slider, slider.value)
        }
    }

    private var dialogOpened = false
    private fun showOverrideDialog(slider: Slider, value: Float) {
        dialogOpened = true
        val dialog = MaterialAlertDialogBuilder(context)
            .setView(R.layout.item_edit_text)
            .setPositiveButton(R.string.okay, null)
            .setNegativeButton(R.string.cancel, null)
            .setTitle(title)
            .create()

        dialog.setOnShowListener {
            val editText = dialog.findViewById<EditText>(R.id.edit_text)
            editText?.inputType = android.text.InputType.TYPE_CLASS_NUMBER
            editText?.setText(value.toInt().toString())
            editText?.hint = customSummary

            dialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener {
                val newMaxValue = editText?.text?.toString()?.toIntOrNull()
                if (newMaxValue != null && (allowOverride || newMaxValue in from..to)) {
                    slider.valueTo = newMaxValue.toFloat()
                    slider.value = newMaxValue.toFloat()
                    dialog.dismiss()
                } else {
                    editText?.error = context.getString(R.string.error_x, if (!allowOverride) "$from - $to" else "")

                }
            }

            dialog.getButton(AlertDialog.BUTTON_NEGATIVE).setOnClickListener {
                dialog.dismiss()
            }
        }
        dialog.setOnDismissListener { dialogOpened = false }
        dialog.show()
    }

    private fun updateSummary() {
        val value = context.getString(R.string.value)
        val entry = getPersistedInt(defaultValue ?: 0)
        val sum = customSummary?.let { "\n\n$it" } ?: ""
        summary = "$value : $entry$sum".trimIndent()
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\prefs\MaterialTextInputPreference.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.prefs

import android.content.Context
import android.widget.EditText
import androidx.appcompat.app.AlertDialog
import androidx.preference.EditTextPreference
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.joaomagdaleno.music_hub.R

class MaterialTextInputPreference(context: Context) : EditTextPreference(context) {

    private var customSummary: CharSequence? = null

    override fun onSetInitialValue(defaultValue: Any?) {
        super.onSetInitialValue(defaultValue)
        customSummary = summary
        updateSummary()
    }


    override fun onClick() {
        val dialog = MaterialAlertDialogBuilder(context)
            .setView(R.layout.item_edit_text)
            .setPositiveButton(R.string.okay, null)
            .setNegativeButton(R.string.cancel, null)
            .setTitle(title)
            .create()

        dialog.setOnShowListener {
            val editText = dialog.findViewById<EditText>(R.id.edit_text)
            editText?.setText(text)
            editText?.hint = customSummary

            dialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener {
                val newText = editText?.text?.toString()
                if (callChangeListener(newText)) {
                    text = newText
                    updateSummary()
                    dialog.dismiss()
                }
            }

            dialog.getButton(AlertDialog.BUTTON_NEGATIVE).setOnClickListener {
                dialog.dismiss()
            }
        }

        dialog.show()
    }

    private fun updateSummary() {
        val value = context.getString(R.string.value)
        val entry = text.takeIf { !it.isNullOrEmpty() } ?: context.getString(R.string.value_not_set)
        val sum = customSummary?.let { "\n\n$it" } ?: ""
        summary = "$value : $entry$sum"
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\prefs\SwitchLongClickPreference.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.prefs

import android.content.Context
import androidx.preference.PreferenceViewHolder
import androidx.preference.SwitchPreferenceCompat

class SwitchLongClickPreference(context: Context) : SwitchPreferenceCompat(context) {
    private var onLongClickListener: (() -> Unit)? = null

    fun setOnLongClickListener(listener: () -> Unit) {
        onLongClickListener = listener
    }

    override fun onBindViewHolder(holder: PreferenceViewHolder) {
        super.onBindViewHolder(holder)

        val listener = onLongClickListener ?: return
        holder.itemView.setOnLongClickListener {
            listener.invoke()
            true
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\prefs\TransitionPreference.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.prefs

import android.content.Context
import androidx.preference.Preference
import androidx.preference.PreferenceViewHolder

class TransitionPreference(
    context: Context
) : Preference(context) {
    override fun onBindViewHolder(holder: PreferenceViewHolder) {
        super.onBindViewHolder(holder)
        holder.itemView.id = key.hashCode()
        holder.itemView.transitionName = key
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\scrolling\ScrollAnimListAdapter.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.scrolling

import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.applyTranslationYAnimation

abstract class ScrollAnimListAdapter<T : Any, VH : ScrollAnimViewHolder>(
    diffCallback: DiffUtil.ItemCallback<T>
) : ListAdapter<T, VH>(diffCallback) {

    override fun onBindViewHolder(holder: VH, position: Int) {
        holder.itemView.applyTranslationYAnimation(scrollY)
    }

    var recyclerView: RecyclerView? = null
    override fun onAttachedToRecyclerView(recyclerView: RecyclerView) {
        this.recyclerView = recyclerView
        recyclerView.addOnScrollListener(scrollListener)
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        recyclerView.removeOnScrollListener(scrollListener)
        this.recyclerView = null
    }

    var scrollY: Int = 0
    val scrollListener = object : RecyclerView.OnScrollListener() {
        override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
            scrollY = dy
            onEachViewHolder { scrollAmount = dy }
        }
    }

    @Suppress("UNCHECKED_CAST")
    fun onEachViewHolder(action: VH.() -> Unit) {
        recyclerView?.let { rv ->
            for (i in 0 until rv.childCount) {
                val holder = rv.getChildViewHolder(rv.getChildAt(i)) as? VH
                if (holder?.bindingAdapter == this) holder.action()
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\scrolling\ScrollAnimLoadStateAdapter.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.scrolling

import androidx.annotation.CallSuper
import androidx.paging.LoadState
import androidx.paging.LoadStateAdapter
import androidx.recyclerview.widget.RecyclerView
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.applyTranslationYAnimation

abstract class ScrollAnimLoadStateAdapter<T: ScrollAnimViewHolder> : LoadStateAdapter<T>() {

    @CallSuper
    override fun onBindViewHolder(holder: T, loadState: LoadState) {
        holder.itemView.applyTranslationYAnimation(scrollY)
    }

    var recyclerView: RecyclerView? = null
    override fun onAttachedToRecyclerView(recyclerView: RecyclerView) {
        this.recyclerView = recyclerView
        recyclerView.addOnScrollListener(scrollListener)
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        recyclerView.removeOnScrollListener(scrollListener)
        this.recyclerView = null
    }

    var scrollY: Int = 0
    val scrollListener = object : RecyclerView.OnScrollListener() {
        override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
            scrollY = dy
            onEachViewHolder { scrollAmount = dy }
        }
    }

    @Suppress("UNCHECKED_CAST")
    fun onEachViewHolder(action: T.() -> Unit) {
        recyclerView?.let { rv ->
            for (i in 0 until rv.childCount) {
                val holder = rv.getChildViewHolder(rv.getChildAt(i)) as? T
                if (holder?.bindingAdapter == this) holder.action()
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\scrolling\ScrollAnimPagingAdapter.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.scrolling

import androidx.paging.PagingDataAdapter
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.RecyclerView
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.applyTranslationYAnimation

abstract class ScrollAnimPagingAdapter<T : Any, VH : ScrollAnimViewHolder>(
    diffCallback: DiffUtil.ItemCallback<T>
) : PagingDataAdapter<T, VH>(diffCallback) {

    override fun onBindViewHolder(holder: VH, position: Int) {
        holder.itemView.applyTranslationYAnimation(scrollY)
    }

    var recyclerView: RecyclerView? = null
    override fun onAttachedToRecyclerView(recyclerView: RecyclerView) {
        this.recyclerView = recyclerView
        recyclerView.addOnScrollListener(scrollListener)
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        recyclerView.removeOnScrollListener(scrollListener)
        this.recyclerView = null
    }

    var scrollY: Int = 0
    val scrollListener = object : RecyclerView.OnScrollListener() {
        override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
            scrollY = dy
            onEachViewHolder { scrollAmount = dy }
        }
    }

    @Suppress("UNCHECKED_CAST")
    fun onEachViewHolder(action: VH.() -> Unit) {
        recyclerView?.let { rv ->
            for (i in 0 until rv.childCount) {
                val holder = rv.getChildViewHolder(rv.getChildAt(i)) as? VH
                if (holder?.bindingAdapter == this) holder.action()
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\scrolling\ScrollAnimRecyclerAdapter.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.scrolling

import androidx.annotation.CallSuper
import androidx.recyclerview.widget.RecyclerView
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.applyTranslationYAnimation

abstract class ScrollAnimRecyclerAdapter<T: ScrollAnimViewHolder> : RecyclerView.Adapter<T>() {

    @CallSuper
    override fun onBindViewHolder(holder: T, position: Int) {
        holder.itemView.applyTranslationYAnimation(scrollY)
    }

    var recyclerView: RecyclerView? = null
    override fun onAttachedToRecyclerView(recyclerView: RecyclerView) {
        this.recyclerView = recyclerView
        recyclerView.addOnScrollListener(scrollListener)
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        recyclerView.removeOnScrollListener(scrollListener)
        this.recyclerView = null
    }

    var scrollY: Int = 0
    val scrollListener = object : RecyclerView.OnScrollListener() {
        override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
            scrollY = dy
            onEachViewHolder { scrollAmount = dy }
        }
    }

    @Suppress("UNCHECKED_CAST")
    fun onEachViewHolder(action: T.() -> Unit) {
        recyclerView?.let { rv ->
            for (i in 0 until rv.childCount) {
                val holder = rv.getChildViewHolder(rv.getChildAt(i)) as? T
                if (holder?.bindingAdapter == this) holder.action()
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\utils\ui\scrolling\ScrollAnimViewHolder.kt ----------
package com.joaomagdaleno.music_hub.utils.ui.scrolling

import android.view.View
import androidx.recyclerview.widget.RecyclerView

abstract class ScrollAnimViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    var scrollAmount: Int = 0
}

