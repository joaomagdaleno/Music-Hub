================================================================================
PROCESS AUDIT: hub_processo_player.txt
DATE: 2026-01-08 15:23:52
FILE COUNT: 50
================================================================================

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\AndroidAutoCallback.kt ----------
package com.joaomagdaleno.music_hub.playback

import android.content.ContentResolver
import android.content.Context
import android.content.res.Resources
import android.net.Uri
import androidx.annotation.CallSuper
import androidx.annotation.OptIn
import androidx.core.net.toUri
import androidx.core.os.bundleOf
import androidx.media3.common.MediaItem
import androidx.media3.common.MediaMetadata
import androidx.media3.common.util.UnstableApi
import androidx.media3.session.LibraryResult
import androidx.media3.session.MediaLibraryService
import androidx.media3.session.MediaLibraryService.MediaLibrarySession
import androidx.media3.session.MediaSession
import androidx.media3.session.SessionError
import com.google.common.collect.ImmutableList
import com.google.common.util.concurrent.Futures
import com.google.common.util.concurrent.ListenableFuture
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.MusicExtension
import com.joaomagdaleno.music_hub.common.clients.AlbumClient
import com.joaomagdaleno.music_hub.common.clients.ArtistClient
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.clients.HomeFeedClient
import com.joaomagdaleno.music_hub.common.clients.LibraryFeedClient
import com.joaomagdaleno.music_hub.common.clients.PlaylistClient
import com.joaomagdaleno.music_hub.common.clients.RadioClient
import com.joaomagdaleno.music_hub.common.clients.SearchFeedClient
import com.joaomagdaleno.music_hub.common.helpers.PagedData
import com.joaomagdaleno.music_hub.common.models.Album
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Feed
import com.joaomagdaleno.music_hub.common.models.ImageHolder
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.common.models.Radio
import com.joaomagdaleno.music_hub.common.models.Shelf
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.isClient
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.extensions.builtin.offline.OfflineExtension
import com.joaomagdaleno.music_hub.utils.CacheUtils.getFromCache
import com.joaomagdaleno.music_hub.utils.CacheUtils.saveToCache
import com.joaomagdaleno.music_hub.utils.CoroutineUtils.await
import com.joaomagdaleno.music_hub.utils.CoroutineUtils.future
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.StateFlow
import java.util.WeakHashMap

@UnstableApi
abstract class AndroidAutoCallback(
    open val app: App,
    open val scope: CoroutineScope,
    open val extensionList: StateFlow<List<MusicExtension>>,
    open val downloadFlow: StateFlow<List<Downloader.Info>>
) : MediaLibrarySession.Callback {

    val context get() = app.context

    @CallSuper
    override fun onGetLibraryRoot(
        session: MediaLibrarySession,
        browser: MediaSession.ControllerInfo,
        params: MediaLibraryService.LibraryParams?
    ): ListenableFuture<LibraryResult<MediaItem>> {
        return Futures.immediateFuture(
            LibraryResult.ofItem(browsableItem(ROOT, "", browsable = false), null)
        )
    }

    @OptIn(UnstableApi::class)
    @CallSuper
    override fun onGetChildren(
        session: MediaLibrarySession,
        browser: MediaSession.ControllerInfo,
        parentId: String,
        page: Int,
        pageSize: Int,
        params: MediaLibraryService.LibraryParams?
    ): ListenableFuture<LibraryResult<ImmutableList<MediaItem>>> = scope.future {
        val extensions = extensionList.value
        if (parentId == ROOT) return@future LibraryResult.ofItemList(
            extensions.map { it.toMediaItem(context) },
            null
        )
        val extId = parentId.substringAfter("$ROOT/").substringBefore("/")
        val extension = extensions.first { it.id == extId }
        val searchQuery = params?.extras?.getString("search_query") ?: ""
        val type = parentId.substringAfter("$extId/").substringBefore("/")
        when (type) {
            ALBUM -> extension.getList<AlbumClient> {
                val id = parentId.substringAfter("$ALBUM/").substringBefore("/")
                val unloaded = itemMap[id] as Album
                getTracks(context, id, page) {
                    val album = loadAlbum(unloaded)
                    album to loadTracks(album)
                }
            }

            PLAYLIST -> extension.getList<PlaylistClient> {
                val id = parentId.substringAfter("$PLAYLIST/").substringBefore("/")
                val unloaded = itemMap[id] as Playlist
                getTracks(context, id, page) {
                    val playlist = loadPlaylist(unloaded)
                    playlist to loadTracks(playlist)
                }
            }

            RADIO -> extension.getList<RadioClient> {
                val id = parentId.substringAfter("$RADIO/").substringBefore("/")
                val radio = itemMap[id] as Radio
                getTracks(context, id, page) {
                    radio to loadTracks(radio)
                }
            }

            ARTIST -> extension.getList<ArtistClient> {
                val id = parentId.substringAfter("$ARTIST/").substringBefore("/")
                val artist = loadArtist(Artist(id, ""))
                loadFeed(artist).toMediaItems(artist.id, context, extId, page)
            }

            LIST -> extension.getList<ExtensionClient> {
                val id = parentId.substringAfter("$LIST/").substringBefore("/")
                getListsItems(context, id, extId)
            }

            SHELF -> extension.getList<ExtensionClient> {
                val id = parentId.substringAfter("$SHELF/").substringBefore("/")
                getShelfItems(context, id, extId, page)
            }

            HOME -> extension.getFeed<HomeFeedClient>(
                context, parentId, HOME, page
            ) { loadHomeFeed() }

            LIBRARY -> extension.getFeed<LibraryFeedClient>(
                context, parentId, LIBRARY, page
            ) { loadLibraryFeed() }

            SEARCH -> extension.getFeed<SearchFeedClient>(
                context, parentId, SEARCH, page
            ) { loadSearchFeed(searchQuery) }

            else -> LibraryResult.ofItemList(
                listOfNotNull(
                    if (extension.isClient<HomeFeedClient>())
                        browsableItem("$ROOT/$extId/$HOME", context.getString(R.string.home))
                    else null,
                    if (extension.isClient<SearchFeedClient>())
                        browsableItem("$ROOT/$extId/$SEARCH", context.getString(R.string.search))
                    else null,
                    if (extension.isClient<LibraryFeedClient>())
                        browsableItem("$ROOT/$extId/$LIBRARY", context.getString(R.string.library))
                    else null,
                ),
                null
            )
        }
    }

    @OptIn(UnstableApi::class)
    @CallSuper
    override fun onGetSearchResult(
        session: MediaLibrarySession,
        browser: MediaSession.ControllerInfo,
        query: String,
        page: Int,
        pageSize: Int,
        params: MediaLibraryService.LibraryParams?
    ): ListenableFuture<LibraryResult<ImmutableList<MediaItem>>> {
        return scope.future {
            val extensions = extensionList.value
            LibraryResult.ofItemList(
                extensions.map { ext ->
                    browsableItem("$ROOT/${ext.id}/$SEARCH", ext.name, query)
                },
                MediaLibraryService.LibraryParams.Builder()
                    .setExtras(bundleOf("search_query" to query))
                    .build()
            )
        }
    }

    @CallSuper
    override fun onSetMediaItems(
        mediaSession: MediaSession,
        controller: MediaSession.ControllerInfo,
        mediaItems: MutableList<MediaItem>,
        startIndex: Int,
        startPositionMs: Long
    ) = scope.future {
        val new = mediaItems.mapNotNull {
            if (it.mediaId.startsWith("auto/")) {
                val id = it.mediaId.substringAfter("auto/")
                val (track, extId, con) =
                    context.getFromCache<Triple<Track, String, EchoMediaItem?>>(id, "auto")
                        ?: return@mapNotNull null
                MediaItemUtils.build(
                    app,
                    downloadFlow.value,
                    MediaState.Unloaded(extId, track),
                    con
                )
            } else it
        }
        val future = super.onSetMediaItems(
            mediaSession, controller, new, startIndex, startPositionMs
        )
        future.await(context)
    }

    companion object {
        private const val ROOT = "root"
        private const val LIBRARY = "library"
        private const val HOME = "home"
        private const val SEARCH = "search"
        private const val FEED = "feed"
        private const val SHELF = "shelf"
        private const val LIST = "list"

        private const val ARTIST = "artist"
        private const val USER = "user"
        private const val ALBUM = "album"
        private const val PLAYLIST = "playlist"
        private const val RADIO = "radio"

        private fun Resources.getUri(int: Int): Uri {
            val scheme = ContentResolver.SCHEME_ANDROID_RESOURCE
            val pkg = getResourcePackageName(int)
            val type = getResourceTypeName(int)
            val name = getResourceEntryName(int)
            val uri = "$scheme://$pkg/$type/$name"
            return uri.toUri()
        }

        private fun ImageHolder.toUri(context: Context) = when (this) {
            is ImageHolder.ResourceUriImageHolder -> uri.toUri()
            is ImageHolder.NetworkRequestImageHolder -> request.url.toUri()
            is ImageHolder.ResourceIdImageHolder -> context.resources.getUri(resId)
            is ImageHolder.HexColorImageHolder -> "".toUri()
        }

        private fun browsableItem(
            id: String,
            title: String,
            subtitle: String? = null,
            browsable: Boolean = true,
            artWorkUri: Uri? = null,
            type: Int = MediaMetadata.MEDIA_TYPE_FOLDER_MIXED
        ) = MediaItem.Builder()
            .setMediaId(id)
            .setMediaMetadata(
                MediaMetadata.Builder()
                    .setIsPlayable(false)
                    .setIsBrowsable(browsable)
                    .setMediaType(type)
                    .setTitle(title)
                    .setSubtitle(subtitle)
                    .setArtworkUri(artWorkUri)
                    .build()
            )
            .build()

        private fun Track.toItem(
            context: Context, extensionId: String, con: EchoMediaItem? = null
        ): MediaItem {
            context.saveToCache(id, Triple(this, extensionId, con), "auto")
            return MediaItem.Builder()
                .setMediaId("auto/$id")
                .setMediaMetadata(
                    MediaMetadata.Builder()
                        .setIsPlayable(true)
                        .setIsBrowsable(false)
                        .setMediaType(MediaMetadata.MEDIA_TYPE_MUSIC)
                        .setTitle(title)
                        .setArtist(subtitleWithE)
                        .setAlbumTitle(album?.title)
                        .setArtworkUri(cover?.toUri(context))
                        .build()
                ).build()
        }

        private suspend fun Extension<*>.toMediaItem(context: Context) = browsableItem(
            "$ROOT/$id", name, context.getString(R.string.extension),
            instance.value().isSuccess,
            metadata.icon?.toUri(context)
        )

        @OptIn(UnstableApi::class)
        val notSupported =
            LibraryResult.ofError<ImmutableList<MediaItem>>(SessionError.ERROR_NOT_SUPPORTED)

        @OptIn(UnstableApi::class)
        val errorIo = LibraryResult.ofError<ImmutableList<MediaItem>>(SessionError.ERROR_IO)

        suspend inline fun <reified C> Extension<*>.getList(
            block: C.() -> List<MediaItem>
        ): LibraryResult<ImmutableList<MediaItem>> = runCatching {
            val client = instance.value().getOrThrow() as? C ?: return@runCatching notSupported
            LibraryResult.ofItemList(
                client.block(),
                MediaLibraryService.LibraryParams.Builder()
                    .setOffline(client is OfflineExtension)
                    .build()
            )
        }.getOrElse {
            it.printStackTrace()
            errorIo
        }


        private val itemMap = WeakHashMap<String, EchoMediaItem>()
        private fun EchoMediaItem.toMediaItem(
            context: Context, extId: String
        ): MediaItem = when (this) {
            is Track -> toItem(context, extId)
            else -> {
                val id = hashCode().toString()
                itemMap[id] = this
                val (page, type) = when (this) {
                    is Artist, is Radio -> USER to MediaMetadata.MEDIA_TYPE_MIXED
                    is Album -> ALBUM to MediaMetadata.MEDIA_TYPE_ALBUM
                    is Playlist -> PLAYLIST to MediaMetadata.MEDIA_TYPE_PLAYLIST
                    else -> throw IllegalStateException("Invalid type")
                }
                browsableItem(
                    "$ROOT/$extId/$page/$id",
                    title,
                    subtitleWithE,
                    true,
                    cover?.toUri(context),
                    type
                )
            }
        }

        private val listsMap = WeakHashMap<String, Shelf.Lists<*>>()
        private fun getListsItems(
            context: Context, id: String, extId: String
        ) = run {
            val shelf = listsMap[id]!!
            when (shelf) {
                is Shelf.Lists.Categories -> shelf.list.map { it.toMediaItem(context, extId) }
                is Shelf.Lists.Items -> shelf.list.map { it.toMediaItem(context, extId) }
                is Shelf.Lists.Tracks -> shelf.list.map { it.toItem(context, extId) }
            } + listOfNotNull(
                if (shelf.more != null) {
                    val moreId = shelf.id
                    feedMap[moreId] = shelf.more
                    browsableItem(
                        "$ROOT/$extId/$FEED/$moreId",
                        context.getString(R.string.more)
                    )
                } else null
            )
        }

        private fun Shelf.toMediaItem(
            context: Context, extId: String
        ): MediaItem = when (this) {
            is Shelf.Category -> {
                val items = feed
                if (items != null) feedMap[id] = items
                browsableItem("$ROOT/$extId/$FEED/$id", title, subtitle, items != null)
            }

            is Shelf.Item -> media.toMediaItem(context, extId)
            is Shelf.Lists<*> -> {
                val id = "${id.hashCode()}"
                listsMap[id] = this
                browsableItem("$ROOT/$extId/$LIST/$id", title, subtitle)
            }
        }


        // THIS PROBABLY BREAKS GOING BACK TBH, NEED TO TEST
        private val shelvesMap = WeakHashMap<String, PagedData<Shelf>>()
        private val continuations = WeakHashMap<Pair<String, Int>, String?>()
        private suspend fun getShelfItems(
            context: Context, id: String, extId: String, page: Int
        ): List<MediaItem> {
            val shelf = shelvesMap[id]!!
            val (list, next) = shelf.loadPage(continuations[id to page])
            continuations[id to page + 1] = next
            return listOfNotNull(
                *list.map { it.toMediaItem(context, extId) }.toTypedArray()
            )
        }

        private val feedMap = WeakHashMap<String, Feed<Shelf>>()
        private suspend fun Feed<Shelf>.toMediaItems(
            id: String, context: Context, extId: String, page: Int
        ): List<MediaItem> {
            val id = "${id.hashCode()}"
            feedMap[id] = this
            //TODO
            return listOf()
        }

        private suspend inline fun <reified T> Extension<*>.getFeed(
            context: Context,
            parentId: String,
            page: String,
            pageNumber: Int,
            getFeed: T.() -> Feed<Shelf>
        ) = getList<T> {
            TODO()
        }

        private val tracksMap = WeakHashMap<String, Pair<EchoMediaItem, PagedData<Track>>>()
        private suspend fun getTracks(
            context: Context,
            id: String,
            page: Int,
            getTracks: suspend () -> Pair<EchoMediaItem, Feed<Track>?>
        ): List<MediaItem> {
            val (item, tracks) = tracksMap.getOrPut(id) {
                val tracks = getTracks().run {
                    first to (second?.run { getPagedData(tabs.firstOrNull()) }?.pagedData
                        ?: PagedData.empty())
                }
                tracksMap[id] = tracks
                tracks
            }
            val (list, next) = tracks.loadPage(continuations[id to page])
            continuations[id to page + 1] = next
            return list.map { it.toItem(context, id, item) }
        }
    }

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\MediaItemUtils.kt ----------
package com.joaomagdaleno.music_hub.playback

import android.content.Context
import android.content.SharedPreferences
import android.net.Uri
import android.os.Bundle
import androidx.annotation.OptIn
import androidx.core.net.toUri
import androidx.core.os.bundleOf
import androidx.media3.common.C
import androidx.media3.common.MediaItem
import androidx.media3.common.MediaMetadata
import androidx.media3.common.MimeTypes
import androidx.media3.common.ThumbRating
import androidx.media3.common.util.UnstableApi
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.ImageHolder
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.playback.PlayerService.Companion.selectServerIndex
import com.joaomagdaleno.music_hub.utils.Serializer.getSerialized
import com.joaomagdaleno.music_hub.utils.Serializer.putSerialized
import com.joaomagdaleno.music_hub.utils.Serializer.toData
import com.joaomagdaleno.music_hub.utils.Serializer.toJson
import kotlinx.serialization.Serializable
import kotlin.io.encoding.Base64
import kotlin.text.Charsets.UTF_8

object MediaItemUtils {

    fun build(
        app: App,
        downloads: List<Downloader.Info>,
        state: MediaState.Unloaded<Track>,
        context: EchoMediaItem?,
    ): MediaItem {
        val item = MediaItem.Builder()
        val metadata = state.toMetaData(bundleOf(), downloads, context, false, app)
        item.setMediaMetadata(metadata)
        item.setMediaId(state.item.id)
        item.setUri(state.item.id)
        return item.build()
    }

    fun buildLoaded(
        app: App,
        downloads: List<Downloader.Info>,
        mediaItem: MediaItem,
        state: MediaState.Loaded<Track>,
    ): MediaItem = with(mediaItem) {
        val item = buildUpon()
        val metadata = state.toMetaData(
            mediaMetadata.extras!!, downloads, context, true, app
        )
        item.setMediaMetadata(metadata)
        return item.build()
    }

    fun buildServer(mediaItem: MediaItem, index: Int): MediaItem = with(mediaItem) {
        val bundle = Bundle().apply {
            putAll(mediaMetadata.extras!!)
            putInt("serverIndex", index)
            putInt("retries", 0)
        }
        buildWithBundle(this, bundle)
    }

    fun buildSource(mediaItem: MediaItem, index: Int) = with(mediaItem) {
        val bundle = Bundle().apply {
            putAll(mediaMetadata.extras!!)
            putInt("sourceIndex", index)
            putInt("retries", 0)
        }
        buildWithBundle(this, bundle)
    }

    fun buildBackground(mediaItem: MediaItem, index: Int): MediaItem = with(mediaItem) {
        val bundle = Bundle().apply {
            putAll(mediaMetadata.extras!!)
            putInt("backgroundIndex", index)
        }
        buildWithBundle(this, bundle)
    }

    fun buildSubtitle(mediaItem: MediaItem, index: Int): MediaItem = with(mediaItem) {
        val bundle = Bundle().apply {
            putAll(mediaMetadata.extras!!)
            putInt("subtitleIndex", index)
        }
        buildWithBundle(this, bundle)
    }


    fun withRetry(item: MediaItem): MediaItem {
        val bundle = Bundle().apply {
            putAll(item.mediaMetadata.extras!!)
            val retries = getInt("retries") + 1
            putBoolean("loaded", false)
            putInt("retries", retries)
        }
        return buildWithBundle(item, bundle)
    }

    private fun buildWithBundle(mediaItem: MediaItem, bundle: Bundle) = run {
        val item = mediaItem.buildUpon()
        val metadata =
            mediaItem.mediaMetadata.buildUpon().setExtras(bundle).setSubtitle(bundle.indexes())
                .build()
        item.setMediaMetadata(metadata)
        item.build()
    }

    @Serializable
    data class Key(val trackId: String, val sourceIndex: Int, val extensionId: String)

    fun String.toKey() = runCatching {
        Base64.decode(this).toString(UTF_8).toData<Key>().getOrThrow()
    }

    fun buildForSource(
        mediaItem: MediaItem, index: Int, source: Streamable.Source?,
    ) = with(mediaItem) {
        val item = buildUpon()
        item.setUri(Base64.encode(Key(track.id, index, extensionId).toJson().toByteArray()))
        when (val decryption = (source as? Streamable.Source.Http)?.decryption) {
            null -> {}
            is Streamable.Decryption.Widevine -> {
                val drmRequest = decryption.license
                val config = MediaItem.DrmConfiguration.Builder(C.WIDEVINE_UUID)
                    .setLicenseUri(drmRequest.url).setMultiSession(decryption.isMultiSession)
                    .setLicenseRequestHeaders(drmRequest.headers).build()
                item.setDrmConfiguration(config)
            }
        }
        item.build()
    }

    fun buildWithBackgroundAndSubtitle(
        mediaItem: MediaItem,
        background: Streamable.Media.Background?,
        subtitle: Streamable.Media.Subtitle?,
    ) = with(mediaItem) {
        val bundle = mediaMetadata.extras!!
        bundle.putSerialized("background", background)
        val item = buildUpon()
        item.setSubtitleConfigurations(
            if (subtitle == null) listOf()
            else listOf(
                MediaItem.SubtitleConfiguration.Builder(subtitle.url.toUri())
                    .setMimeType(subtitle.type.toMimeType())
                    .setSelectionFlags(C.SELECTION_FLAG_DEFAULT).build()
            )
        )
        item.build()
    }


    @OptIn(UnstableApi::class)
    private fun MediaState<Track>.toMetaData(
        bundle: Bundle,
        downloads: List<Downloader.Info>,
        context: EchoMediaItem? = bundle.getSerialized<EchoMediaItem>("context")?.getOrNull(),
        loaded: Boolean = bundle.getBoolean("loaded"),
        app: App,
        serverIndex: Int? = null,
        backgroundIndex: Int? = null,
        subtitleIndex: Int? = null,
    ) = with(item) {
        val isLiked = (this@toMetaData as? MediaState.Loaded<*>)?.isLiked == true
        MediaMetadata.Builder()
            .setTitle(title)
            .setAlbumTitle(album?.title)
            .setAlbumArtist(album?.artists?.joinToString(", ") { it.name })
            .setArtist(artists.joinToString(", ") { it.name })
            .setArtworkUri(cover?.toUriWithJson())
            .setUserRating(
                if (isLiked) ThumbRating(true) else ThumbRating()
            )
            .setExtras(Bundle().apply {
                putAll(bundle)
                putSerialized("unloadedCover", bundle.stateNullable?.item?.cover)
                putSerialized("state", this@toMetaData)
                putSerialized("context", context)
                putBoolean("loaded", loaded)
                putInt("subtitleIndex", subtitleIndex ?: 0.takeIf { subtitles.isNotEmpty() } ?: -1)
                putInt(
                    "backgroundIndex", backgroundIndex ?: 0.takeIf {
                        backgrounds.isNotEmpty() && app.settings.showBackground()
                    } ?: -1
                )
                val downloaded =
                    downloads.filter { it.download.trackId == id }
                        .mapNotNull { it.download.finalFile }
                putInt(
                    "serverIndex",
                    serverIndex ?: selectServerIndex(app, extensionId, servers, downloaded)
                )
                putSerialized("downloaded", downloaded)
            })
            .setSubtitle(bundle.indexes())
            .setMediaType(MediaMetadata.MEDIA_TYPE_MUSIC)
            .setIsPlayable(true)
            .setIsBrowsable(false)
            .build()
    }

    private fun Bundle.indexes() =
        "${getInt("serverIndex")} ${getInt("sourceIndex")} ${getInt("backgroundIndex")} ${getInt("subtitleIndex")}"

    private val Bundle?.stateNullable
        get() = this?.getSerialized<MediaState<Track>>("state")?.getOrNull()
    val Bundle?.state get() = requireNotNull(stateNullable)
    val Bundle?.track get() = state.item
    val Bundle?.isLoaded get() = this?.getBoolean("loaded") ?: false
    val Bundle?.extensionId get() = state.extensionId
    val Bundle?.context get() = this?.getSerialized<EchoMediaItem?>("context")?.getOrNull()
    val Bundle?.serverIndex get() = this?.getInt("serverIndex", -1) ?: -1
    val Bundle?.sourceIndex get() = this?.getInt("sourceIndex", -1) ?: -1
    val Bundle?.backgroundIndex get() = this?.getInt("backgroundIndex", -1) ?: -1
    val Bundle?.subtitleIndex get() = this?.getInt("subtitleIndex", -1) ?: -1
    val Bundle?.background
        get() = this?.getSerialized<Streamable.Media.Background?>("background")?.getOrNull()
    val Bundle?.retries get() = this?.getInt("retries") ?: 0
    val Bundle?.unloadedCover
        get() = this?.getSerialized<ImageHolder?>("unloadedCover")?.getOrNull()
    val Bundle?.downloaded get() = this?.getSerialized<List<String>>("downloaded")?.getOrNull()

    val MediaItem.state get() = mediaMetadata.extras.state
    val MediaItem.track get() = mediaMetadata.extras.track
    val MediaItem.extensionId get() = mediaMetadata.extras.extensionId
    val MediaItem.context get() = mediaMetadata.extras.context
    val MediaItem.isLoaded get() = mediaMetadata.extras.isLoaded
    val MediaItem.serverIndex get() = mediaMetadata.extras.serverIndex
    val MediaItem.sourceIndex get() = mediaMetadata.extras.sourceIndex
    val MediaItem.backgroundIndex get() = mediaMetadata.extras.backgroundIndex
    val MediaItem.subtitleIndex get() = mediaMetadata.extras.subtitleIndex
    val MediaItem.background get() = mediaMetadata.extras.background
    val MediaMetadata.isLiked get() = (userRating as? ThumbRating)?.isThumbsUp == true
    val MediaItem.isLiked get() = mediaMetadata.isLiked
    val MediaItem.retries get() = mediaMetadata.extras.retries
    val MediaItem.unloadedCover get() = mediaMetadata.extras.unloadedCover
    val MediaItem.downloaded get() = mediaMetadata.extras.downloaded

    private fun Streamable.SubtitleType.toMimeType() = when (this) {
        Streamable.SubtitleType.VTT -> MimeTypes.TEXT_VTT
        Streamable.SubtitleType.SRT -> MimeTypes.APPLICATION_SUBRIP
        Streamable.SubtitleType.ASS -> MimeTypes.TEXT_SSA
    }

    private fun ImageHolder.toUriWithJson(): Uri {
        val main = when (this) {
            is ImageHolder.ResourceUriImageHolder -> uri
            is ImageHolder.NetworkRequestImageHolder -> request.url
            is ImageHolder.ResourceIdImageHolder -> "res://$resId"
            is ImageHolder.HexColorImageHolder -> ""
        }.toUri()
        val json = toJson()
        return main.buildUpon().appendQueryParameter("actual_data", json).build()
    }

    const val SHOW_BACKGROUND = "show_background"
    fun SharedPreferences?.showBackground() = this?.getBoolean(SHOW_BACKGROUND, true) ?: true

    fun MediaItem.serverWithDownloads(
        context: Context,
    ) = track.servers + listOfNotNull(
        Streamable.server(
            "DOWNLOADED", Int.MAX_VALUE, context.getString(R.string.downloads)
        ).takeIf { !downloaded.isNullOrEmpty() }
    )
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\PlayerCallback.kt ----------
package com.joaomagdaleno.music_hub.playback

import android.content.Context
import android.content.Intent
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.widget.Toast
import androidx.annotation.OptIn
import androidx.core.graphics.drawable.toBitmap
import androidx.core.graphics.scale
import androidx.core.os.bundleOf
import androidx.media3.common.Player
import androidx.media3.common.Rating
import androidx.media3.common.ThumbRating
import androidx.media3.common.util.UnstableApi
import androidx.media3.session.MediaButtonReceiver
import androidx.media3.session.MediaSession
import androidx.media3.session.MediaSession.MediaItemsWithStartPosition
import androidx.media3.session.SessionCommand
import androidx.media3.session.SessionError
import androidx.media3.session.SessionResult
import androidx.media3.session.SessionResult.RESULT_SUCCESS
import com.google.common.util.concurrent.Futures
import com.google.common.util.concurrent.ListenableFuture
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.clients.AlbumClient
import com.joaomagdaleno.music_hub.common.clients.ArtistClient
import com.joaomagdaleno.music_hub.common.clients.LikeClient
import com.joaomagdaleno.music_hub.common.clients.PlaylistClient
import com.joaomagdaleno.music_hub.common.clients.RadioClient
import com.joaomagdaleno.music_hub.common.clients.TrackClient
import com.joaomagdaleno.music_hub.common.helpers.PagedData
import com.joaomagdaleno.music_hub.common.models.Album
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.pagedDataOfFirst
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.common.models.Radio
import com.joaomagdaleno.music_hub.common.models.Shelf
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.get
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getAs
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtension
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtensionOrThrow
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.extensionId
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.playback.ResumptionUtils.recoverPlaylist
import com.joaomagdaleno.music_hub.playback.ResumptionUtils.recoverRepeat
import com.joaomagdaleno.music_hub.playback.ResumptionUtils.recoverShuffle
import com.joaomagdaleno.music_hub.playback.ResumptionUtils.recoverTracks
import com.joaomagdaleno.music_hub.playback.exceptions.PlayerException
import com.joaomagdaleno.music_hub.playback.listener.PlayerRadio
import com.joaomagdaleno.music_hub.utils.CoroutineUtils.future
import com.joaomagdaleno.music_hub.utils.Serializer.getSerialized
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadDrawable
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext


@OptIn(UnstableApi::class)
class PlayerCallback(
    override val app: App,
    override val scope: CoroutineScope,
    private val throwableFlow: MutableSharedFlow<Throwable>,
    private val extensions: ExtensionLoader,
    private val radioFlow: MutableStateFlow<PlayerState.Radio>,
    override val downloadFlow: StateFlow<List<Downloader.Info>>,
) : AndroidAutoCallback(app, scope, extensions.music, downloadFlow) {

    override fun onConnect(
        session: MediaSession, controller: MediaSession.ControllerInfo,
    ): MediaSession.ConnectionResult {
        val sessionCommands = with(PlayerCommands) {
            MediaSession.ConnectionResult.DEFAULT_SESSION_AND_LIBRARY_COMMANDS.buildUpon()
                .add(likeCommand).add(unlikeCommand).add(repeatCommand).add(repeatOffCommand)
                .add(repeatOneCommand).add(radioCommand).add(sleepTimer)
                .add(playCommand).add(addToQueueCommand).add(addToNextCommand)
                .add(resumeCommand).add(imageCommand)
                .build()
        }
        return MediaSession.ConnectionResult.AcceptedResultBuilder(session)
            .setAvailableSessionCommands(sessionCommands).build()
    }

    override fun onCustomCommand(
        session: MediaSession,
        controller: MediaSession.ControllerInfo,
        customCommand: SessionCommand,
        args: Bundle,
    ): ListenableFuture<SessionResult> = with(PlayerCommands) {
        val player = session.player
        when (customCommand) {
            likeCommand -> onSetRating(session, controller, ThumbRating(true))
            unlikeCommand -> onSetRating(session, controller, ThumbRating())
            repeatOffCommand -> setRepeat(player, Player.REPEAT_MODE_OFF)
            repeatOneCommand -> setRepeat(player, Player.REPEAT_MODE_ONE)
            repeatCommand -> setRepeat(player, Player.REPEAT_MODE_ALL)
            playCommand -> playItem(player, args)
            addToQueueCommand -> addToQueue(player, args)
            addToNextCommand -> addToNext(player, args)
            radioCommand -> radio(player, args)
            sleepTimer -> onSleepTimer(player, args.getLong("ms"))
            resumeCommand -> resume(player, args.getBoolean("cleared", true))
            imageCommand -> getImage(player)
            else -> super.onCustomCommand(session, controller, customCommand, args)
        }
    }

    private fun getImage(player: Player) = scope.future {
        val item = player.with { currentMediaItem }
            ?: context.recoverPlaylist(app, downloadFlow.value, false).run { first.getOrNull(second) }
            ?: return@future SessionResult(SessionError.ERROR_UNKNOWN)
        val image = item.track.cover.loadDrawable(context)?.toScaledBitmap(720)
        SessionResult(RESULT_SUCCESS, Bundle().apply { putParcelable("image", image) })
    }

    private fun Drawable.toScaledBitmap(width: Int) = toBitmap().let { bmp ->
        val ratio = width.toFloat() / bmp.width
        val height = (bmp.height * ratio).toInt()
        bmp.scale(width, height)
    }

    private fun resume(player: Player, withClear: Boolean) = scope.future {
        withContext(Dispatchers.Main) {
            player.shuffleModeEnabled = context.recoverShuffle() == true
            player.repeatMode = context.recoverRepeat() ?: Player.REPEAT_MODE_OFF
        }
        val (items, index, pos) = context.recoverPlaylist(app,downloadFlow.value, withClear)
        withContext(Dispatchers.Main) {
            player.setMediaItems(items, index, pos)
            player.prepare()
        }
        SessionResult(RESULT_SUCCESS)
    }

    private var timerJob: Job? = null
    private fun onSleepTimer(player: Player, ms: Long): ListenableFuture<SessionResult> {
        timerJob?.cancel()
        val time = when (ms) {
            0L -> return Futures.immediateFuture(SessionResult(RESULT_SUCCESS))
            Long.MAX_VALUE -> player.run { duration - currentPosition }
            else -> ms
        }

        timerJob = scope.launch {
            delay(time)
            player.with { pause() }
        }
        return Futures.immediateFuture(SessionResult(RESULT_SUCCESS))
    }

    private fun setRepeat(player: Player, repeat: Int) = run {
        player.repeatMode = repeat
        Futures.immediateFuture(SessionResult(RESULT_SUCCESS))
    }


    @OptIn(UnstableApi::class)
    private fun radio(player: Player, args: Bundle) = scope.future {
        val error = SessionResult(SessionError.ERROR_UNKNOWN)
        val extId = args.getString("extId") ?: return@future error
        val item = args.getSerialized<EchoMediaItem>("item")?.getOrNull() ?: return@future error
        val itemLoaded = args.getBoolean("loaded", false)
        val extension = extensions.music.getExtension(extId) ?: return@future error
        val newItem = if (itemLoaded) item else loadItem(extension, item)
        radioFlow.value = PlayerState.Radio.Loading
        val loaded = PlayerRadio.start(
            throwableFlow, extension, newItem, null
        )
        if (loaded == null) return@future error
        player.with {
            clearMediaItems()
            shuffleModeEnabled = false
        }
        PlayerRadio.play(player, downloadFlow, app, radioFlow, loaded)
        player.with { play() }
        SessionResult(RESULT_SUCCESS)
    }

    private suspend fun loadItem(
        extension: Extension<*>, item: EchoMediaItem,
    ) = when (item) {
        is Track -> extension.getAs<TrackClient, EchoMediaItem> { loadTrack(item, false) }
        is Album -> extension.getAs<AlbumClient, EchoMediaItem> { loadAlbum(item) }
        is Playlist -> extension.getAs<PlaylistClient, EchoMediaItem> { loadPlaylist(item) }
        is Artist -> extension.getAs<ArtistClient, EchoMediaItem> { loadArtist(item) }
        is Radio -> throw IllegalStateException()
    }.getOrThrow()

    private suspend fun listTracks(
        extension: Extension<*>, item: EchoMediaItem, loaded: Boolean,
    ) = when (item) {
        is Album -> extension.getAs<AlbumClient, PagedData<Track>> {
            val album = if (!loaded) loadAlbum(item) else item
            loadTracks(album)?.pagedDataOfFirst()
                ?: PagedData.empty()
        }

        is Playlist -> extension.getAs<PlaylistClient, PagedData<Track>> {
            val playlist = if (!loaded) loadPlaylist(item) else item
            loadTracks(playlist).pagedDataOfFirst()
        }

        is Radio -> extension.getAs<RadioClient, PagedData<Track>> {
            val radio = if (!loaded) loadRadio(item) else item
            loadTracks(radio).pagedDataOfFirst()
        }

        is Artist -> extension.getAs<ArtistClient, PagedData<Track>> {
            val artist = if (!loaded) loadArtist(item) else item
            loadFeed(artist).pagedDataOfFirst().toTracks()
        }

        is Track -> Result.success(PagedData.Single { listOf(item) })
    }


    private fun playItem(player: Player, args: Bundle) = scope.future {
        val error = SessionResult(SessionError.ERROR_UNKNOWN)
        val extId = args.getString("extId") ?: return@future error
        val item = args.getSerialized<EchoMediaItem>("item")?.getOrNull() ?: return@future error
        val loaded = args.getBoolean("loaded", false)
        val shuffle = args.getBoolean("shuffle", false)
        val extension = extensions.music.getExtension(extId) ?: return@future error
        when (item) {
            is Track -> {
                val mediaItem = MediaItemUtils.build(
                    app, downloadFlow.value, MediaState.Unloaded(extId, item), null
                )
                player.with {
                    setMediaItem(mediaItem)
                    prepare()
                    seekTo(item.playedDuration ?: 0)
                    play()
                }
            }

            else -> {
                val tracks = listTracks(extension, item, loaded).getOrElse {
                    throwableFlow.emit(it)
                    return@future error
                }

                val result = if (shuffle) extension.get { tracks.loadAll() }
                else runCatching {
                    val (list, continuation) = extension.get { tracks.loadPage(null) }.getOrThrow()
                    if (continuation != null) scope.launch {
                        val all = extension.get { tracks.loadAll() }.getOrElse {
                            throwableFlow.emit(it)
                            return@launch
                        }.drop(list.size).map {
                            MediaItemUtils.build(
                                app, downloadFlow.value, MediaState.Unloaded(extId, it), item
                            )
                        }
                        player.with { addMediaItems(list.size, all) }
                    }
                    list
                }
                val list = result.getOrElse {
                    throwableFlow.emit(it)
                    return@future error
                }
                player.with {
                    setMediaItems(list.map {
                        MediaItemUtils.build(
                            app, downloadFlow.value, MediaState.Unloaded(extId, it), item
                        )
                    })
                    shuffleModeEnabled = shuffle
                    seekTo(0, list.firstOrNull()?.playedDuration ?: 0)
                    play()
                }
            }
        }
        SessionResult(RESULT_SUCCESS)
    }

    private suspend fun <T> Player.with(block: suspend Player.() -> T): T =
        withContext(Dispatchers.Main) { block() }

    private suspend fun <T : Any> PagedData<T>.load(
        pages: Int = 5,
    ) = runCatching {
        val list = mutableListOf<T>()
        var page = loadPage(null)
        list.addAll(page.data)
        var count = 0
        while (page.continuation != null && count < pages) {
            page = loadPage(page.continuation)
            list.addAll(page.data)
            count++
        }
        list
    }

    private fun addToQueue(player: Player, args: Bundle) = scope.future {
        val error = SessionResult(SessionError.ERROR_UNKNOWN)
        val extId = args.getString("extId") ?: return@future error
        val item = args.getSerialized<EchoMediaItem>("item")?.getOrNull() ?: return@future error
        val loaded = args.getBoolean("loaded", false)
        val extension = extensions.music.getExtension(extId) ?: return@future error
        val tracks = listTracks(extension, item, loaded).getOrElse {
            throwableFlow.emit(it)
            return@future error
        }.load().getOrElse {
            throwableFlow.emit(it)
            return@future error
        }
        if (tracks.isEmpty()) return@future error
        val mediaItems = tracks.map { track ->
            MediaItemUtils.build(
                app,
                downloadFlow.value,
                MediaState.Unloaded(extId, track),
                null
            )
        }
        player.with {
            addMediaItems(mediaItems)
            prepare()
        }
        SessionResult(RESULT_SUCCESS)
    }

    private var next = 0
    private var nextJob: Job? = null
    private fun addToNext(player: Player, args: Bundle) = scope.future {
        val error = SessionResult(SessionError.ERROR_UNKNOWN)
        val extId = args.getString("extId") ?: return@future error
        val item = args.getSerialized<EchoMediaItem>("item")?.getOrNull() ?: return@future error
        val loaded = args.getBoolean("loaded", false)
        val extension = extensions.music.getExtension(extId) ?: return@future error
        nextJob?.cancel()
        val tracks = listTracks(extension, item, loaded).getOrElse {
            throwableFlow.emit(it)
            return@future error
        }.load().getOrElse {
            throwableFlow.emit(it)
            return@future error
        }
        if (tracks.isEmpty()) return@future error
        val mediaItems = tracks.map { track ->
            MediaItemUtils.build(
                app,
                downloadFlow.value,
                MediaState.Unloaded(extId, track),
                null
            )
        }
        player.with {
            if (mediaItemCount == 0) playWhenReady = true
            addMediaItems(currentMediaItemIndex + 1 + next, mediaItems)
            prepare()
        }
        next += mediaItems.size
        nextJob = scope.launch {
            delay(5000)
            next = 0
        }
        SessionResult(RESULT_SUCCESS)
    }

    override fun onSetRating(
        session: MediaSession, controller: MediaSession.ControllerInfo, rating: Rating,
    ): ListenableFuture<SessionResult> {
        return if (rating !is ThumbRating) super.onSetRating(session, controller, rating)
        else scope.future {
            val item = session.player.with { currentMediaItem }
                ?: return@future SessionResult(SessionError.ERROR_UNKNOWN)
            val track = item.track
            runCatching {
                val extension = extensions.music.getExtensionOrThrow(item.extensionId)
                extension.getAs<LikeClient, Unit> {
                    likeItem(track, rating.isThumbsUp)
                }
            }.getOrElse {
                throwableFlow.emit(PlayerException(item, it))
                return@future SessionResult(SessionError.ERROR_UNKNOWN)
            }
            val liked = rating.isThumbsUp
            val newItem = item.run {
                buildUpon().setMediaMetadata(
                    mediaMetadata.buildUpon().setUserRating(ThumbRating(liked)).build()
                )
            }.build()
            session.player.with {
                replaceMediaItem(currentMediaItemIndex, newItem)
            }
            SessionResult(RESULT_SUCCESS, bundleOf("liked" to liked))
        }
    }

    override fun onPlaybackResumption(
        mediaSession: MediaSession,
        controller: MediaSession.ControllerInfo,
    ) = scope.future {
        withContext(Dispatchers.Main) {
            mediaSession.player.shuffleModeEnabled = context.recoverShuffle() ?: false
            mediaSession.player.repeatMode = context.recoverRepeat() ?: Player.REPEAT_MODE_OFF
        }
        val (items, index, pos) = context.recoverPlaylist(app, downloadFlow.value)
        MediaItemsWithStartPosition(items, index, pos)
    }

    class ButtonReceiver : MediaButtonReceiver() {
        override fun shouldStartForegroundService(context: Context, intent: Intent): Boolean {
            val isEmpty = context.recoverTracks().isNullOrEmpty()
            if (isEmpty) Toast.makeText(
                context,
                context.getString(R.string.no_last_played_track_found),
                Toast.LENGTH_SHORT
            ).show()
            return !isEmpty
        }
    }

    companion object {
        fun PagedData<Shelf>.toTracks() = map {
            it.getOrThrow().mapNotNull { shelf ->
                when (shelf) {
                    is Shelf.Category -> null
                    is Shelf.Item -> listOfNotNull(shelf.media as? Track)
                    is Shelf.Lists.Categories -> null
                    is Shelf.Lists.Items -> shelf.list.filterIsInstance<Track>()
                    is Shelf.Lists.Tracks -> shelf.list
                }
            }.flatten()
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\PlayerCommands.kt ----------
package com.joaomagdaleno.music_hub.playback

import android.content.Context
import android.os.Bundle
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.session.CommandButton
import androidx.media3.session.SessionCommand
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.isLiked

object PlayerCommands {
    val likeCommand = SessionCommand("liked", Bundle.EMPTY)
    val unlikeCommand = SessionCommand("unliked", Bundle.EMPTY)
    val repeatCommand = SessionCommand("repeat", Bundle.EMPTY)
    val repeatOffCommand = SessionCommand("repeat_off", Bundle.EMPTY)
    val repeatOneCommand = SessionCommand("repeat_one", Bundle.EMPTY)
    val playCommand = SessionCommand("play", Bundle.EMPTY)
    val addToQueueCommand = SessionCommand("add_to_queue", Bundle.EMPTY)
    val addToNextCommand = SessionCommand("add_to_next", Bundle.EMPTY)
    val radioCommand = SessionCommand("radio", Bundle.EMPTY)
    val sleepTimer = SessionCommand("sleep_timer", Bundle.EMPTY)
    val resumeCommand = SessionCommand("resume", Bundle.EMPTY)
    val imageCommand = SessionCommand("image", Bundle.EMPTY)

    fun getLikeButton(context: Context, item: MediaItem) = run {
        val builder = CommandButton.Builder()
        if (!item.isLiked) builder
            .setDisplayName(context.getString(R.string.like))
            .setIconResId(R.drawable.ic_favorite_20dp)
            .setSessionCommand(likeCommand)
        else builder
            .setDisplayName(context.getString(R.string.unlike))
            .setIconResId(R.drawable.ic_favorite_filled_20dp)
            .setSessionCommand(unlikeCommand)
        builder.build()
    }

    fun getRepeatButton(context: Context, repeat: Int) = run {
        val builder = CommandButton.Builder()
        when (repeat) {
            Player.REPEAT_MODE_ONE -> builder
                .setDisplayName(context.getString(R.string.repeat_one))
                .setIconResId(R.drawable.ic_repeat_one_20dp)
                .setSessionCommand(repeatOffCommand)

            Player.REPEAT_MODE_OFF -> builder
                .setDisplayName(context.getString(R.string.repeat_off))
                .setIconResId(R.drawable.ic_repeat_20dp)
                .setSessionCommand(repeatCommand)

            else -> builder
                .setDisplayName(context.getString(R.string.repeat_all))
                .setIconResId(R.drawable.ic_repeat_on_20dp)
                .setSessionCommand(repeatOneCommand)
        }
        builder.build()
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\PlayerService.kt ----------
package com.joaomagdaleno.music_hub.playback

import android.app.Activity
import android.app.Application
import android.app.PendingIntent
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import androidx.annotation.OptIn
import androidx.media3.common.AudioAttributes
import androidx.media3.common.C
import androidx.media3.common.MediaItem
import androidx.media3.common.TrackSelectionParameters
import androidx.media3.common.TrackSelectionParameters.AudioOffloadPreferences.AUDIO_OFFLOAD_MODE_DISABLED
import androidx.media3.common.TrackSelectionParameters.AudioOffloadPreferences.AUDIO_OFFLOAD_MODE_ENABLED
import androidx.media3.common.util.UnstableApi
import androidx.media3.database.StandaloneDatabaseProvider
import androidx.media3.datasource.cache.LeastRecentlyUsedCacheEvictor
import androidx.media3.datasource.cache.SimpleCache
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.session.DefaultMediaNotificationProvider
import androidx.media3.session.MediaController
import androidx.media3.session.MediaLibraryService
import androidx.media3.session.MediaSession
import androidx.media3.session.SessionToken
import com.joaomagdaleno.music_hub.MainActivity.Companion.getMainActivity
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.extensionPrefId
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.prefs
import com.joaomagdaleno.music_hub.playback.listener.AudioFocusListener
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener
import com.joaomagdaleno.music_hub.playback.listener.MediaSessionServiceListener
import com.joaomagdaleno.music_hub.playback.listener.PlayerEventListener
import com.joaomagdaleno.music_hub.playback.listener.PlayerRadio
import com.joaomagdaleno.music_hub.playback.listener.TrackingListener
import com.joaomagdaleno.music_hub.playback.renderer.PlayerBitmapLoader
import com.joaomagdaleno.music_hub.playback.renderer.RenderersFactory
import com.joaomagdaleno.music_hub.playback.source.StreamableMediaSource
import com.joaomagdaleno.music_hub.utils.ContextUtils.listenFuture
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.plus
import org.koin.android.ext.android.inject
import java.io.File

class PlayerService : MediaLibraryService() {

    private val extensionLoader by inject<ExtensionLoader>()
    private val extensions by lazy { extensionLoader }
    private val exoPlayer by lazy { createExoplayer() }

    private var mediaSession: MediaLibrarySession? = null
    override fun onGetSession(controllerInfo: MediaSession.ControllerInfo) = mediaSession

    private val app by inject<App>()
    private val state by inject<PlayerState>()
    private val scope = CoroutineScope(Dispatchers.IO) + CoroutineName("PlayerService")

    @OptIn(UnstableApi::class)
    private val listener = SharedPreferences.OnSharedPreferenceChangeListener { prefs, key ->
        when (key) {
            SKIP_SILENCE -> exoPlayer.skipSilenceEnabled = prefs.getBoolean(key, true)
            MORE_BRAIN_CAPACITY -> exoPlayer.trackSelectionParameters =
                exoPlayer.trackSelectionParameters
                    .buildUpon()
                    .setAudioOffloadPreferences(offloadPreferences(prefs.getBoolean(key, false)))
                    .build()
        }
    }
    private val effects by lazy { EffectsListener(exoPlayer, this, state.session) }

    private val downloader by inject<Downloader>()
    private val downloadFlow by lazy { downloader.flow }

    @OptIn(UnstableApi::class)
    override fun onCreate() {
        super.onCreate()
        setListener(MediaSessionServiceListener(this, getPendingIntent(this)))

        val player = ShufflePlayer(exoPlayer)
        scope.launch(Dispatchers.Main) {
            mediaChangeFlow.collect { (o, n) -> player.onMediaItemChanged(o, n) }
        }

        val callback = PlayerCallback(
            app, scope, app.throwFlow, extensions, state.radio, downloadFlow
        )

        val session = MediaLibrarySession.Builder(this, player, callback)
            .setBitmapLoader(PlayerBitmapLoader(this, scope))
            .setSessionActivity(getPendingIntent(this))
            .build()

        player.addListener(AudioFocusListener(this, player))
        player.addListener(
            PlayerEventListener(this, scope, session, state.current, extensions, app.throwFlow)
        )
        player.addListener(
            PlayerRadio(
                app, scope, player, app.throwFlow, state.radio, extensions.music, downloadFlow
            )
        )
        player.addListener(
            TrackingListener(player, scope, extensions, state.current, app.throwFlow)
        )
        player.addListener(effects)
        app.settings.registerOnSharedPreferenceChangeListener(listener)

        val notificationProvider = DefaultMediaNotificationProvider.Builder(this)
            .setChannelName(R.string.app_name)
            .build()
        notificationProvider.setSmallIcon(R.drawable.ic_mono)
        setMediaNotificationProvider(notificationProvider)

        mediaSession = session
    }

    override fun onDestroy() {
        mediaSession?.run {
            player.release()
            release()
            mediaSession = null
        }
        super.onDestroy()
    }

    private val cache by inject<SimpleCache>()

    private val mediaChangeFlow = MutableSharedFlow<Pair<MediaItem, MediaItem>>()

    @OptIn(UnstableApi::class)
    private fun offloadPreferences(moreBrainCapacity: Boolean) =
        TrackSelectionParameters.AudioOffloadPreferences.Builder()
            .setAudioOffloadMode(
                if (moreBrainCapacity) AUDIO_OFFLOAD_MODE_DISABLED else AUDIO_OFFLOAD_MODE_ENABLED
            ).setIsGaplessSupportRequired(true)
            .setIsSpeedChangeSupportRequired(true)
            .build()

    @OptIn(UnstableApi::class)
    private fun createExoplayer() = run {
        val audioAttributes = AudioAttributes.Builder()
            .setUsage(C.USAGE_MEDIA)
            .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)
            .build()

        val audioOffloadPreferences =
            offloadPreferences(app.settings.getBoolean(MORE_BRAIN_CAPACITY, false))

        val factory = StreamableMediaSource.Factory(
            app, scope, state, extensions, cache, downloadFlow, mediaChangeFlow
        )

        ExoPlayer.Builder(this, factory)
            .setRenderersFactory(RenderersFactory(this))
            .setHandleAudioBecomingNoisy(true)
            .setWakeMode(C.WAKE_MODE_NETWORK)
            .setAudioAttributes(audioAttributes, true)
            .build()
            .also {
                it.trackSelectionParameters = it.trackSelectionParameters
                    .buildUpon()
                    .setAudioOffloadPreferences(audioOffloadPreferences)
                    .build()
                it.preloadConfiguration = ExoPlayer.PreloadConfiguration(C.TIME_UNSET)
                it.skipSilenceEnabled = app.settings.getBoolean(SKIP_SILENCE, true)
            }
    }


    override fun onTaskRemoved(rootIntent: Intent?) {
        val stopPlayer = app.settings.getBoolean(CLOSE_PLAYER, false)
        val player = mediaSession?.player ?: return stopSelf()
        if (stopPlayer || !player.isPlaying) stopSelf()
    }

    companion object {
        const val MORE_BRAIN_CAPACITY = "offload"
        const val CLOSE_PLAYER = "close_player"
        const val SKIP_SILENCE = "skip_silence"

        const val CACHE_SIZE = "cache_size"

        @OptIn(UnstableApi::class)
        fun getCache(
            app: Application,
            settings: SharedPreferences,
        ): SimpleCache {
            val databaseProvider = StandaloneDatabaseProvider(app)
            val cacheSize = settings.getInt(CACHE_SIZE, 250)
            return SimpleCache(
                File(app.cacheDir, "exo-player"),
                LeastRecentlyUsedCacheEvictor(cacheSize * 1024 * 1024L),
                databaseProvider
            )
        }

        const val STREAM_QUALITY = "stream_quality"
        const val UNMETERED_STREAM_QUALITY = "unmetered_stream_quality"
        val streamQualities = arrayOf("highest", "medium", "lowest")

        fun selectServerIndex(
            app: App,
            extensionId: String,
            streamables: List<Streamable>,
            downloaded: List<String>,
        ) = if (downloaded.isNotEmpty()) streamables.size
        else if (streamables.isNotEmpty()) {
            val streamable = streamables.select(app, extensionId) { it.quality }
            streamables.indexOf(streamable)
        } else -1

        private fun <E> List<E>.select(
            app: App,
            settings: SharedPreferences,
            quality: (E) -> Int,
            default: String = streamQualities[1],
        ): E? {
            val unmetered = if (app.isUnmetered) selectQuality(
                settings.getString(UNMETERED_STREAM_QUALITY, "off"),
                quality
            ) else null
            return unmetered ?: selectQuality(
                settings.getString(STREAM_QUALITY, default),
                quality
            )
        }

        private fun <E> List<E>.selectQuality(final: String?, quality: (E) -> Int): E? {
            return when (final) {
                streamQualities[0] -> maxBy { quality(it) }
                streamQualities[1] -> sortedBy { quality(it) }[size / 2]
                streamQualities[2] -> minBy { quality(it) }
                else -> null
            }
        }


        fun <T> List<T>.select(
            app: App, extensionId: String, quality: (T) -> Int,
        ): T {
            val extSettings =
                extensionPrefId(ExtensionType.MUSIC.name, extensionId).prefs(app.context)
            return select(app, extSettings, quality, "off")
                ?: select(app, app.settings, quality)
                ?: first()
        }

        fun getController(
            context: Application,
            block: (MediaController) -> Unit,
        ): () -> Unit {
            val sessionToken =
                SessionToken(context, ComponentName(context, PlayerService::class.java))
            val playerFuture = MediaController.Builder(context, sessionToken).buildAsync()
            context.listenFuture(playerFuture) { result ->
                val controller = result.getOrElse {
                    return@listenFuture it.printStackTrace()
                }
                block(controller)
            }
            return { MediaController.releaseFuture(playerFuture) }
        }

        fun getPendingIntent(context: Context): PendingIntent = PendingIntent.getActivity(
            context,
            0,
            Intent(context, MainActivityOpener::class.java),
            PendingIntent.FLAG_IMMUTABLE,
        )
    }

    class MainActivityOpener : Activity() {
        override fun onStart() {
            super.onStart()
            finish()
            startActivity(Intent(this, getMainActivity()).apply {
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                putExtra("fromNotification", true)
            })
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\PlayerState.kt ----------
package com.joaomagdaleno.music_hub.playback

import androidx.media3.common.MediaItem
import com.joaomagdaleno.music_hub.common.helpers.Page
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.context
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import java.util.WeakHashMap

data class PlayerState(
    val current: MutableStateFlow<Current?> = MutableStateFlow(null),
    val radio: MutableStateFlow<Radio> = MutableStateFlow(Radio.Empty),
    val session: MutableStateFlow<Int> = MutableStateFlow(0)
) {

    val servers: WeakHashMap<String, Result<Streamable.Media.Server>> = WeakHashMap()
    val serverChanged = MutableSharedFlow<Unit>()

    data class Current(
        val index: Int,
        val mediaItem: MediaItem,
        val isLoaded: Boolean,
        val isPlaying: Boolean,
    ) {

        val context by lazy { mediaItem.context }
        val track by lazy { mediaItem.track }
        fun isPlaying(id: String?): Boolean {
            val same = mediaItem.mediaId == id
                    || context?.id == id
                    || track.album?.id == id
                    || track.artists.any { it.id == id }
            return isPlaying && same
        }

        companion object {
            fun Current?.isPlaying(id: String?): Boolean = this?.isPlaying(id) ?: false
        }
    }

    sealed class Radio {
        data object Empty : Radio()
        data object Loading : Radio()
        data class Loaded(
            val clientId: String,
            val context: EchoMediaItem,
            val cont: String?,
            val tracks: suspend (String?) -> Page<Track>?
        ) : Radio()
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\ResumptionUtils.kt ----------
package com.joaomagdaleno.music_hub.playback

import android.content.Context
import androidx.media3.common.C
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.context
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.extensionId
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.utils.CacheUtils.getFromCache
import com.joaomagdaleno.music_hub.utils.CacheUtils.saveToCache
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

object ResumptionUtils {

    private const val CLEARED = "cleared"
    private const val FOLDER = "queue"
    private const val TRACKS = "queue_tracks"
    private const val CONTEXTS = "queue_contexts"
    private const val EXTENSIONS = "queue_extensions"
    private const val INDEX = "queue_index"
    private const val POSITION = "position"
    private const val SHUFFLE = "shuffle"
    private const val REPEAT = "repeat"

    private fun Player.mediaItems() = (0 until mediaItemCount).map { getMediaItemAt(it) }
    fun saveIndex(context: Context, index: Int) {
        context.saveToCache(INDEX, index, FOLDER)
    }

    suspend fun saveQueue(context: Context, player: Player) = withContext(Dispatchers.Main) {
        val list = player.mediaItems()
        context.saveToCache(CLEARED, list.isEmpty())
        if (list.isEmpty()) return@withContext
        val currentIndex = player.currentMediaItemIndex
        withContext(Dispatchers.IO) {
            val extensionIds = list.map { it.extensionId }
            val tracks = list.map { it.track }
            val contexts = list.map { it.context }
            context.saveToCache(INDEX, currentIndex, FOLDER)
            context.saveToCache(EXTENSIONS, extensionIds, FOLDER)
            context.saveToCache(TRACKS, tracks, FOLDER)
            context.saveToCache(CONTEXTS, contexts, FOLDER)
        }
    }

    fun saveCurrentPos(context: Context, position: Long) {
        context.saveToCache(POSITION, position, FOLDER)
    }

    fun Context.recoverTracks(withClear: Boolean = false): List<Pair<MediaState.Unloaded<Track>, EchoMediaItem?>>? {
        if (withClear && getFromCache<Boolean>(CLEARED) != false) return null
        val tracks = getFromCache<List<Track>>(TRACKS, FOLDER)
        val extensionIds = getFromCache<List<String>>(EXTENSIONS, FOLDER)
        val contexts = getFromCache<List<EchoMediaItem>>(CONTEXTS, FOLDER)
        return tracks?.mapIndexedNotNull { index, track ->
            val extensionId = extensionIds?.getOrNull(index) ?: return@mapIndexedNotNull null
            val item = contexts?.getOrNull(index)
            MediaState.Unloaded(extensionId, track) to item
        }
    }

    private fun Context.recoverQueue(
        app: App,
        downloads: List<Downloader.Info>,
        withClear: Boolean = false
    ): List<MediaItem>? {
        val tracks = recoverTracks(withClear) ?: return null
        return tracks.map { (state, item) ->
            MediaItemUtils.build(app, downloads, state, item)
        }
    }

    fun Context.recoverIndex() = getFromCache<Int>(INDEX, FOLDER)
    private fun Context.recoverPosition() = getFromCache<Long>(POSITION, FOLDER)


    fun Context.recoverShuffle() = getFromCache<Boolean>(SHUFFLE, FOLDER)
    fun saveShuffle(context: Context, shuffle: Boolean) {
        context.saveToCache(SHUFFLE, shuffle, FOLDER)
    }

    fun Context.recoverRepeat() = getFromCache<Int>(REPEAT, FOLDER)
    fun saveRepeat(context: Context, repeat: Int) {
        context.saveToCache(REPEAT, repeat, FOLDER)
    }

    fun Context.recoverPlaylist(
        app: App,
        downloads: List<Downloader.Info>,
        withClear: Boolean = false
    ): Triple<List<MediaItem>, Int, Long> {
        val items = recoverQueue(app, downloads, withClear) ?: emptyList()
        val index = recoverIndex() ?: C.INDEX_UNSET
        val position = recoverPosition() ?: -1L
        return Triple(items, index, position)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\ShufflePlayer.kt ----------
package com.joaomagdaleno.music_hub.playback

import androidx.annotation.OptIn
import androidx.media3.common.ForwardingPlayer
import androidx.media3.common.MediaItem
import androidx.media3.common.util.UnstableApi
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.exoplayer.source.ShuffleOrder

@Suppress("unused")
@OptIn(UnstableApi::class)
class ShufflePlayer(
    private val player: ExoPlayer,
) : ForwardingPlayer(player) {

    init {
        player.setShuffleOrder(ShuffleOrder.UnshuffledShuffleOrder(0))
    }

    private fun getQueue() = (0 until mediaItemCount).map { player.getMediaItemAt(it) }

    private var isShuffled = false
    private var original = getQueue()

    override fun setShuffleModeEnabled(enabled: Boolean) {
        if (enabled) original = getQueue()
        isShuffled = enabled
        changeQueue(if (enabled) original.shuffled() else original)
        player.shuffleModeEnabled = enabled
    }

    override fun hasNextMediaItem(): Boolean {
        return currentMediaItemIndex < mediaItemCount - 1
    }

    @Suppress("UNUSED_PARAMETER")
    private fun log(name: String) {
//        println(name)
//        println("$isShuffled list ${original.size}: ${original.map { it.mediaMetadata.title }}")
//        println("player ${mediaItemCount}: ${getQueue().map { it.mediaMetadata.title }}")
    }

    private fun changeQueue(list: List<MediaItem>) {
        log("Change queue")
        if (list.size <= 1) return
        val currentMediaItem = list.first { it.mediaId == currentMediaItem?.mediaId }
        val index = list.indexOf(currentMediaItem)
        val before = list.take(index) - currentMediaItem
        val after = list.takeLast(list.size - index) - currentMediaItem
        if (currentMediaItemIndex > 0) player.removeMediaItems(0, currentMediaItemIndex)
        player.addMediaItems(0, before)
        player.removeMediaItems(currentMediaItemIndex + 1, mediaItemCount)
        player.addMediaItems(currentMediaItemIndex + 1, after)
    }

    fun onMediaItemChanged(old: MediaItem, new: MediaItem) {
        original = original.toMutableList().apply {
            val index = indexOf(old).takeIf { it != -1 } ?: return
            set(index, new)
        }
        log("Change media item")
    }

    override fun addMediaItem(mediaItem: MediaItem) {
        original = original + mediaItem
        player.addMediaItem(mediaItem)
        log("Add media item")
    }

    override fun addMediaItems(mediaItems: MutableList<MediaItem>) {
        original = original + mediaItems
        player.addMediaItems(mediaItems)
        log("Add media items")
    }

    override fun addMediaItem(index: Int, mediaItem: MediaItem) {
        original = original + mediaItem
        player.addMediaItem(index, mediaItem)
        log("Add media item at $index")
    }

    override fun addMediaItems(index: Int, mediaItems: MutableList<MediaItem>) {
        original = original + mediaItems
        player.addMediaItems(index, mediaItems)
        log("Add media items at $index")
    }

    private fun getItemAt(index: Int) = player.getMediaItemAt(index).let {
        original.first { item -> item.mediaId == it.mediaId }
    }

    override fun removeMediaItem(index: Int) {
        original = original - getItemAt(index)
        player.removeMediaItem(index)
        log("Remove media item at $index")
    }

    override fun removeMediaItems(fromIndex: Int, toIndex: Int) {
        original =
            original - (fromIndex until toIndex).map { getItemAt(it) }.toSet()
        player.removeMediaItems(fromIndex, toIndex)
        log("Remove media items from $fromIndex to $toIndex")
    }

    override fun replaceMediaItem(index: Int, mediaItem: MediaItem) {
        original = original.toMutableList().apply {
            val originalIndex = indexOf(getItemAt(index)).takeIf { it != -1 }!!
            set(originalIndex, mediaItem)
        }
        player.replaceMediaItem(index, mediaItem)
        log("Replace media item at $index")
    }

    override fun replaceMediaItems(
        fromIndex: Int, toIndex: Int, mediaItems: MutableList<MediaItem>
    ) {
        original = original.toMutableList().apply {
            val originalIndexes = (fromIndex until toIndex).map { i ->
                indexOf(getItemAt(i)).takeIf { it != -1 }!!
            }
            originalIndexes.forEachIndexed { i, originalIndex ->
                set(originalIndex, mediaItems[i])
            }
        }
        player.replaceMediaItems(fromIndex, toIndex, mediaItems)
        log("Replace media items from $fromIndex to $toIndex")
    }

    override fun setMediaItem(mediaItem: MediaItem) {
        original = listOf(mediaItem)
        player.setMediaItem(mediaItem)
        log("Set media item")
    }

    override fun setMediaItem(mediaItem: MediaItem, resetPosition: Boolean) {
        original = listOf(mediaItem)
        player.setMediaItem(mediaItem, resetPosition)
        log("Set media item")
    }

    override fun setMediaItem(mediaItem: MediaItem, startPositionMs: Long) {
        original = listOf(mediaItem)
        player.setMediaItem(mediaItem, startPositionMs)
        log("Set media item")
    }

    override fun setMediaItems(mediaItems: MutableList<MediaItem>) {
        original = mediaItems
        player.setMediaItems(mediaItems)
        log("Set media items")
    }

    override fun setMediaItems(mediaItems: MutableList<MediaItem>, resetPosition: Boolean) {
        original = mediaItems
        player.setMediaItems(mediaItems, resetPosition)
        log("Set media items")
    }

    override fun setMediaItems(
        mediaItems: MutableList<MediaItem>,
        startIndex: Int,
        startPositionMs: Long
    ) {
        original = mediaItems
        player.setMediaItems(
            mediaItems,
            startIndex.coerceAtMost(mediaItems.size - 1),
            startPositionMs
        )
        log("Set media items")
    }

    override fun clearMediaItems() {
        original = emptyList()
        player.clearMediaItems()
        log("Clear media items")
    }

}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\exceptions\PlayerException.kt ----------
package com.joaomagdaleno.music_hub.playback.exceptions

import androidx.media3.common.MediaItem

class PlayerException(
    val mediaItem: MediaItem?,
    override val cause: Throwable
) : Exception()

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\listener\AudioFocusListener.kt ----------
package com.joaomagdaleno.music_hub.playback.listener

import android.content.Context
import android.media.AudioAttributes
import android.media.AudioFocusRequest
import android.media.AudioManager
import android.os.Build
import android.os.Handler
import androidx.media3.common.Player
import androidx.media3.common.Player.PlaybackSuppressionReason

@Suppress("DEPRECATION")
class AudioFocusListener(
    val context: Context,
    val player: Player
) : Player.Listener {
    private val handler = Handler(context.mainLooper)
    private val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
    private lateinit var focusRequest: AudioFocusRequest

    private val audioFocusChangeListener = AudioManager.OnAudioFocusChangeListener {
        if (it == AudioManager.AUDIOFOCUS_GAIN) {
            player.apply {
                setAudioAttributes(audioAttributes, true)
                seekTo(currentPosition)
            }
            abandonRequest()
        }
    }


    private fun requestFocus() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
            audioManager.requestAudioFocus(focusRequest)
        else audioManager.requestAudioFocus(
            audioFocusChangeListener,
            AudioManager.STREAM_MUSIC,
            AudioManager.AUDIOFOCUS_GAIN
        )
    }

    private fun abandonRequest() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
            audioManager.abandonAudioFocusRequest(focusRequest)
        else audioManager.abandonAudioFocus(audioFocusChangeListener)
    }

    init {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            focusRequest = AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN).run {
                setAudioAttributes(
                    AudioAttributes.Builder()
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                        .build()
                )
                setAcceptsDelayedFocusGain(true)
                setOnAudioFocusChangeListener(audioFocusChangeListener, handler)
                build()
            }
        }

        //TODO fix this to support player to play in calls
        // if the audio suppression was not there from the start
        // https://github.com/androidx/media/issues/1716
        onPlaybackSuppressionReasonChanged(player.playbackSuppressionReason)
    }

    override fun onPlaybackSuppressionReasonChanged(playbackSuppressionReason: @PlaybackSuppressionReason Int) {
        if (playbackSuppressionReason == Player.PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS) {
            player.apply {
                setAudioAttributes(audioAttributes, false)
                player.playWhenReady = false
                seekTo(currentPosition)
            }
            requestFocus()
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\listener\EffectsListener.kt ----------
package com.joaomagdaleno.music_hub.playback.listener

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.content.SharedPreferences.OnSharedPreferenceChangeListener
import android.media.audiofx.AudioEffect
import android.media.audiofx.Equalizer
import android.media.audiofx.LoudnessEnhancer
import androidx.annotation.OptIn
import androidx.core.content.edit
import androidx.media3.common.MediaItem
import androidx.media3.common.PlaybackParameters
import androidx.media3.common.Player
import androidx.media3.common.util.UnstableApi
import androidx.media3.exoplayer.ExoPlayer
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.copyTo
import kotlinx.coroutines.flow.MutableStateFlow
import kotlin.math.pow
import kotlin.math.roundToInt

@OptIn(UnstableApi::class)
class EffectsListener(
    private val exoPlayer: ExoPlayer,
    private val context: Context,
    private val audioSessionFlow: MutableStateFlow<Int>
) : Player.Listener {

    init {
        audioSessionFlow.value = exoPlayer.audioSessionId
        context.broadcastAudioSession()
    }

    private val settings: SharedPreferences = context.globalFx()
    private var oldSettings = settings
    private fun applyCustomEffects() {
        oldSettings.unregisterOnSharedPreferenceChangeListener(listener)
        val current = context.getFxPrefs(settings, exoPlayer.currentMediaItem?.mediaId?.hashCode())
            ?: settings
        oldSettings = current
        current.registerOnSharedPreferenceChangeListener(listener)
        applyPlayback(current)
        effects.applySettings(current)
    }

    private fun createEffects() = Effects(exoPlayer.audioSessionId)

    private fun applyPlayback(settings: SharedPreferences) {
        val index = settings.getInt(PLAYBACK_SPEED, speedRange.indexOf(1f))
        val speed = speedRange.getOrNull(index) ?: 1f
        val pitch = if (settings.getBoolean(CHANGE_PITCH, true)) speed else 1f
        exoPlayer.playbackParameters =
            PlaybackParameters(speed, pitch)
    }

    private var effects: Effects = createEffects()
    private val listener = OnSharedPreferenceChangeListener { _, _ -> applyCustomEffects() }

    override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) = applyCustomEffects()
    override fun onAudioSessionIdChanged(audioSessionId: Int) {
        release()
        context.broadcastAudioSession()
        audioSessionFlow.value = audioSessionId
        effects = createEffects()
        effects.applySettings(oldSettings)
    }

    class Effects(sessionId: Int) {
        private val equalizer = runCatching { Equalizer(0, sessionId) }.getOrNull()
        private val gain = runCatching { LoudnessEnhancer(sessionId) }.getOrNull()
        private fun applyBassBoost(strength: Int) = runCatching {
            if (strength == 0) {
                equalizer?.setEnabled(false)
                gain?.setEnabled(false)
                return@runCatching
            }
            gain?.setEnabled(true)
            equalizer?.setEnabled(true)
            equalizer?.apply {
                val value =
                    (strength * bandLevelRange.last().toDouble() / 10).roundToInt().toShort()
                val zero = numberOfBands.toDouble() * 2 / 3
                for (it in 0 until numberOfBands) {
                    val v = (-(it - zero).pow(3) * value / zero.pow(3)).roundToInt()
                    setBandLevel(it.toShort(), v.toShort())
                }
            }
            val g = (strength.toDouble().pow(1.toDouble() / 3) * 1600).roundToInt()
            gain?.setTargetGain(g)
        }

        fun release() {
            runCatching {
                equalizer?.release()
                gain?.release()
            }
        }

        fun applySettings(settings: SharedPreferences) {
            applyBassBoost(settings.getInt(BASS_BOOST, 0))
        }
    }

    companion object {
        const val GLOBAL_FX = "global_fx"
        const val BASS_BOOST = "bass_boost"
        const val PLAYBACK_SPEED = "playback_speed"
        val speedRange = listOf(
            0.1f, 0.175f, 0.25f, 0.33f, 0.5f, 0.66f, 0.75f, 0.85f, 0.9f, 0.95f,
            1f, 1.05f, 1.1f, 1.15f, 1.25f, 1.33f, 1.5f, 1.66f, 1.75f, 1.88f, 2f,
            2.33f, 2.5f, 3f, 4f, 8f, 16f, 32f, 64f
        )

        const val CHANGE_PITCH = "change_pitch"
        const val CUSTOM_EFFECTS = "custom_effects"

        fun Context.globalFx() = getSharedPreferences(GLOBAL_FX, Context.MODE_PRIVATE)!!
        fun Context.deleteGlobalFx() = deleteSharedPreferences(GLOBAL_FX)
        fun Context.getFxPrefs(settings: SharedPreferences, id: Int? = null): SharedPreferences? {
            if (id == null) return null
            val string = id.toString()
            val hasCustom = settings.getStringSet(CUSTOM_EFFECTS, emptySet())?.contains(string)
                ?: false
            return if (!hasCustom) null
            else getSharedPreferences("fx_$string", Context.MODE_PRIVATE)!!.apply {
                if (getBoolean("init", false)) return@apply
                settings.copyTo(this)
                edit { putBoolean("init", true) }
            }
        }

        fun Context.deleteFxPrefs(id: Int) =
            deleteSharedPreferences("fx_$id")
    }

    private fun Context.broadcastAudioSession() {
        val id = exoPlayer.audioSessionId
        sendBroadcast(Intent(AudioEffect.ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION).apply {
            putExtra(AudioEffect.EXTRA_PACKAGE_NAME, packageName)
            putExtra(AudioEffect.EXTRA_AUDIO_SESSION, id)
            putExtra(AudioEffect.EXTRA_CONTENT_TYPE, AudioEffect.CONTENT_TYPE_MUSIC)
        })
    }

    private fun Context.broadcastAudioSessionClose(id: Int) {
        sendBroadcast(Intent(AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION).apply {
            putExtra(AudioEffect.EXTRA_PACKAGE_NAME, packageName)
            putExtra(AudioEffect.EXTRA_AUDIO_SESSION, id)
        })
    }

    private fun release() {
        effects.release()
        context.broadcastAudioSessionClose(audioSessionFlow.value)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\listener\MediaSessionServiceListener.kt ----------
package com.joaomagdaleno.music_hub.playback.listener

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.media3.common.util.UnstableApi
import androidx.media3.session.MediaSessionService.Listener
import com.joaomagdaleno.music_hub.R

@UnstableApi
class MediaSessionServiceListener(
    private val context: Context,
    private val intent: PendingIntent
) : Listener {

    override fun onForegroundServiceStartNotAllowedException() {
        if (
            Build.VERSION.SDK_INT >= 33 &&
            context.checkSelfPermission(Manifest.permission.POST_NOTIFICATIONS) !=
            PackageManager.PERMISSION_GRANTED
        ) return

        val notificationManagerCompat = NotificationManagerCompat.from(context)
        context.ensureNotificationChannel(notificationManagerCompat)
        val builder = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_mono)
            .setContentTitle(context.getString(R.string.app_name))
            .setStyle(
                NotificationCompat.BigTextStyle().bigText(context.getString(R.string.app_name))
            )
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setAutoCancel(true)
            .setContentIntent(intent)
        notificationManagerCompat.notify(NOTIFICATION_ID, builder.build())
    }

    private fun Context.ensureNotificationChannel(
        notificationManagerCompat: NotificationManagerCompat
    ) {
        if (
            Build.VERSION.SDK_INT < 26 ||
            notificationManagerCompat.getNotificationChannel(CHANNEL_ID) != null
        ) return

        val channel = NotificationChannel(
            CHANNEL_ID,
            getString(R.string.app_name),
            NotificationManager.IMPORTANCE_DEFAULT,
        )
        notificationManagerCompat.createNotificationChannel(channel)
    }

    companion object {
        const val CHANNEL_ID = "echo_notification_channel_id"
        const val NOTIFICATION_ID = 1
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\listener\PlayerEventListener.kt ----------
package com.joaomagdaleno.music_hub.playback.listener

import android.content.Context
import androidx.media3.common.MediaItem
import androidx.media3.common.MediaMetadata
import androidx.media3.common.PlaybackException
import androidx.media3.common.Player
import androidx.media3.common.Timeline
import androidx.media3.session.MediaSession
import com.joaomagdaleno.music_hub.common.clients.LikeClient
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtension
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.isClient
import com.joaomagdaleno.music_hub.playback.MediaItemUtils
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.extensionId
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.isLoaded
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.retries
import com.joaomagdaleno.music_hub.playback.PlayerCommands.getLikeButton
import com.joaomagdaleno.music_hub.playback.PlayerCommands.getRepeatButton
import com.joaomagdaleno.music_hub.playback.PlayerState
import com.joaomagdaleno.music_hub.playback.ResumptionUtils
import com.joaomagdaleno.music_hub.playback.exceptions.PlayerException
import com.joaomagdaleno.music_hub.utils.Serializer.rootCause
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlin.reflect.KClass

class PlayerEventListener(
    private val context: Context,
    private val scope: CoroutineScope,
    private val session: MediaSession,
    private val currentFlow: MutableStateFlow<PlayerState.Current?>,
    private val extensions: ExtensionLoader,
    private val throwableFlow: MutableSharedFlow<Throwable>
) : Player.Listener {

    private val player get() = session.player

    private fun updateCustomLayout() = scope.launch(Dispatchers.Main) {
        val item = player.currentMediaItem ?: return@launch
        val supportsLike = withContext(Dispatchers.IO) {
            extensions.music.getExtension(item.extensionId)?.isClient<LikeClient>() ?: false
        }
        val commandButtons = listOfNotNull(
            getRepeatButton(context, player.repeatMode),
            getLikeButton(context, item).takeIf { supportsLike }
        )
        session.setCustomLayout(commandButtons)
    }

    private fun updateCurrentFlow() {
        if (player.currentMediaItem == null && player.mediaItemCount > 0)
            throw Exception("This is possible")
        currentFlow.value = player.currentMediaItem?.let {
            val isPlaying = player.isPlaying && player.playbackState == Player.STATE_READY
            PlayerState.Current(player.currentMediaItemIndex, it, it.isLoaded, isPlaying)
        }
    }

    override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {
        updateCurrentFlow()
        updateCustomLayout()
        ResumptionUtils.saveIndex(context, player.currentMediaItemIndex)
    }

    override fun onMediaMetadataChanged(mediaMetadata: MediaMetadata) {
        updateCurrentFlow()
        updateCustomLayout()
    }

    override fun onTimelineChanged(timeline: Timeline, reason: Int) {
        updateCurrentFlow()
        scope.launch { ResumptionUtils.saveQueue(context, player) }
    }

    override fun onRepeatModeChanged(repeatMode: Int) {
        updateCustomLayout()
        ResumptionUtils.saveRepeat(context, repeatMode)
    }

    override fun onShuffleModeEnabledChanged(shuffleModeEnabled: Boolean) {
        ResumptionUtils.saveShuffle(context, shuffleModeEnabled)
    }

    override fun onPlaybackStateChanged(playbackState: Int) {
        updateCurrentFlow()
    }

    override fun onIsPlayingChanged(isPlaying: Boolean) {
        updateCurrentFlow()
        ResumptionUtils.saveCurrentPos(context, player.currentPosition)
    }

    override fun onPositionDiscontinuity(
        oldPosition: Player.PositionInfo, newPosition: Player.PositionInfo, reason: Int
    ) {
        ResumptionUtils.saveCurrentPos(context, player.currentPosition)
    }

    private val maxRetries = 3
    private val maxSingleItemRetries = 1
    private var currentRetries = 0
    private var last: KClass<*>? = null
    override fun onPlayerError(error: PlaybackException) {
        val cause = error.cause ?: error
        val mediaItem = player.currentMediaItem
        scope.launch { throwableFlow.emit(PlayerException(mediaItem, cause)) }

        val old = last
        last = cause.rootCause::class
        if (old != null && old == last) currentRetries++
        else currentRetries = 0

        if (mediaItem == null) return
        val index = player.currentMediaItemIndex
        val retries = mediaItem.retries

        if (currentRetries >= maxRetries) return
        if (retries >= maxSingleItemRetries) {
            val hasMore = index < player.mediaItemCount - 1
            if (!hasMore) return
            player.seekToNextMediaItem()
        } else {
            val newItem = MediaItemUtils.withRetry(mediaItem)
            player.replaceMediaItem(index, newItem)
        }
        player.prepare()
        player.play()
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\listener\PlayerRadio.kt ----------
package com.joaomagdaleno.music_hub.playback.listener

import android.content.SharedPreferences
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.common.Player.REPEAT_MODE_OFF
import androidx.media3.common.Timeline
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.MusicExtension
import com.joaomagdaleno.music_hub.common.clients.RadioClient
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.pagedDataOfFirst
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.get
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtension
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getIf
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getOrThrow
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.playback.MediaItemUtils
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.context
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.extensionId
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.playback.PlayerState
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class PlayerRadio(
    private val app: App,
    private val scope: CoroutineScope,
    private val player: Player,
    private val throwFlow: MutableSharedFlow<Throwable>,
    private val stateFlow: MutableStateFlow<PlayerState.Radio>,
    private val extensionList: StateFlow<List<MusicExtension>>,
    private val downloadFlow: StateFlow<List<Downloader.Info>>
) : Player.Listener {

    companion object {
        const val AUTO_START_RADIO = "auto_start_radio"
        suspend fun start(
            throwableFlow: MutableSharedFlow<Throwable>,
            extension: Extension<*>,
            item: EchoMediaItem,
            itemContext: EchoMediaItem?
        ): PlayerState.Radio.Loaded? {
            if (!item.isRadioSupported) return null
            return extension.getIf<RadioClient, PlayerState.Radio.Loaded?> {
                val radio = radio(item, itemContext)
                val tracks = loadTracks(radio).pagedDataOfFirst()
                PlayerState.Radio.Loaded(extension.id, radio, null) {
                    extension.get { tracks.loadPage(it) }.getOrThrow(throwableFlow)
                }
            }.getOrThrow(throwableFlow)
        }

        suspend fun play(
            player: Player,
            downloadFlow: StateFlow<List<Downloader.Info>>,
            app: App,
            stateFlow: MutableStateFlow<PlayerState.Radio>,
            loaded: PlayerState.Radio.Loaded
        ) {
            stateFlow.value = PlayerState.Radio.Loading
            val tracks = loaded.tracks(loaded.cont) ?: return

            stateFlow.value = if (tracks.continuation == null) PlayerState.Radio.Empty
            else loaded.copy(cont = tracks.continuation)

            val item = tracks.data.map {
                MediaItemUtils.build(
                    app,
                    downloadFlow.value,
                    MediaState.Unloaded(loaded.clientId, it),
                    loaded.context
                )
            }

            withContext(Dispatchers.Main) {
                player.addMediaItems(item)
                player.prepare()
            }
        }
    }

    private suspend fun loadPlaylist() {
        val mediaItem = withContext(Dispatchers.Main) { player.currentMediaItem } ?: return
        val extensionId = mediaItem.extensionId
        val item = mediaItem.track
        val itemContext = mediaItem.context
        stateFlow.value = PlayerState.Radio.Loading
        val extension = extensionList.getExtension(extensionId) ?: return
        val loaded = start(throwFlow, extension, item, itemContext)
        stateFlow.value = loaded ?: PlayerState.Radio.Empty
        if (loaded != null) play(player, downloadFlow, app, stateFlow, loaded)
    }

    private var autoStartRadio = app.settings.getBoolean(AUTO_START_RADIO, true)

    private val listener = SharedPreferences.OnSharedPreferenceChangeListener { pref, key ->
        if (key != AUTO_START_RADIO) return@OnSharedPreferenceChangeListener
        autoStartRadio = pref.getBoolean(AUTO_START_RADIO, true)
    }

    init {
        app.settings.registerOnSharedPreferenceChangeListener(listener)
    }

    private suspend fun startRadio() {
        if (!autoStartRadio) return
        val shouldNotStart = withContext(Dispatchers.Main) {
            player.run {
                currentMediaItem == null || repeatMode != REPEAT_MODE_OFF || hasNextMediaItem()
            }
        }
        if (shouldNotStart) return
        when (val state = stateFlow.value) {
            is PlayerState.Radio.Loading -> {}
            is PlayerState.Radio.Empty -> loadPlaylist()
            is PlayerState.Radio.Loaded -> play(player, downloadFlow, app, stateFlow, state)
        }
    }

    override fun onTimelineChanged(timeline: Timeline, reason: Int) {
        scope.launch { startRadio() }
    }

    override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {
        if (player.mediaItemCount == 0) stateFlow.value = PlayerState.Radio.Empty
        scope.launch { startRadio() }
    }
}



---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\listener\TrackingListener.kt ----------
package com.joaomagdaleno.music_hub.playback.listener

import androidx.media3.common.C
import androidx.media3.common.MediaItem
import androidx.media3.common.PlaybackException
import androidx.media3.common.Player
import androidx.media3.common.util.UnstableApi
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.clients.TrackerClient
import com.joaomagdaleno.music_hub.common.clients.TrackerMarkClient
import com.joaomagdaleno.music_hub.common.models.TrackDetails
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtension
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.runIf
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.context
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.extensionId
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.playback.PlayerState
import com.joaomagdaleno.music_hub.utils.PauseTimer
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.FlowPreview
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.debounce
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withContext

@UnstableApi
class TrackingListener(
    private val player: Player,
    private val scope: CoroutineScope,
    extensions: ExtensionLoader,
    private val currentFlow: MutableStateFlow<PlayerState.Current?>,
    private val throwableFlow: MutableSharedFlow<Throwable>
) : Player.Listener {

    private val musicList = extensions.music
    private val trackerList = extensions.tracker

    private var current: MediaItem? = null
    private var previousId: String? = null

    private suspend fun getDetails() = withContext(Dispatchers.Main) {
        current?.let { curr ->
            val (pos, total) = player.currentPosition to player.duration.takeIf { it != C.TIME_UNSET }
            TrackDetails(curr.extensionId, curr.track, curr.context, pos, total)
        }
    }

    private fun trackMedia(
        block: suspend TrackerClient.(extension: Extension<*>, details: TrackDetails?) -> Unit
    ) {
        scope.launch {
            val details = getDetails()
            val prevExtension = previousId?.takeIf { details?.extensionId != it }
                ?.let { musicList.getExtension(it) }
            val extension = musicList.getExtension(details?.extensionId)
            val trackers = trackerList.value.filter { it.isEnabled }
            prevExtension?.runIf<TrackerClient>(throwableFlow) { block(prevExtension, null) }
            extension?.runIf<TrackerClient>(throwableFlow) { block(extension, details) }
            trackers.forEach {
                launch { it.runIf<TrackerClient>(throwableFlow) { block(it, details) } }
            }
        }
    }

    private val mutex = Mutex()
    private val timers = mutableMapOf<String, PauseTimer>()
    private fun onTrackChanged(mediaItem: MediaItem?) {
        previousId = current?.extensionId
        current = mediaItem
        scope.launch {
            mutex.withLock {
                timers.forEach { (_, timer) -> timer.pause() }
                timers.clear()
            }
            trackMedia { extension, details ->
                onTrackChanged(details)
                details ?: return@trackMedia
                val duration = (this as? TrackerMarkClient)?.getMarkAsPlayedDuration(details)
                    ?: return@trackMedia
                mutex.withLock {
                    timers[extension.id] = PauseTimer(scope, duration) {
                        scope.launch {
                            extension.runIf<TrackerMarkClient>(throwableFlow) {
                                onMarkAsPlayed(details)
                            }
                        }
                    }
                }
            }
        }
    }

    override fun onIsPlayingChanged(isPlaying: Boolean) {
        scope.launch {
            playState.value = getDetails() to isPlaying
        }
    }

    override fun onPositionDiscontinuity(
        oldPosition: Player.PositionInfo, newPosition: Player.PositionInfo, reason: Int
    ) {
        scope.launch {
            val isPlaying = withContext(Dispatchers.Main) { player.isPlaying }
            playState.value = getDetails() to isPlaying
        }
        if (reason == 2 || current == null) return
        val mediaItem = newPosition.mediaItem ?: return
        if (oldPosition.mediaItem != mediaItem) return
        if (newPosition.positionMs != 0L) return

        onTrackChanged(current)
    }

    override fun onPlayerError(error: PlaybackException) {
        onTrackChanged(null)
    }

    private val playState = MutableStateFlow<Pair<TrackDetails?, Boolean>>(null to false)

    init {
        scope.launch {
            currentFlow.map { it?.let { curr -> curr.mediaItem.takeIf { curr.isLoaded } } }
                .distinctUntilChanged().collectLatest {
                    onTrackChanged(it)
                }
        }
        scope.launch {
            @OptIn(FlowPreview::class)
            playState.debounce(500).collectLatest { (_, isPlaying) ->
                mutex.withLock {
                    timers.forEach { (_, timer) ->
                        if (isPlaying) timer.resume()
                        else timer.pause()
                    }
                }
                trackMedia { _, details ->
                    onPlayingStateChanged(details, isPlaying)
                }
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\renderer\PlayerBitmapLoader.kt ----------
package com.joaomagdaleno.music_hub.playback.renderer

import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import androidx.core.graphics.drawable.toBitmapOrNull
import androidx.media3.common.util.BitmapLoader
import androidx.media3.common.util.UnstableApi
import com.google.common.util.concurrent.ListenableFuture
import com.joaomagdaleno.music_hub.common.models.ImageHolder
import com.joaomagdaleno.music_hub.utils.CoroutineUtils.futureCatching
import com.joaomagdaleno.music_hub.utils.Serializer.toData
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadDrawable
import kotlinx.coroutines.CoroutineScope

@UnstableApi
class PlayerBitmapLoader(
    val context: Context,
    private val scope: CoroutineScope
) : BitmapLoader {

    override fun supportsMimeType(mimeType: String) = true

    override fun decodeBitmap(data: ByteArray) = scope.futureCatching {
        BitmapFactory.decodeByteArray(data, 0, data.size) ?: error("Failed to decode bitmap")
    }

    override fun loadBitmap(uri: Uri): ListenableFuture<Bitmap> = scope.futureCatching {
        val cover = uri.getQueryParameter("actual_data")!!.toData<ImageHolder>().getOrThrow()
        cover.loadDrawable(context)?.toBitmapOrNull()
            ?: error("Failed to load bitmap of $cover")
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\renderer\RenderersFactory.kt ----------
package com.joaomagdaleno.music_hub.playback.renderer

import android.content.Context
import androidx.media3.common.audio.SonicAudioProcessor
import androidx.media3.common.util.UnstableApi
import androidx.media3.exoplayer.DefaultRenderersFactory
import androidx.media3.exoplayer.audio.DefaultAudioSink
import androidx.media3.exoplayer.audio.SilenceSkippingAudioProcessor

@androidx.annotation.OptIn(UnstableApi::class)
class RenderersFactory(
    context: Context
) : DefaultRenderersFactory(context) {

    override fun buildAudioSink(
        context: Context,
        enableFloatOutput: Boolean,
        enableAudioTrackPlaybackParams: Boolean
    ) = run {
        val silenceSkippingAudioProcessor = SilenceSkippingAudioProcessor(
            2_000_000,
            (20_000 / 2_000_000).toFloat(),
            2_000_000,
            0,
            256,
        )

        DefaultAudioSink.Builder(context)
            .setEnableFloatOutput(enableFloatOutput)
            .setEnableAudioTrackPlaybackParams(enableAudioTrackPlaybackParams)
            .setAudioProcessorChain(
                DefaultAudioSink.DefaultAudioProcessorChain(
                    emptyArray(), silenceSkippingAudioProcessor, SonicAudioProcessor()
                )
            )
            .build()
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\source\RawDataSource.kt ----------
package com.joaomagdaleno.music_hub.playback.source

import android.net.Uri
import androidx.annotation.OptIn
import androidx.media3.common.util.UnstableApi
import androidx.media3.datasource.BaseDataSource
import androidx.media3.datasource.DataSource
import androidx.media3.datasource.DataSpec
import com.joaomagdaleno.music_hub.common.models.Streamable
import kotlinx.coroutines.runBlocking
import java.io.InputStream

@OptIn(UnstableApi::class)
class RawDataSource : BaseDataSource(true) {

    class Factory : DataSource.Factory {
        override fun createDataSource() = RawDataSource()
    }

    private var stream: InputStream? = null
    private var uri: Uri? = null

    override fun open(dataSpec: DataSpec): Long {
        val streamable = dataSpec.customData as Streamable.Source.Raw
        val (source, total) = runBlocking {
            streamable.streamProvider!!.provide(dataSpec.position, dataSpec.length)
        }
        uri = dataSpec.uri
        stream = source
        return total
    }

    override fun read(buffer: ByteArray, offset: Int, length: Int): Int {
        return stream!!.read(buffer, offset, length)
    }

    override fun getUri() = uri

    override fun close() {
        stream?.close()
        stream = null
        uri = null
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\source\StreamableDataSource.kt ----------
package com.joaomagdaleno.music_hub.playback.source

import android.content.Context
import androidx.core.net.toUri
import androidx.media3.common.util.UnstableApi
import androidx.media3.datasource.BaseDataSource
import androidx.media3.datasource.DataSource
import androidx.media3.datasource.DataSpec
import androidx.media3.datasource.DefaultDataSource
import androidx.media3.datasource.DefaultHttpDataSource
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.playback.source.StreamableResolver.Companion.copy

@UnstableApi
class StreamableDataSource(
    private val defaultDataSourceFactory: Lazy<DefaultDataSource.Factory>,
    private val defaultHttpDataSourceFactory: Lazy<DefaultHttpDataSource.Factory>,
    private val rawDataSourceFactory: Lazy<RawDataSource.Factory>,
) : BaseDataSource(true) {

    class Factory(
        context: Context,
    ) : DataSource.Factory {
        private val defaultDataSourceFactory = lazy {
            DefaultDataSource.Factory(context, defaultHttpDataSourceFactory.value)
        }
        private val defaultHttpDataSourceFactory = lazy {
            DefaultHttpDataSource.Factory().setAllowCrossProtocolRedirects(true)
        }
        private val rawDataSourceFactory = lazy { RawDataSource.Factory() }
        override fun createDataSource() = StreamableDataSource(
            defaultDataSourceFactory, defaultHttpDataSourceFactory, rawDataSourceFactory
        )
    }

    private var source: DataSource? = null

    override fun getUri() = source?.uri

    override fun read(buffer: ByteArray, offset: Int, length: Int) =
        source?.read(buffer, offset, length) ?: throw Exception("Source not opened")

    override fun close() {
        source?.close()
        source = null
    }

    override fun open(dataSpec: DataSpec): Long {
        val result = dataSpec.customData as? Result<*>
        val (factory, spec) = when (result) {
            null -> defaultDataSourceFactory to dataSpec
            else -> when (val streamable = result.getOrThrow() as Streamable.Source) {
                is Streamable.Source.Raw -> rawDataSourceFactory to
                        dataSpec.copy(uri = streamable.uri, customData = streamable)

                is Streamable.Source.Http -> {
                    val spec = streamable.request.run {
                        defaultHttpDataSourceFactory.value.setDefaultRequestProperties(headers)
                        dataSpec.copy(uri = url.toUri(), httpRequestHeaders = headers)
                    }
                    defaultDataSourceFactory to spec
                }
            }
        }
        val source = factory.value.createDataSource()
        this.source = source
        return source.open(spec)
    }

    companion object {
        val Streamable.Source.uri
            get() = when (this) {
                is Streamable.Source.Http -> request.url.toUri()
                is Streamable.Source.Raw -> "raw://${id.hashCode()}".toUri()
            }
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\source\StreamableLoader.kt ----------
package com.joaomagdaleno.music_hub.playback.source

import android.net.Uri
import androidx.media3.common.MediaItem
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.MusicExtension
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Streamable.Source.Companion.toSource
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtensionOrThrow
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.extensions.cache.Cached
import com.joaomagdaleno.music_hub.extensions.cache.Cached.loadStreamableMedia
import com.joaomagdaleno.music_hub.playback.MediaItemUtils
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.backgroundIndex
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.downloaded
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.extensionId
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.isLoaded
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.serverIndex
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.state
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.subtitleIndex
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.ui.media.MediaHeaderAdapter.Companion.playableString
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import java.io.File

class StreamableLoader(
    private val app: App,
    private val extensionListFlow: StateFlow<List<MusicExtension>>,
    private val downloadFlow: StateFlow<List<Downloader.Info>>
) {
    suspend fun load(mediaItem: MediaItem) = withContext(Dispatchers.IO) {
        extensionListFlow.first { it.isNotEmpty() }
        val new = if (mediaItem.isLoaded) mediaItem
        else MediaItemUtils.buildLoaded(
            app, downloadFlow.value, mediaItem, loadTrack(mediaItem)
        )

        val server = async { loadServer(new) }
        val background =
            async { if (new.backgroundIndex < 0) null else loadBackground(new).getOrNull() }
        val subtitle = async { if (new.subtitleIndex < 0) null else loadSubtitle(new).getOrNull() }

        MediaItemUtils.buildWithBackgroundAndSubtitle(
            new, background.await(), subtitle.await()
        ) to server.await()
    }

    private suspend fun <T> withClient(
        mediaItem: MediaItem,
        block: suspend (Extension<*>) -> Result<T>
    ): Result<T> {
        val extension = extensionListFlow.getExtensionOrThrow(mediaItem.extensionId)
        return block(extension)
    }

    private suspend fun loadTrack(item: MediaItem): MediaState.Loaded<Track> {
        val track = withClient(item) {
            Cached.loadMedia(app, it, item.state)
        }
        return track.getOrThrow()
    }

    private suspend fun loadServer(mediaItem: MediaItem): Result<Streamable.Media.Server> {
        val downloaded = mediaItem.downloaded
        val servers = mediaItem.track.servers
        val index = mediaItem.serverIndex
        if (!downloaded.isNullOrEmpty() && servers.size == index) {
            return runCatching {
                Streamable.Media.Server(
                    downloaded.map { Uri.fromFile(File(it)).toString().toSource() },
                    true
                )
            }
        }
        return withClient(mediaItem) {
            runCatching {
                val isPlayable = mediaItem.track.playableString(app.context)
                if (isPlayable != null) throw Exception(isPlayable)
                val streamable = servers.getOrNull(index) ?: throw Exception("Server not found")
                loadStreamableMedia(
                    app, it, mediaItem.track, streamable
                ).getOrThrow() as Streamable.Media.Server
            }
        }
    }

    private suspend fun loadBackground(mediaItem: MediaItem): Result<Streamable.Media.Background> {
        val streams = mediaItem.track.backgrounds
        val index = mediaItem.backgroundIndex
        val streamable = streams[index]
        return withClient(mediaItem) {
            runCatching {
                loadStreamableMedia(
                    app, it, mediaItem.track, streamable
                ).getOrThrow() as Streamable.Media.Background
            }
        }
    }

    private suspend fun loadSubtitle(mediaItem: MediaItem): Result<Streamable.Media.Subtitle> {
        val streams = mediaItem.track.subtitles
        val index = mediaItem.subtitleIndex
        val streamable = streams[index]
        return withClient(mediaItem) {
            runCatching {
                loadStreamableMedia(
                    app, it, mediaItem.track, streamable
                ).getOrThrow() as Streamable.Media.Subtitle
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\source\StreamableMediaSource.kt ----------
package com.joaomagdaleno.music_hub.playback.source

import androidx.media3.common.C
import androidx.media3.common.MediaItem
import androidx.media3.common.Timeline
import androidx.media3.common.util.UnstableApi
import androidx.media3.common.util.Util
import androidx.media3.datasource.ResolvingDataSource
import androidx.media3.datasource.TransferListener
import androidx.media3.datasource.cache.CacheDataSource
import androidx.media3.datasource.cache.SimpleCache
import androidx.media3.exoplayer.dash.DashMediaSource
import androidx.media3.exoplayer.drm.DrmSessionManagerProvider
import androidx.media3.exoplayer.hls.HlsMediaSource
import androidx.media3.exoplayer.source.CompositeMediaSource
import androidx.media3.exoplayer.source.DefaultMediaSourceFactory
import androidx.media3.exoplayer.source.MediaPeriod
import androidx.media3.exoplayer.source.MediaSource
import androidx.media3.exoplayer.source.MergingMediaSource
import androidx.media3.exoplayer.upstream.Allocator
import androidx.media3.exoplayer.upstream.LoadErrorHandlingPolicy
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.playback.MediaItemUtils
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.backgroundIndex
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.extensionId
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.retries
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.serverIndex
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.sourceIndex
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.subtitleIndex
import com.joaomagdaleno.music_hub.playback.PlayerService.Companion.select
import com.joaomagdaleno.music_hub.playback.PlayerState
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import java.io.IOException

@UnstableApi
class StreamableMediaSource(
    private var mediaItem: MediaItem,
    private val app: App,
    private val scope: CoroutineScope,
    private val state: PlayerState,
    private val loader: StreamableLoader,
    private val cacheFactories: Factories,
    private val factories: Factories,
    private val changeFlow: MutableSharedFlow<Pair<MediaItem, MediaItem>>,
) : CompositeMediaSource<Nothing>() {

    private var error: Throwable? = null
    override fun maybeThrowSourceInfoRefreshError() {
        error?.let { throw IOException(it) }
        super.maybeThrowSourceInfoRefreshError()
    }

    fun getFactory(source: Streamable.Source) = if (source.isLive) factories else cacheFactories

    private lateinit var actualSource: MediaSource
    override fun prepareSourceInternal(mediaTransferListener: TransferListener?) {
        super.prepareSourceInternal(mediaTransferListener)
        val handler = Util.createHandlerForCurrentLooper()
        scope.launch {
            var (new, serv) = runCatching { loader.load(mediaItem) }.getOrElse {
                error = it
                return@launch
            }
            val server = serv.getOrNull()
            state.servers[new.mediaId] = serv
            state.serverChanged.emit(Unit)
            val sources = server?.sources
            actualSource = when (sources?.size) {
                0, null -> factories.create(new, -1, null)
                1 -> {
                    val source = sources.first()
                    getFactory(source).create(new, 0, source)
                }

                else -> {
                    if (server.merged) MergingMediaSource(
                        *sources.mapIndexed { index, source ->
                            getFactory(source).create(new, index, source)
                        }.toTypedArray()
                    ) else {
                        val index = mediaItem.sourceIndex
                        val source = sources.getOrNull(index)
                            ?: sources.select(app, new.extensionId) { it.quality }
                        val newIndex = sources.indexOf(source)
                        new = MediaItemUtils.buildSource(new, newIndex)
                        getFactory(source).create(new, newIndex, source)
                    }
                }
            }

            changeFlow.emit(mediaItem to new)
            mediaItem = new

            handler.post {
                runCatching {
                    prepareChildSource(null, actualSource)
                }.getOrElse {
                    it.printStackTrace()
                }
            }
        }
    }

    override fun onChildSourceInfoRefreshed(
        childSourceId: Nothing?, mediaSource: MediaSource, newTimeline: Timeline,
    ) = refreshSourceInfo(newTimeline)

    override fun getMediaItem() = mediaItem

    override fun createPeriod(
        id: MediaSource.MediaPeriodId, allocator: Allocator, startPositionUs: Long,
    ) = actualSource.createPeriod(id, allocator, startPositionUs)

    override fun releasePeriod(mediaPeriod: MediaPeriod) =
        actualSource.releasePeriod(mediaPeriod)

    override fun canUpdateMediaItem(mediaItem: MediaItem) = run {
        this.mediaItem.apply {
            if (retries != mediaItem.retries) return@run false
            if (serverIndex != mediaItem.serverIndex) return@run false
            if (this.sourceIndex != mediaItem.sourceIndex) return@run false
            if (backgroundIndex != mediaItem.backgroundIndex) return@run false
            if (subtitleIndex != mediaItem.subtitleIndex) return@run false
        }
        if (::actualSource.isInitialized) actualSource.canUpdateMediaItem(mediaItem)
        else false
    }

    override fun updateMediaItem(mediaItem: MediaItem) {
        this.mediaItem = mediaItem
        actualSource.updateMediaItem(mediaItem)
    }

    data class Factories(
        val dash: Lazy<MediaSource.Factory>,
        val hls: Lazy<MediaSource.Factory>,
        val default: Lazy<MediaSource.Factory>,
    ) {
        fun create(mediaItem: MediaItem, index: Int, source: Streamable.Source?): MediaSource {
            val type = (source as? Streamable.Source.Http)?.type
            val factory = when (type) {
                Streamable.SourceType.DASH -> dash
                Streamable.SourceType.HLS -> hls
                Streamable.SourceType.Progressive, null -> default
            }
            val new = MediaItemUtils.buildForSource(mediaItem, index, source)
            return factory.value.createMediaSource(new)
        }
    }

    class Factory(
        private val app: App,
        private val scope: CoroutineScope,
        private val state: PlayerState,
        extensions: ExtensionLoader,
        cache: SimpleCache,
        downloadFlow: StateFlow<List<Downloader.Info>>,
        private val changeFlow: MutableSharedFlow<Pair<MediaItem, MediaItem>>,
    ) : MediaSource.Factory {

        private val loader = StreamableLoader(app, extensions.music, downloadFlow)

        val dataSourceFactory = StreamableDataSource.Factory(app.context)
        val streamableResolver = StreamableResolver(app.context, state.servers)

        private val cacheDataSource = ResolvingDataSource.Factory(
            CacheDataSource.Factory().setCache(cache)
                .setUpstreamDataSourceFactory(dataSourceFactory),
            streamableResolver
        )

        private val dataSource = ResolvingDataSource.Factory(
            dataSourceFactory, streamableResolver
        )

        private val cacheFactories = createFactories(cacheDataSource)

        private val factories = createFactories(dataSource)

        private fun createFactories(dataSource: ResolvingDataSource.Factory) = Factories(
            lazily { DashMediaSource.Factory(dataSource) },
            lazily { HlsMediaSource.Factory(dataSource) },
            lazily { DefaultMediaSourceFactory(dataSource) }
        )

        private var drmSessionManagerProvider: DrmSessionManagerProvider? = null
        private var loadErrorHandlingPolicy: LoadErrorHandlingPolicy? = null
        private fun lazily(factory: () -> MediaSource.Factory) = lazy {
            factory().apply {
                drmSessionManagerProvider?.let { setDrmSessionManagerProvider(it) }
                loadErrorHandlingPolicy?.let { setLoadErrorHandlingPolicy(it) }
            }
        }

        override fun getSupportedTypes() = intArrayOf(
            C.CONTENT_TYPE_OTHER, C.CONTENT_TYPE_HLS, C.CONTENT_TYPE_DASH
        )

        override fun setDrmSessionManagerProvider(
            drmSessionManagerProvider: DrmSessionManagerProvider,
        ): MediaSource.Factory {
            this.drmSessionManagerProvider = drmSessionManagerProvider
            return this
        }

        override fun setLoadErrorHandlingPolicy(
            loadErrorHandlingPolicy: LoadErrorHandlingPolicy,
        ): MediaSource.Factory {
            this.loadErrorHandlingPolicy = loadErrorHandlingPolicy
            return this
        }

        override fun createMediaSource(mediaItem: MediaItem) = StreamableMediaSource(
            mediaItem, app, scope, state, loader, cacheFactories, factories, changeFlow
        )
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\playback\source\StreamableResolver.kt ----------
package com.joaomagdaleno.music_hub.playback.source

import android.content.Context
import android.net.Uri
import androidx.annotation.OptIn
import androidx.media3.common.util.UnstableApi
import androidx.media3.datasource.DataSpec
import androidx.media3.datasource.ResolvingDataSource.Resolver
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.toKey
import com.joaomagdaleno.music_hub.playback.source.StreamableDataSource.Companion.uri
import com.joaomagdaleno.music_hub.utils.CacheUtils.saveToCache
import java.util.WeakHashMap

class StreamableResolver(
    private val context: Context,
    private val current: WeakHashMap<String, Result<Streamable.Media.Server>>,
) : Resolver {

    @OptIn(UnstableApi::class)
    override fun resolveDataSpec(dataSpec: DataSpec): DataSpec {
        val (id, index) = dataSpec.uri.toString().toKey().getOrNull() ?: return dataSpec
        val streamable = runCatching { current[id]!!.getOrThrow().sources[index] }
        val uri = streamable.map {
            if (!it.isLive)
                context.saveToCache(it.uri.toString(), dataSpec.uri.toString(), "player")
            it.uri
        }
        return dataSpec.copy(uri = uri.getOrNull(), customData = streamable)
    }

    companion object {

        @OptIn(UnstableApi::class)
        fun DataSpec.copy(
            uri: Uri? = null,
            uriPositionOffset: Long? = null,
            httpMethod: Int? = null,
            httpBody: ByteArray? = null,
            httpRequestHeaders: Map<String, String>? = null,
            position: Long? = null,
            length: Long? = null,
            key: String? = null,
            flags: Int? = null,
            customData: Any? = null,
        ): DataSpec {
            return DataSpec.Builder()
                .setUri(uri ?: this.uri)
                .setUriPositionOffset(uriPositionOffset ?: this.uriPositionOffset)
                .setHttpMethod(httpMethod ?: this.httpMethod)
                .setHttpBody(httpBody ?: this.httpBody)
                .setHttpRequestHeaders(httpRequestHeaders ?: this.httpRequestHeaders)
                .setPosition(position ?: this.position)
                .setLength(length ?: this.length)
                .setKey(key ?: this.key)
                .setFlags(flags ?: this.flags)
                .setCustomData(customData ?: this.customData)
                .build()
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\media\LineAdapter.kt ----------
package com.joaomagdaleno.music_hub.ui.media

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.paging.LoadState
import com.joaomagdaleno.music_hub.databinding.ItemLineBinding
import com.joaomagdaleno.music_hub.ui.common.GridAdapter
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimLoadStateAdapter
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimViewHolder

class LineAdapter : ScrollAnimLoadStateAdapter<LineAdapter.ViewHolder>(), GridAdapter {
    override val adapter = this
    override fun getSpanSize(position: Int, width: Int, count: Int) = count
    override fun onCreateViewHolder(parent: ViewGroup, loadState: LoadState) = ViewHolder(parent)
    class ViewHolder(
        parent: ViewGroup,
        binding: ItemLineBinding = ItemLineBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        )
    ) : ScrollAnimViewHolder(binding.root)
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\media\MediaDetailsFragment.kt ----------
package com.joaomagdaleno.music_hub.ui.media

import android.os.Bundle
import android.view.View
import androidx.fragment.app.Fragment
import androidx.paging.LoadState
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.Feed
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.databinding.FragmentMediaDetailsBinding
import com.joaomagdaleno.music_hub.ui.common.GridAdapter
import com.joaomagdaleno.music_hub.ui.common.GridAdapter.Companion.configureGridLayout
import com.joaomagdaleno.music_hub.ui.common.UiViewModel
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyContentInsets
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyInsets
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.configure
import com.joaomagdaleno.music_hub.ui.feed.FeedAdapter.Companion.getFeedAdapter
import com.joaomagdaleno.music_hub.ui.feed.FeedAdapter.Companion.getTouchHelper
import com.joaomagdaleno.music_hub.ui.feed.FeedClickListener
import com.joaomagdaleno.music_hub.ui.feed.FeedClickListener.Companion.getFeedListener
import com.joaomagdaleno.music_hub.ui.feed.FeedViewModel
import com.joaomagdaleno.music_hub.ui.media.MediaHeaderAdapter.Companion.getMediaHeaderListener
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.ui.FastScrollerHelper
import kotlinx.coroutines.flow.combine
import org.koin.androidx.viewmodel.ext.android.activityViewModel
import org.koin.androidx.viewmodel.ext.android.viewModel

class MediaDetailsFragment : Fragment(R.layout.fragment_media_details) {

    interface Parent {
        val feedId: String
        val viewModel: MediaDetailsViewModel
        val fromPlayer: Boolean
    }

    val parent by lazy { requireParentFragment() as Parent }
    val viewModel by lazy { parent.viewModel }
    private val feedViewModel by lazy {
        requireParentFragment().viewModel<FeedViewModel>().value
    }

    private val trackFeedData by lazy {
        feedViewModel.getFeedData(
            "${parent.feedId}_tracks",
            Feed.Buttons(showPlayAndShuffle = true),
            true,
            viewModel.tracksLoadedFlow, viewModel.trackCachedFlow,
            cached = { viewModel.trackCachedFlow.value?.getOrThrow() },
            loader = { viewModel.tracksLoadedFlow.value?.getOrThrow() }
        )
    }

    private val feedData by lazy {
        feedViewModel.getFeedData(
            "${parent.feedId}_feed",
            Feed.Buttons(),
            false,
            viewModel.feedCachedFlow, viewModel.feedLoadedFlow,
            cached = { viewModel.feedCachedFlow.value?.getOrThrow() },
            loader = { viewModel.feedLoadedFlow.value?.getOrThrow() }
        )
    }

    private val mediaHeaderAdapter by lazy {
        MediaHeaderAdapter(
            requireParentFragment().getMediaHeaderListener(viewModel),
            parent.fromPlayer
        )
    }

    private val feedListener by lazy {
        if (!parent.fromPlayer) requireParentFragment().getFeedListener()
        else FeedClickListener(
            requireParentFragment(),
            requireActivity().supportFragmentManager,
            R.id.navHostFragment
        ) {
            val uiViewModel by activityViewModel<UiViewModel>()
            uiViewModel.collapsePlayer()
        }
    }

    private val trackAdapter by lazy {
        getFeedAdapter(trackFeedData, feedListener, true)
    }
    private val feedAdapter by lazy {
        getFeedAdapter(feedData, feedListener)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val binding = FragmentMediaDetailsBinding.bind(view)
        FastScrollerHelper.applyTo(binding.recyclerView)
        applyInsets(viewModel.uiResultFlow) {
            val item = viewModel.uiResultFlow.value?.getOrNull()?.item as? Playlist
            val bottom = if (item?.isEditable == true) 72 else 16
            binding.recyclerView.applyContentInsets(it, 20, 8, bottom)
        }
        val lineAdapter = LineAdapter()
        observe(trackFeedData.shouldShowEmpty) {
            lineAdapter.loadState = if (it) LoadState.Loading else LoadState.NotLoading(false)
        }
        observe(viewModel.uiResultFlow) { result ->
            mediaHeaderAdapter.result = result
        }
        getTouchHelper(feedListener).attachToRecyclerView(binding.recyclerView)
        configureGridLayout(
            binding.recyclerView,
            GridAdapter.Concat(
                mediaHeaderAdapter,
                trackAdapter.withLoading(this),
                lineAdapter,
                feedAdapter.withLoading(this)
            )
        )
        val loadingFlow = viewModel.isRefreshingFlow
            .combine(trackFeedData.isRefreshingFlow) { a, b -> a || b }
                .combine(feedData.isRefreshingFlow) { a, b -> a || b }
        binding.swipeRefresh.run {
            configure()
            setOnRefreshListener { viewModel.refresh() }
            observe(loadingFlow) {
                isRefreshing = it
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\media\MediaDetailsViewModel.kt ----------
package com.joaomagdaleno.music_hub.ui.media

import android.content.Context
import android.content.Intent
import androidx.core.app.ShareCompat
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.MusicExtension
import com.joaomagdaleno.music_hub.common.clients.FollowClient
import com.joaomagdaleno.music_hub.common.clients.HideClient
import com.joaomagdaleno.music_hub.common.clients.LikeClient
import com.joaomagdaleno.music_hub.common.clients.SaveClient
import com.joaomagdaleno.music_hub.common.clients.ShareClient
import com.joaomagdaleno.music_hub.common.helpers.PagedData
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Feed
import com.joaomagdaleno.music_hub.common.models.Feed.Companion.toFeed
import com.joaomagdaleno.music_hub.common.models.Message
import com.joaomagdaleno.music_hub.common.models.Shelf
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getIf
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.extensions.cache.Cached.getFeed
import com.joaomagdaleno.music_hub.extensions.cache.Cached.getTracks
import com.joaomagdaleno.music_hub.extensions.cache.Cached.loadFeed
import com.joaomagdaleno.music_hub.extensions.cache.Cached.loadItem
import com.joaomagdaleno.music_hub.extensions.cache.Cached.loadTracks
import com.joaomagdaleno.music_hub.ui.feed.FeedData
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted.Companion.Eagerly
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.transformLatest
import kotlinx.coroutines.launch

@OptIn(ExperimentalCoroutinesApi::class)
abstract class MediaDetailsViewModel(
    downloader: Downloader,
    private val app: App,
    private val loadFeeds: Boolean,
    extension: Flow<MusicExtension?>,
) : ViewModel() {
    val extensionFlow = extension.stateIn(viewModelScope, Eagerly, null)
    val downloadsFlow = downloader.flow

    val refreshFlow = MutableSharedFlow<Unit>()
    val cacheResultFlow = MutableStateFlow<Result<MediaState.Loaded<*>>?>(null)
    val itemResultFlow = MutableStateFlow<Result<MediaState.Loaded<*>>?>(null)

    val uiResultFlow = itemResultFlow.combine(cacheResultFlow) { item, cache ->
        item ?: cache
    }.stateIn(viewModelScope, Eagerly, null)

    val cacheExtensionItemFlow = uiResultFlow.map {
        extensionFlow.value to it?.getOrNull()?.item
    }.stateIn(viewModelScope, Eagerly, null to null)

    val extensionItemFlow = itemResultFlow.map { result ->
        extensionFlow.value to result?.getOrNull()?.item
    }.stateIn(viewModelScope, Eagerly, null to null)

    private fun trackFeed(item: EchoMediaItem, extension: Extension<*>) =
        if (item is Track) runCatching {
            PagedData.Concat(
                PagedData.Single {
                    val album = item.album?.let { loadItem(extension, it).getOrNull() ?: it }
                    listOfNotNull(album?.toShelf())
                },
                PagedData.Single {
                    if (item.artists.isEmpty()) return@Single emptyList()
                    listOf(
                        Shelf.Lists.Items(
                            item.id + "_artists",
                            app.context.getString(R.string.artists),
                            item.artists.map {
                                loadItem(extension, it).getOrNull() ?: it
                            },
                        )
                    )
                },
            ).toFeed(Feed.Buttons.EMPTY)
        } else null

    val trackCachedFlow = cacheExtensionItemFlow.transformLatest { (extension, item) ->
        emit(null)
        if (!loadFeeds) return@transformLatest
        extension ?: return@transformLatest
        val item = item ?: cacheResultFlow.value?.getOrNull()?.item ?: return@transformLatest
        val feed = trackFeed(item, extension)
            ?: getTracks(app, extension.id, item).map { feed -> feed?.map { it.toShelf() } }
        emit(feed.map {
            it ?: return@map null
            FeedData.State(extension.id, item, it)
        })
    }.stateIn(viewModelScope, Eagerly, null)

    val tracksLoadedFlow = extensionItemFlow.transformLatest { (extension, item) ->
        emit(null)
        if (!loadFeeds) return@transformLatest
        extension ?: return@transformLatest
        item ?: return@transformLatest
        val feed = trackFeed(item, extension)
            ?: loadTracks(app, extension, item).map { feed -> feed?.map { it.toShelf() } }
        emit(feed.map {
            it ?: return@map null
            FeedData.State(extension.id, item, it)
        })
    }.stateIn(viewModelScope, Eagerly, null)

    val feedCachedFlow = cacheExtensionItemFlow.transformLatest { (extension, item) ->
        emit(null)
        if (!loadFeeds) return@transformLatest
        extension ?: return@transformLatest
        val item = item ?: cacheResultFlow.value?.getOrNull()?.item ?: return@transformLatest
        val feed = getFeed(app, extension.id, item) ?: return@transformLatest
        emit(feed.map {
            FeedData.State(extension.id, item, it)
        })
    }.stateIn(viewModelScope, Eagerly, null)

    val feedLoadedFlow = extensionItemFlow.transformLatest { (extension, item) ->
        emit(null)
        if (!loadFeeds) return@transformLatest
        extension ?: return@transformLatest
        item ?: return@transformLatest
        val feed = loadFeed(app, extension, item)
        emit(feed.map {
            it ?: return@map null
            FeedData.State(extension.id, item, it)
        })
    }.stateIn(viewModelScope, Eagerly, null)

    fun refresh() = viewModelScope.launch {
        refreshFlow.emit(Unit)
    }

    abstract fun getItem(): Triple<String, EchoMediaItem, Boolean>?

    fun likeItem(liked: Boolean) = app.scope.launch {
        val item = itemResultFlow.value?.getOrNull()?.item ?: return@launch
        val extension = extensionFlow.value
        like(app, extension, item, liked)
        refresh()
    }

    fun hideItem(hidden: Boolean) = app.scope.launch {
        val item = itemResultFlow.value?.getOrNull()?.item ?: return@launch
        val extension = extensionFlow.value
        hide(app, extension, item, hidden)
        refresh()
    }

    fun followItem(followed: Boolean) = app.scope.launch {
        val item = itemResultFlow.value?.getOrNull()?.item ?: return@launch
        val extension = extensionFlow.value
        follow(app, extension, item, followed)
        refresh()
    }

    fun saveToLibrary(saved: Boolean) = app.scope.launch {
        val item = itemResultFlow.value?.getOrNull()?.item ?: return@launch
        val extension = extensionFlow.value
        save(app, extension, item, saved)
        refresh()
    }

    fun onShare() = app.scope.launch(Dispatchers.IO) {
        val item = itemResultFlow.value?.getOrNull()?.item ?: return@launch
        val extension = extensionFlow.value
        share(app, extension, item)
    }

    val isRefreshing get() = itemResultFlow.value == null
    val isRefreshingFlow = itemResultFlow.map {
        isRefreshing
    }

    companion object {

        suspend fun notFound(app: App, id: Int) {
            val notFound = app.context.run { getString(R.string.no_x_found, getString(id)) }
            app.messageFlow.emit(Message(notFound))
        }

        suspend fun createMessage(app: App, message: Context.() -> String) {
            app.messageFlow.emit(Message(app.context.message()))
        }

        suspend fun like(
            app: App, extension: Extension<*>?, item: EchoMediaItem, like: Boolean,
        ) {
            val extension = extension ?: return notFound(app, R.string.extension)
            createMessage(app) {
                getString(
                    if (like) R.string.liking_x else R.string.unliking_x,
                    item.title
                )
            }
            val result = extension.getIf<LikeClient, Unit>(app.throwFlow) {
                likeItem(item, like)
            }
            if (result != null) createMessage(app) {
                getString(
                    if (like) R.string.liked_x else R.string.unliked_x, item.title
                )
            }
        }

        suspend fun hide(
            app: App, extension: Extension<*>?, item: EchoMediaItem, hide: Boolean,
        ) {
            val extension = extension ?: return notFound(app, R.string.extension)
            createMessage(app) {
                getString(
                    if (hide) R.string.hiding_x else R.string.unhiding_x,
                    item.title
                )
            }
            val result = extension.getIf<HideClient, Unit>(app.throwFlow) {
                hideItem(item, hide)
            }
            if (result != null) createMessage(app) {
                getString(
                    if (hide) R.string.hidden_x else R.string.unhidden_x,
                    item.title
                )
            }
        }

        suspend fun follow(
            app: App, extension: Extension<*>?, item: EchoMediaItem, follow: Boolean,
        ) {
            val extension = extension ?: return notFound(app, R.string.extension)
            createMessage(app) {
                getString(
                    if (follow) R.string.following_x else R.string.unfollowing_x,
                    item.title
                )
            }
            val result = extension.getIf<FollowClient, Unit>(app.throwFlow) {
                followItem(item, follow)
            }
            if (result != null) createMessage(app) {
                getString(
                    if (follow) R.string.followed_x else R.string.unfollowed_x,
                    item.title
                )
            }
        }

        suspend fun save(
            app: App, extension: Extension<*>?, item: EchoMediaItem, save: Boolean,
        ) {
            val extension = extension ?: return notFound(app, R.string.extension)
            createMessage(app) {
                getString(
                    if (save) R.string.saving_x else R.string.removing_x,
                    item.title
                )
            }
            val result = extension.getIf<SaveClient, Unit>(app.throwFlow) {
                saveToLibrary(item, save)
            }
            if (result != null) createMessage(app) {
                getString(
                    if (save) R.string.saved_x_to_library else R.string.removed_x_from_library,
                    item.title
                )
            }
        }

        suspend fun share(
            app: App, extension: Extension<*>?, item: EchoMediaItem,
        ) {
            val extension = extension ?: return notFound(app, R.string.extension)
            createMessage(app) { getString(R.string.sharing_x, item.title) }
            val url = extension.getIf<ShareClient, String>(app.throwFlow) {
                onShare(item)
            } ?: return notFound(app, R.string.extension)
            val intent = ShareCompat.IntentBuilder(app.context)
                .setType("text/plain")
                .setChooserTitle("${extension.name} - ${item.title}")
                .setText(url)
                .createChooserIntent()
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            app.context.startActivity(intent)
        }

        private fun <T : Any> Feed<T>.map(transform: (T) -> Shelf) = Feed(tabs) { tab ->
            val data = getPagedData.invoke(tab)
            Feed.Data(
                data.pagedData.map {
                    val list = it.getOrThrow()
                    list.map(transform)
                },
                data.buttons,
                data.background
            )
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\media\MediaFragment.kt ----------
package com.joaomagdaleno.music_hub.ui.media

import android.os.Bundle
import android.view.View
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.view.isVisible
import androidx.core.view.updateLayoutParams
import androidx.fragment.app.Fragment
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.databinding.FragmentMediaBinding
import com.joaomagdaleno.music_hub.ui.common.FragmentUtils.openFragment
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyBackPressCallback
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyFabInsets
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyGradient
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyInsets
import com.joaomagdaleno.music_hub.ui.feed.viewholders.MediaViewHolder.Companion.icon
import com.joaomagdaleno.music_hub.ui.feed.viewholders.MediaViewHolder.Companion.placeHolder
import com.joaomagdaleno.music_hub.ui.media.more.MediaMoreBottomSheet
import com.joaomagdaleno.music_hub.ui.playlist.delete.DeletePlaylistBottomSheet
import com.joaomagdaleno.music_hub.ui.playlist.edit.EditPlaylistFragment
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.Serializer.getSerialized
import com.joaomagdaleno.music_hub.utils.Serializer.putSerialized
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadInto
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadWithThumb
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.setupTransition
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.configureAppBar
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.dpToPx
import org.koin.androidx.viewmodel.ext.android.viewModel
import org.koin.core.parameter.parametersOf

class MediaFragment : Fragment(R.layout.fragment_media), MediaDetailsFragment.Parent {
    companion object {
        fun getBundle(extensionId: String, item: EchoMediaItem, loaded: Boolean) = Bundle().apply {
            putString("extensionId", extensionId)
            putSerialized("item", item)
            putBoolean("loaded", loaded)
        }
    }

    val args by lazy { requireArguments() }
    val extensionId by lazy { args.getString("extensionId")!! }
    val item by lazy { args.getSerialized<EchoMediaItem>("item")!!.getOrThrow() }
    val loaded by lazy { args.getBoolean("loaded") }

    override val fromPlayer = false
    override val feedId by lazy { item.id }

    override val viewModel by viewModel<MediaViewModel> {
        parametersOf(true, extensionId, item, loaded, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val binding = FragmentMediaBinding.bind(view)
        setupTransition(view)
        applyBackPressCallback()
        binding.appBarLayout.configureAppBar { offset ->
            binding.appbarOutline.alpha = offset
            binding.coverContainer.alpha = 1 - offset
            binding.endIcon.alpha = 1 - offset
        }
        binding.toolBar.setNavigationOnClickListener {
            parentFragmentManager.popBackStack()
        }
        binding.toolBar.setOnMenuItemClickListener {
            val item = viewModel.itemResultFlow.value?.getOrNull()?.item ?: item
            MediaMoreBottomSheet.newInstance(
                id, extensionId, item, !viewModel.isRefreshing
            ).show(parentFragmentManager, null)
            true
        }
        applyInsets {
            binding.fabContainer.applyFabInsets(it, systemInsets.value)
        }

        observe(viewModel.itemResultFlow) { result ->
            val item = result?.getOrNull()?.item ?: item
            binding.toolBar.title = item.title.trim()
            binding.endIcon.setImageResource(item.icon)
            if (item is Artist) binding.coverContainer.run {
                val maxWidth = 240.dpToPx(context)
                radius = maxWidth.toFloat()
                updateLayoutParams<ConstraintLayout.LayoutParams> {
                    matchConstraintMaxWidth = maxWidth
                }
            }
            item.cover.loadInto(binding.cover, null, item.placeHolder)
            item.background.loadWithThumb(view) { applyGradient(view, it) }
            val isEditable = (result?.getOrNull()?.item as? Playlist)?.isEditable ?: false
            binding.fabEditPlaylist.isVisible = isEditable
            binding.fabEditPlaylist.setOnClickListener {
                val playlist = item as? Playlist ?: return@setOnClickListener
                openFragment<EditPlaylistFragment>(
                    it, EditPlaylistFragment.getBundle(extensionId, playlist, loaded)
                )
            }
        }
        parentFragmentManager.setFragmentResultListener("reload", this) { _, data ->
            if (data.getString("id") == item.id) viewModel.refresh()
        }
        parentFragmentManager.setFragmentResultListener("delete", this) { _, data ->
            val playlist = item as? Playlist ?: return@setFragmentResultListener
            DeletePlaylistBottomSheet.show(
                requireActivity(), extensionId, playlist, !viewModel.isRefreshing
            )
        }
        parentFragmentManager.setFragmentResultListener("deleted", this) { _, data ->
            if (data.getString("id") == item.id) parentFragmentManager.popBackStack()
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\media\MediaHeaderAdapter.kt ----------
package com.joaomagdaleno.music_hub.ui.media

import android.content.Context
import android.icu.text.CompactDecimalFormat
import android.text.SpannableString
import android.text.Spanned
import android.text.method.LinkMovementMethod
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.core.view.isVisible
import androidx.core.view.updateLayoutParams
import androidx.core.view.updatePaddingRelative
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.Album
import com.joaomagdaleno.music_hub.common.models.Album.Type.Book
import com.joaomagdaleno.music_hub.common.models.Album.Type.Compilation
import com.joaomagdaleno.music_hub.common.models.Album.Type.EP
import com.joaomagdaleno.music_hub.common.models.Album.Type.LP
import com.joaomagdaleno.music_hub.common.models.Album.Type.PreRelease
import com.joaomagdaleno.music_hub.common.models.Album.Type.Show
import com.joaomagdaleno.music_hub.common.models.Album.Type.Single
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.common.models.Radio
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.databinding.ItemLineBinding
import com.joaomagdaleno.music_hub.databinding.ItemMediaHeaderBinding
import com.joaomagdaleno.music_hub.databinding.ItemShelfErrorBinding
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.ui.common.ExceptionUtils.getFinalTitle
import com.joaomagdaleno.music_hub.ui.common.ExceptionUtils.getMessage
import com.joaomagdaleno.music_hub.ui.common.FragmentUtils.openFragment
import com.joaomagdaleno.music_hub.ui.common.GridAdapter
import com.joaomagdaleno.music_hub.ui.media.MediaFragment.Companion.getBundle
import com.joaomagdaleno.music_hub.ui.player.PlayerViewModel
import com.joaomagdaleno.music_hub.utils.ui.SimpleItemSpan
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.dpToPx
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.toTimeString
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimRecyclerAdapter
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimViewHolder

class MediaHeaderAdapter(
    private val listener: Listener,
    private val fromPlayer: Boolean,
) : ScrollAnimRecyclerAdapter<MediaHeaderAdapter.ViewHolder>(), GridAdapter {

    interface Listener {
        fun onRetry(view: View)
        fun onError(view: View, error: Throwable?)
        fun onDescriptionClicked(view: View, extensionId: String?, item: EchoMediaItem?)
        fun openMediaItem(extensionId: String, item: EchoMediaItem)
        fun onFollowClicked(view: View, follow: Boolean)
        fun onSavedClicked(view: View, saved: Boolean)
        fun onLikeClicked(view: View, liked: Boolean)
        fun onPlayClicked(view: View)
        fun onRadioClicked(view: View)
        fun onShareClicked(view: View)
        fun onHideClicked(view: View, hidden: Boolean)
    }

    override val adapter = this
    override fun getSpanSize(position: Int, width: Int, count: Int) = count
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) = when (viewType) {
        0 -> Success(parent, listener, fromPlayer)
        1 -> Error(parent, listener)
        2 -> Loading(parent)
        else -> throw IllegalArgumentException("Unknown view type: $viewType")
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        super.onBindViewHolder(holder, position)
        when (holder) {
            is Success -> {
                val state = result?.getOrNull() ?: return
                holder.bind(state)
            }

            is Error -> {
                val error = result?.exceptionOrNull() ?: return
                holder.bind(error)
            }

            is Loading -> {}
        }
    }

    override fun getItemCount() = 1
    override fun getItemViewType(position: Int) = when (result?.isSuccess) {
        true -> 0
        false -> 1
        null -> 2
    }

    var result: Result<MediaState.Loaded<*>>? = null
        set(value) {
            field = value
            notifyItemChanged(0)
        }

    sealed class ViewHolder(itemView: View) : ScrollAnimViewHolder(itemView)
    class Success(
        parent: ViewGroup,
        private val listener: Listener,
        private val fromPlayer: Boolean,
        private val binding: ItemMediaHeaderBinding = ItemMediaHeaderBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        ),
    ) : ViewHolder(binding.root) {
        val buttons = binding.run {
            listOf(
                followButton, playButton, savedButton, likeButton, hideButton,
                radioButton, shareButton
            )
        }

        init {
            binding.followButton.setOnClickListener {
                listener.onFollowClicked(it, binding.followButton.isChecked)
                it.isEnabled = false
            }
            binding.savedButton.setOnClickListener {
                listener.onSavedClicked(it, binding.savedButton.isChecked)
                it.isEnabled = false
            }
            binding.likeButton.setOnClickListener {
                listener.onLikeClicked(it, binding.likeButton.isChecked)
                it.isEnabled = false
            }
            binding.hideButton.setOnClickListener {
                listener.onHideClicked(it, binding.hideButton.isChecked)
                it.isEnabled = false
            }
            binding.playButton.setOnClickListener {
                listener.onPlayClicked(it)
            }
            binding.radioButton.setOnClickListener {
                listener.onRadioClicked(it)
            }
            binding.shareButton.setOnClickListener {
                listener.onShareClicked(it)
                it.isEnabled = false
            }
        }


        fun configureButtons() {
            val visible = buttons.filter { it.isVisible }
            binding.buttonGroup.isVisible = visible.isNotEmpty()
            val isNotOne = visible.size > 1
            visible.forEachIndexed { index, button ->
                button.isEnabled = true
                if (index == 0 && isNotOne) button.run {
                    updatePaddingRelative(
                        start = if (icon != null) 16.dpToPx(context) else 24.dpToPx(context),
                        end = 24.dpToPx(context)
                    )
                    iconPadding = 8.dpToPx(context)
                    text = contentDescription
                } else button.run {
                    updatePaddingRelative(start = 12.dpToPx(context), end = 12.dpToPx(context))
                    iconPadding = 0
                    text = null
                }
            }
            binding.buttonGroup.updateLayoutParams<ViewGroup.MarginLayoutParams> {
                width = if (isNotOne) ViewGroup.LayoutParams.MATCH_PARENT
                else ViewGroup.LayoutParams.WRAP_CONTENT
                bottomMargin = if (isNotOne) 0 else (-56).dpToPx(binding.root.context)
            }
            binding.description.updateLayoutParams<ViewGroup.MarginLayoutParams> {
                marginEnd = if (isNotOne) 0 else 48.dpToPx(binding.root.context)
            }
        }

        var clickEnabled = true
        var state: MediaState.Loaded<*>? = null

        fun bind(state: MediaState.Loaded<*>) = with(binding) {
            this@Success.state = state
            followButton.isVisible = state.isFollowed != null
            followButton.isChecked = state.isFollowed ?: false
            followButton.contentDescription = root.context.getString(
                if (state.isFollowed == true) R.string.unfollow else R.string.follow
            )

            savedButton.isVisible = state.isSaved != null
            savedButton.isChecked = state.isSaved ?: false
            savedButton.contentDescription = root.context.getString(
                if (state.isSaved == true) R.string.unsave else R.string.save
            )

            likeButton.isVisible = state.isLiked != null && !fromPlayer
            likeButton.isChecked = state.isLiked ?: false
            likeButton.contentDescription = root.context.getString(
                if (state.isLiked == true) R.string.unlike else R.string.like
            )

            hideButton.isVisible = state.isHidden != null
            hideButton.isChecked = state.isHidden ?: false
            hideButton.contentDescription = root.context.getString(
                if (state.isHidden == true) R.string.unhide else R.string.hide
            )

            playButton.isVisible = state.item is Track && !fromPlayer && state.item.isPlayable == Track.Playable.Yes
            radioButton.isVisible = state.showRadio
            shareButton.isVisible = state.showShare
            configureButtons()

            explicit.isVisible = state.item.isExplicit
            followers.isVisible = state.followers != null
            followers.text = state.followers?.let {
                val formatter = CompactDecimalFormat.getInstance()
                root.context.getString(R.string.x_followers, formatter.format(it))
            }
            val span =
                root.context.getSpan(true, state.extensionId, state.item) { id, item ->
                    clickEnabled = false
                    listener.openMediaItem(id, item)
                    description.post { clickEnabled = true }
                }
            description.text = span
            description.isVisible = span.isNotEmpty()
        }

        init {
            binding.run {
                description.movementMethod = LinkMovementMethod.getInstance()
                description.setOnClickListener {
                    if (clickEnabled) listener.onDescriptionClicked(
                        it,
                        state?.extensionId,
                        state?.item
                    )
                }
            }
        }
    }

    class Error(
        parent: ViewGroup,
        listener: Listener,
        private val binding: ItemShelfErrorBinding = ItemShelfErrorBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        ),
    ) : ViewHolder(binding.root) {
        var throwable: Throwable? = null

        init {
            binding.errorView.setOnClickListener {
                listener.onError(binding.error, throwable)
            }
            binding.retry.setOnClickListener {
                listener.onRetry(it)
            }
        }

        fun bind(throwable: Throwable) {
            this.throwable = throwable
            binding.error.run {
                transitionName = throwable.hashCode().toString()
                text = context.getFinalTitle(throwable)
            }
        }
    }

    class Loading(
        parent: ViewGroup,
        binding: ItemLineBinding = ItemLineBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        ),
    ) : ViewHolder(binding.root) {
        init {
            itemView.alpha = 0f
        }
    }

    companion object {
        private const val MAX_DESC_TEXT = 144
        private fun String.ellipsize() = if (length > MAX_DESC_TEXT) {
            substring(0, MAX_DESC_TEXT) + "..."
        } else this

        private const val DIVIDER = "  "
        fun Context.getSpan(
            compact: Boolean,
            extensionId: String,
            item: EchoMediaItem,
            openMediaItem: (String, EchoMediaItem) -> Unit = { a, b -> },
        ): SpannableString = when (item) {
            is EchoMediaItem.Lists -> {
                val madeBy = item.artists.joinToString(", ") { it.name }
                val span = SpannableString(buildString {
                    val firstRow = listOfNotNull(
                        getString(item.typeInt),
                        item.date?.toString(),
                    ).joinToString(DIVIDER)
                    val secondRow = listOfNotNull(
                        item.toTrackString(this@getSpan),
                        item.duration?.toTimeString()
                    ).joinToString(DIVIDER)
                    if (firstRow.isNotEmpty()) appendLine(firstRow)
                    if (secondRow.isNotEmpty()) appendLine(secondRow)
                    val desc = item.description
                    if (desc != null) {
                        appendLine()
                        appendLine(if (compact) desc.ellipsize() else desc)
                    }
                    if (madeBy.isNotEmpty()) {
                        appendLine()
                        appendLine(getString(R.string.by_x, madeBy))
                    }
                    if (item.label != null) {
                        appendLine()
                        appendLine(item.label)
                    }
                }.trimEnd('\n').trimStart('\n'))
                val madeByIndex = span.indexOf(madeBy)
                item.artists.forEach {
                    val start = span.indexOf(it.name, madeByIndex)
                    if (start != -1) {
                        val end = start + it.name.length
                        val clickableSpan = SimpleItemSpan(this) {
                            openMediaItem(extensionId, it)
                        }
                        span.setSpan(
                            clickableSpan, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                    }
                }
                span
            }

            is Artist -> {
                val desc = if (compact) item.bio?.ellipsize() else item.bio
                SpannableString(desc ?: "")
            }

            is Track -> {
                SpannableString(buildString {
                    val firstRow = listOfNotNull(
                        getString(
                            when (item.type) {
                                Track.Type.Song, Track.Type.VideoSong -> R.string.song
                                Track.Type.Video, Track.Type.HorizontalVideo -> R.string.video
                                Track.Type.Podcast -> R.string.podcast
                            }
                        ),
                        item.releaseDate
                    ).joinToString(DIVIDER)
                    val secondRow = listOfNotNull(
                        item.duration?.toTimeString(),
                        if (item.plays != null) {
                            val formatter = CompactDecimalFormat.getInstance()
                            getString(R.string.x_plays, formatter.format(item.plays))
                        } else null
                    ).joinToString(DIVIDER)
                    if (firstRow.isNotEmpty()) appendLine(firstRow)
                    if (secondRow.isNotEmpty()) appendLine(secondRow)
                    val notPlayable = item.playableString(this@getSpan)
                    if (!notPlayable.isNullOrEmpty()) {
                        appendLine()
                        appendLine(notPlayable)
                    }
                    val desc = item.description
                    if (desc != null) {
                        appendLine()
                        appendLine(if (compact) desc.ellipsize() else desc)
                        appendLine()
                    }
                    val genres = item.genres.joinToString(", ")
                    if (genres.isNotEmpty()) {
                        appendLine(getString(R.string.genres_x, genres))
                    }
                    val isrc = item.isrc
                    if (isrc != null) {
                        appendLine(getString(R.string.isrc_x, isrc))
                    }
                    val label = item.album?.label
                    if (label != null) {
                        appendLine()
                        appendLine(label)
                    }
                    val lastRow = listOfNotNull(
                        item.albumDiscNumber?.let {
                            getString(R.string.disc_number_n, it)
                        },
                        item.albumOrderNumber?.let {
                            getString(R.string.album_order_n, it)
                        }
                    ).joinToString(DIVIDER)
                    if (lastRow.isNotEmpty()) {
                        appendLine()
                        appendLine(lastRow)
                    }
                }.trimStart('\n').trimEnd('\n'))
            }
        }

        fun Context.unfuckedString(
            numberStringId: Int, nStringId: Int, count: Int,
        ) = runCatching {
            resources.getQuantityString(numberStringId, count, count)
        }.getOrNull() ?: getString(nStringId, count)

        fun Fragment.getMediaHeaderListener(viewModel: MediaDetailsViewModel) = object : Listener {
            override fun onRetry(view: View) {
                viewModel.refresh()
            }

            override fun onError(view: View, error: Throwable?) {
                error ?: return
                requireActivity().getMessage(error, view).action?.handler?.invoke()
            }

            override fun openMediaItem(extensionId: String, item: EchoMediaItem) {
                openFragment<MediaFragment>(null, getBundle(extensionId, item, false))
            }

            override fun onFollowClicked(view: View, follow: Boolean) {
                viewModel.followItem(follow)
            }

            override fun onSavedClicked(view: View, saved: Boolean) {
                viewModel.saveToLibrary(saved)
            }

            override fun onLikeClicked(view: View, liked: Boolean) {
                viewModel.likeItem(liked)
            }

            override fun onHideClicked(view: View, hidden: Boolean) {
                viewModel.hideItem(hidden)
            }

            override fun onPlayClicked(view: View) {
                val (extensionId, item, loaded) = viewModel.getItem() ?: return
                val vm by activityViewModels<PlayerViewModel>()
                vm.play(extensionId, item, loaded)
            }

            override fun onRadioClicked(view: View) {
                val (extensionId, item, loaded) = viewModel.getItem() ?: return
                val vm by activityViewModels<PlayerViewModel>()
                vm.radio(extensionId, item, loaded)
            }

            override fun onShareClicked(view: View) {
                viewModel.onShare()
            }

            override fun onDescriptionClicked(
                view: View, extensionId: String?, item: EchoMediaItem?,
            ) {
                item ?: return
                extensionId ?: return
                val context = requireContext()
                var dialog: AlertDialog? = null
                val builder = MaterialAlertDialogBuilder(context)
                builder.setTitle(item.title)
                builder.setMessage(context.getSpan(false, extensionId, item) { m, n ->
                    openMediaItem(m, n)
                    dialog?.dismiss()
                })
                builder.setPositiveButton(getString(R.string.okay)) { d, _ ->
                    d.dismiss()
                }
                dialog = builder.create()
                dialog.show()
                val text = dialog.findViewById<TextView>(android.R.id.message)!!
                text.movementMethod = LinkMovementMethod.getInstance()
            }
        }

        val EchoMediaItem.Lists.typeInt
            get() = when (this) {
                is Album -> when (type) {
                    PreRelease -> R.string.pre_release
                    Single -> R.string.single
                    EP -> R.string.ep
                    LP -> R.string.lp
                    Compilation -> R.string.compilation
                    Show -> R.string.show
                    Book -> R.string.book
                    null -> R.string.album
                }

                is Playlist -> R.string.playlist
                is Radio -> R.string.radio
            }

        fun EchoMediaItem.Lists.toTrackString(context: Context) = context.run {
            val tracks = trackCount?.toInt()
            if (tracks != null) {
                when (type) {
                    PreRelease, Single, EP, LP, Compilation -> unfuckedString(
                        R.plurals.number_songs, R.string.n_songs, tracks
                    )

                    Show -> unfuckedString(
                        R.plurals.number_episodes, R.string.n_episodes, tracks
                    )

                    Book -> unfuckedString(
                        R.plurals.number_chapters, R.string.n_chapters, tracks
                    )

                    null -> unfuckedString(
                        R.plurals.number_tracks, R.string.n_tracks, tracks
                    )
                }
            } else null
        }

        fun Track.playableString(context: Context) = when (val play = isPlayable) {
            is Track.Playable.No -> context.getString(R.string.not_playable_x, play.reason)
            Track.Playable.Yes -> null
            Track.Playable.RegionLocked -> context.getString(R.string.unavailable_in_your_region)
            Track.Playable.Unreleased -> if (releaseDate != null) context.getString(
                R.string.releases_on_x, releaseDate.toString()
            ) else context.getString(R.string.not_yet_released)
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\media\MediaViewModel.kt ----------
package com.joaomagdaleno.music_hub.ui.media

import androidx.lifecycle.viewModelScope
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.extensions.cache.Cached
import com.joaomagdaleno.music_hub.extensions.cache.Cached.loadMedia
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.merge
import kotlinx.coroutines.launch

class MediaViewModel(
    extensionLoader: ExtensionLoader,
    downloader: Downloader,
    val app: App,
    loadFeeds: Boolean,
    val extensionId: String,
    val item: EchoMediaItem,
    val loaded: Boolean,
) : MediaDetailsViewModel(
    downloader, app, loadFeeds,
    extensionLoader.music.map { list -> list.find { it.id == extensionId } }
) {

    override fun getItem(): Triple<String, EchoMediaItem, Boolean> {
        val result = itemResultFlow.value?.getOrNull()?.item
        return Triple(
            extensionId,
            result ?: item,
            loaded || result != null
        )
    }

    init {
        var force = false
        viewModelScope.launch(Dispatchers.IO) {
            listOf(extensionFlow, refreshFlow).merge().collectLatest {
                itemResultFlow.value = null
                cacheResultFlow.value = null
                cacheResultFlow.value = Cached.getMedia<EchoMediaItem>(app, extensionId, item.id)
                    .getOrNull()?.let { Result.success(it) }
                val extension = extensionFlow.value ?: return@collectLatest
                itemResultFlow.value = loadMedia(
                    app, extension, MediaState.Unloaded(extension.id, item)
                )
                force = true
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\media\more\MediaMoreBottomSheet.kt ----------
package com.joaomagdaleno.music_hub.ui.media.more

import android.os.Bundle
import android.view.View
import androidx.fragment.app.Fragment
import androidx.paging.LoadState
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.clients.ExtensionClient
import com.joaomagdaleno.music_hub.common.clients.PlaylistEditClient
import com.joaomagdaleno.music_hub.common.clients.TrackClient
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Playlist
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.databinding.DialogMediaMoreBinding
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.extensions.builtin.offline.OfflineExtension
import com.joaomagdaleno.music_hub.extensions.builtin.unified.UnifiedExtension.Companion.EXTENSION_ID
import com.joaomagdaleno.music_hub.ui.common.FragmentUtils.openFragment
import com.joaomagdaleno.music_hub.ui.common.GridAdapter
import com.joaomagdaleno.music_hub.ui.common.GridAdapter.Companion.configureGridLayout
import com.joaomagdaleno.music_hub.ui.download.DownloadViewModel
import com.joaomagdaleno.music_hub.ui.feed.FeedLoadingAdapter
import com.joaomagdaleno.music_hub.ui.feed.FeedLoadingAdapter.Companion.createListener
import com.joaomagdaleno.music_hub.ui.feed.viewholders.MediaViewHolder.Companion.icon
import com.joaomagdaleno.music_hub.ui.media.MediaFragment
import com.joaomagdaleno.music_hub.ui.media.MediaViewModel
import com.joaomagdaleno.music_hub.ui.media.more.MoreButton.Companion.button
import com.joaomagdaleno.music_hub.ui.player.PlayerViewModel
import com.joaomagdaleno.music_hub.ui.player.audiofx.AudioEffectsBottomSheet
import com.joaomagdaleno.music_hub.ui.player.more.lyrics.LyricsItemAdapter
import com.joaomagdaleno.music_hub.ui.player.quality.QualitySelectionBottomSheet
import com.joaomagdaleno.music_hub.ui.player.sleep.SleepTimerBottomSheet
import com.joaomagdaleno.music_hub.ui.playlist.delete.DeletePlaylistBottomSheet
import com.joaomagdaleno.music_hub.ui.playlist.edit.EditPlaylistBottomSheet
import com.joaomagdaleno.music_hub.ui.playlist.edit.EditPlaylistFragment
import com.joaomagdaleno.music_hub.ui.playlist.save.SaveToPlaylistBottomSheet
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.Serializer.getSerialized
import com.joaomagdaleno.music_hub.utils.Serializer.putSerialized
import kotlinx.coroutines.flow.combine
import org.koin.androidx.viewmodel.ext.android.activityViewModel
import org.koin.androidx.viewmodel.ext.android.viewModel
import org.koin.core.parameter.parametersOf

class MediaMoreBottomSheet : BottomSheetDialogFragment(R.layout.dialog_media_more) {
    companion object {
        fun newInstance(
            contId: Int,
            extensionId: String,
            item: EchoMediaItem,
            loaded: Boolean,
            fromPlayer: Boolean = false,
            context: EchoMediaItem? = null,
            tabId: String? = null,
            pos: Int? = null,
        ) = MediaMoreBottomSheet().apply {
            arguments = Bundle().apply {
                putInt("contId", contId)
                putString("extensionId", extensionId)
                putSerialized("item", item)
                putBoolean("loaded", loaded)
                putSerialized("context", context)
                putBoolean("fromPlayer", fromPlayer)
                putString("tabId", tabId)
                putInt("pos", pos ?: -1)
            }
        }
    }

    private val args by lazy { requireArguments() }
    private val contId by lazy { args.getInt("contId", -1).takeIf { it != -1 }!! }
    private val extensionId by lazy { args.getString("extensionId")!! }
    private val item by lazy { args.getSerialized<EchoMediaItem>("item")!!.getOrThrow() }
    private val loaded by lazy { args.getBoolean("loaded") }
    private val itemContext by lazy { args.getSerialized<EchoMediaItem?>("context")?.getOrThrow() }
    private val tabId by lazy { args.getString("tabId") }
    private val pos by lazy { args.getInt("pos") }
    private val fromPlayer by lazy { args.getBoolean("fromPlayer") }
    private val delete by lazy { args.getBoolean("delete", false) }

    private val vm by viewModel<MediaViewModel> {
        parametersOf(false, extensionId, item, loaded, delete)
    }
    private val playerViewModel by activityViewModel<PlayerViewModel>()

    private val actionAdapter by lazy { MoreButtonAdapter() }
    private val headerAdapter by lazy {
        MoreHeaderAdapter({ dismiss() }, {
            openItemFragment(extensionId, item, loaded)
            dismiss()
        })
    }

    private val loadingAdapter by lazy {
        FeedLoadingAdapter(createListener { vm.refresh() }) {
            val holder = LyricsItemAdapter.Loading(it)
            holder
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val binding = DialogMediaMoreBinding.bind(view)
        observe(playerViewModel.playerState.current) {
            headerAdapter.onCurrentChanged(it)
        }
        val actionFlow =
            combine(vm.downloadsFlow, vm.uiResultFlow) { _, _ -> }
        observe(actionFlow) {
            val client = vm.extensionFlow.value?.instance?.value()?.getOrNull()
            val result = vm.uiResultFlow.value?.getOrNull()
            val downloads = vm.downloadsFlow.value.filter { it.download.finalFile != null }
            val loaded = if (result != null) true else loaded
            val list = getButtons(client, result, loaded, downloads)
            actionAdapter.submitList(list)
            headerAdapter.item = result?.item ?: item
        }
        observe(vm.itemResultFlow) { result ->
            loadingAdapter.loadState = result?.map { LoadState.NotLoading(false) }?.getOrElse {
                LoadState.Error(it)
            } ?: LoadState.Loading
        }
        configureGridLayout(
            binding.root,
            GridAdapter.Concat(
                headerAdapter,
                actionAdapter,
                loadingAdapter
            )
        )
    }

    private fun getButtons(
        client: ExtensionClient?,
        state: MediaState.Loaded<*>?,
        loaded: Boolean,
        downloads: List<Downloader.Info>
    ) = getPlayerButtons() +
            getPlayButtons(client, state?.item ?: item, loaded) +
            getPlaylistEditButtons(client, state, loaded) +
            getDownloadButtons(client, state, downloads) +
            getActionButtons(state) +
            getItemButtons(state?.item ?: item)

    private fun getPlayerButtons() = if (fromPlayer) listOf(
        button("audio_fx", R.string.audio_fx, R.drawable.ic_equalizer) {
            AudioEffectsBottomSheet().show(parentFragmentManager, null)
        },
        button("sleep_timer", R.string.sleep_timer, R.drawable.ic_snooze) {
            SleepTimerBottomSheet().show(parentFragmentManager, null)
        },
        button("quality_selection", R.string.quality_selection, R.drawable.ic_high_quality) {
            QualitySelectionBottomSheet().show(parentFragmentManager, null)
        }
    ) else listOf()

    private fun getPlayButtons(
        client: ExtensionClient?, item: EchoMediaItem, loaded: Boolean
    ) = if (client is TrackClient) listOfNotNull(
        button("play", R.string.play, R.drawable.ic_play) {
            playerViewModel.play(extensionId, item, loaded)
        },
        if (playerViewModel.queue.isNotEmpty())
            button("next", R.string.add_to_next, R.drawable.ic_playlist_play) {
                playerViewModel.addToNext(extensionId, item, loaded)
            }
        else null,
        if (playerViewModel.queue.size > 1)
            button("queue", R.string.add_to_queue, R.drawable.ic_playlist_add) {
                playerViewModel.addToQueue(extensionId, item, loaded)
            }
        else null
    ) else listOf()

    fun getPlaylistEditButtons(
        client: ExtensionClient?, state: MediaState<*>?, loaded: Boolean
    ) = run {
        if (client !is PlaylistEditClient) return@run listOf()
        val item = state?.item ?: item
        val isEditable = item is Playlist && item.isEditable
        listOfNotNull(
            if (loaded) button(
                "save_to_playlist", R.string.save_to_playlist, R.drawable.ic_library_music
            ) {
                SaveToPlaylistBottomSheet.newInstance(extensionId, item)
                    .show(parentFragmentManager, null)
            } else null,
            if (isEditable) button(
                "edit_playlist", R.string.edit_playlist, R.drawable.ic_edit_note
            ) {
                openFragment<EditPlaylistFragment>(
                    EditPlaylistFragment.getBundle(extensionId, item, loaded)
                )
            } else null,
            if (isEditable) button(
                "delete_playlist", R.string.delete_playlist, R.drawable.ic_delete
            ) {
                DeletePlaylistBottomSheet.show(requireActivity(), extensionId, item, loaded)
            } else null,
            if ((itemContext as? Playlist)?.isEditable == true && item is Track) button(
                "remove_from_playlist", R.string.remove, R.drawable.ic_cancel
            ) {
                EditPlaylistBottomSheet.newInstance(
                    extensionId, itemContext as Playlist, tabId, pos
                ).show(parentFragmentManager, null)
            } else null
        )
    }

    fun getDownloadButtons(
        client: ExtensionClient?, state: MediaState<*>?, downloads: List<Downloader.Info>
    ) = run {
        val item = state?.item ?: item
        val shouldShowDelete = when (item) {
            is Track -> downloads.any { it.download.trackId == item.id }
            else -> downloads.any { it.context?.itemId == item.id }
        }
        val downloadable =
            state != null && client is TrackClient && state.item.extras[EXTENSION_ID] != OfflineExtension.metadata.id

        listOfNotNull(
            if (downloadable) button(
                "download", R.string.download, R.drawable.ic_download_for_offline
            ) {
                val downloadViewModel by activityViewModel<DownloadViewModel>()
                downloadViewModel.addToDownload(requireActivity(), extensionId, item, itemContext)
            } else null,
            if (shouldShowDelete) button(
                "delete_download", R.string.delete_download, R.drawable.ic_scan_delete
            ) {
                val downloadViewModel by activityViewModel<DownloadViewModel>()
                downloadViewModel.deleteDownload(item)
            } else null
        )

    }

    fun getActionButtons(
        state: MediaState.Loaded<*>?,
    ) = listOfNotNull(
        if (state?.isFollowed != null) button(
            "follow", if (state.isFollowed) R.string.unfollow else R.string.follow,
            if (state.isFollowed) R.drawable.ic_check_circle_filled else R.drawable.ic_check_circle
        ) {
            vm.followItem(!state.isFollowed)
        } else null,
        if (state?.isSaved != null) button(
            "save_to_library",
            if (state.isSaved) R.string.remove_from_library else R.string.save_to_library,
            if (state.isSaved) R.drawable.ic_bookmark_filled else R.drawable.ic_bookmark_outline
        ) {
            vm.saveToLibrary(!state.isSaved)
        } else null,
        if (state?.isLiked != null) button(
            "like", if (state.isLiked) R.string.unlike else R.string.like,
            if (state.isLiked) R.drawable.ic_heart_filled_40dp else R.drawable.ic_heart_outline_40dp
        ) {
            vm.likeItem(!state.isLiked)
        } else null,
        if (state?.isHidden != null) button(
            "hide", if (state.isHidden) R.string.unhide else R.string.hide,
            if (state.isHidden) R.drawable.ic_unhide else R.drawable.ic_hide
        ) {
            vm.hideItem(!state.isHidden)
        } else null,
        if (state?.showRadio == true) button(
            "radio", R.string.radio, R.drawable.ic_sensors
        ) {
            playerViewModel.radio(extensionId, state.item, true)
        } else null,
        if (state?.showShare == true) button(
            "share", R.string.share, R.drawable.ic_share
        ) {
            vm.onShare()
        } else null
    )

    private fun getItemButtons(item: EchoMediaItem) = when (item) {
        is Track -> item.artists + listOfNotNull(item.album)
        is EchoMediaItem.Lists -> item.artists
        is Artist -> listOf()
    }.map {
        button(it.id, it.title, it.icon) {
            openItemFragment(extensionId, it)
        }
    }

    private inline fun <reified T : Fragment> openFragment(bundle: Bundle) {
        parentFragmentManager.findFragmentById(contId)!!
            .openFragment<T>(null, bundle)
    }

    private fun openItemFragment(
        extensionId: String?, item: EchoMediaItem?, loaded: Boolean = false
    ) {
        extensionId ?: return
        item ?: return
        openFragment<MediaFragment>(MediaFragment.getBundle(extensionId, item, loaded))
        dismiss()
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\media\more\MoreButton.kt ----------
package com.joaomagdaleno.music_hub.ui.media.more

import androidx.fragment.app.DialogFragment
import androidx.recyclerview.widget.DiffUtil

data class MoreButton(
    val id: String, val title: String, val icon: Int, val onClick: () -> Unit
) {
    object DiffCallback : DiffUtil.ItemCallback<MoreButton>() {
        override fun areItemsTheSame(oldItem: MoreButton, newItem: MoreButton) =
            oldItem.id == newItem.id

        override fun areContentsTheSame(oldItem: MoreButton, newItem: MoreButton) =
            oldItem == newItem
    }

    companion object {
        fun DialogFragment.button(
            id: String, title: String, icon: Int, onClick: () -> Unit
        ) = MoreButton(id, title, icon) {
            onClick()
            dismiss()
        }

        fun DialogFragment.button(
            id: String, title: Int, icon: Int, onClick: () -> Unit
        ) = button(id, getString(title), icon, onClick)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\media\more\MoreButtonAdapter.kt ----------
package com.joaomagdaleno.music_hub.ui.media.more

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.ListAdapter
import com.joaomagdaleno.music_hub.databinding.ItemMoreButtonBinding
import com.joaomagdaleno.music_hub.ui.common.GridAdapter
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimViewHolder

class MoreButtonAdapter
    : ListAdapter<MoreButton, MoreButtonAdapter.ViewHolder>(MoreButton.DiffCallback), GridAdapter {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) = ViewHolder(parent)
    override fun onBindViewHolder(holder: ViewHolder, position: Int) =
        holder.bind(getItem(position))

    override val adapter = this
    override fun getSpanSize(position: Int, width: Int, count: Int) = 1

    class ViewHolder(
        parent: ViewGroup,
        val binding: ItemMoreButtonBinding = ItemMoreButtonBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        )
    ) : ScrollAnimViewHolder(binding.root) {
        fun bind(item: MoreButton) = with(binding.root) {
            text = item.title
            setOnClickListener { item.onClick() }
            setIconResource(item.icon)
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\media\more\MoreHeaderAdapter.kt ----------
package com.joaomagdaleno.music_hub.ui.media.more

import android.graphics.drawable.Animatable
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.recyclerview.widget.RecyclerView
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.Artist
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.databinding.ItemMoreHeaderBinding
import com.joaomagdaleno.music_hub.playback.PlayerState
import com.joaomagdaleno.music_hub.playback.PlayerState.Current.Companion.isPlaying
import com.joaomagdaleno.music_hub.ui.common.GridAdapter
import com.joaomagdaleno.music_hub.ui.feed.viewholders.MediaViewHolder.Companion.applyCover
import com.joaomagdaleno.music_hub.ui.media.MediaHeaderAdapter.Companion.typeInt
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimViewHolder

class MoreHeaderAdapter(
    private val onCloseClicked: () -> Unit,
    private val onItemClicked: () -> Unit
) : RecyclerView.Adapter<MoreHeaderAdapter.ViewHolder>(), GridAdapter {
    override val adapter = this
    override fun getSpanSize(position: Int, width: Int, count: Int) = count
    override fun getItemCount() = 1
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val holder = ViewHolder(parent)
        holder.binding.run {
            coverContainer.cover.clipToOutline = true
            coverContainer.root.setOnClickListener { onItemClicked() }
            closeButton.setOnClickListener { onCloseClicked() }
        }
        return holder
    }

    var item: EchoMediaItem? = null
        set(value) {
            field = value
            notifyItemChanged(0)
        }

    private var viewHolder: ViewHolder? = null
    override fun onBindViewHolder(holder: ViewHolder, position: Int) = with(holder.binding) {
        viewHolder = holder
        val item = item
        holder.bind(item)
        holder.onCurrentChanged(item, current)
    }

    class ViewHolder(
        parent: ViewGroup,
        val binding: ItemMoreHeaderBinding = ItemMoreHeaderBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        )
    ) : ScrollAnimViewHolder(binding.root) {

        fun bind(item: EchoMediaItem?) = with(binding) {
            if (item == null) return@with
            title.text = item.title
            type.text = when (item) {
                is Artist -> ""
                is EchoMediaItem.Lists -> root.context.getString(item.typeInt)
                is Track -> root.context.getString(R.string.track)
            }
            coverContainer.run { applyCover(item, cover, listBg1, listBg2, icon) }
        }

        fun onCurrentChanged(item: EchoMediaItem?, current: PlayerState.Current?) {
            binding.coverContainer.isPlaying.run {
                val isPlaying = current.isPlaying(item?.id)
                isVisible = isPlaying
                (icon as Animatable).start()
            }
        }
    }

    var current: PlayerState.Current? = null
    fun onCurrentChanged(current: PlayerState.Current?) {
        this.current = current
        viewHolder?.onCurrentChanged(item, current)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\PlayerColors.kt ----------
package com.joaomagdaleno.music_hub.ui.player

import android.content.Context
import android.graphics.Bitmap
import androidx.palette.graphics.Palette
import com.google.android.material.color.MaterialColors
import com.joaomagdaleno.music_hub.MainActivity.Companion.isAmoled
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.isNightMode

data class PlayerColors(
    val background: Int,
    val accent: Int,
    val onBackground: Int,
) {
    companion object {
        fun Context.getColorsFrom(bitmap: Bitmap?): PlayerColors? {
            bitmap ?: return null
            val palette = Palette.from(bitmap).generate()
            return if (!isAmoled()) {
                val lightMode = !isNightMode()
                val lightSwatch = palette.run {
                    lightVibrantSwatch ?: vibrantSwatch ?: lightMutedSwatch
                }
                val darkSwatch = palette.run {
                    darkVibrantSwatch ?: darkMutedSwatch ?: mutedSwatch
                }
                val bgSwatch = if (lightMode) lightSwatch else darkSwatch
                val accentSwatch = if (lightMode) darkSwatch else lightSwatch
                bgSwatch?.run {
                    PlayerColors(rgb, accentSwatch?.rgb ?: titleTextColor, bodyTextColor)
                }
            } else defaultPlayerColors().let { default ->
                val dominantColor = palette.run {
                    vibrantSwatch?.rgb ?: getDominantColor(0).takeIf { it != 0 }
                } ?: return null
                PlayerColors(default.background, dominantColor, default.onBackground)
            }
        }

        fun Context.defaultPlayerColors(): PlayerColors {
            val background = MaterialColors.getColor(
                this, R.attr.navBackground, 0
            )
            val primary = MaterialColors.getColor(
                this, androidx.appcompat.R.attr.colorPrimary, 0
            )
            val onSurface = MaterialColors.getColor(
                this, com.google.android.material.R.attr.colorOnSurface, 0
            )
            return PlayerColors(background, primary, onSurface)
        }

        fun getDominantColor(bitmap: Bitmap): Int {
            return Palette.from(bitmap).generate().getDominantColor(0)
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\PlayerFragment.kt ----------
package com.joaomagdaleno.music_hub.ui.player

import android.content.Context
import android.content.res.ColorStateList
import android.graphics.Color
import android.graphics.Outline
import android.graphics.drawable.Animatable
import android.graphics.drawable.AnimatedVectorDrawable
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.text.SpannableString
import android.text.Spanned
import android.text.method.LinkMovementMethod
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.ViewOutlineProvider
import android.widget.ProgressBar
import androidx.annotation.OptIn
import androidx.appcompat.content.res.AppCompatResources
import androidx.core.graphics.drawable.toBitmap
import androidx.core.net.toUri
import androidx.core.view.doOnLayout
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.media3.common.C
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.common.Player.REPEAT_MODE_ALL
import androidx.media3.common.Player.REPEAT_MODE_OFF
import androidx.media3.common.Player.REPEAT_MODE_ONE
import androidx.media3.common.util.UnstableApi
import androidx.media3.datasource.DefaultHttpDataSource
import androidx.media3.datasource.cache.CacheDataSource
import androidx.media3.datasource.cache.SimpleCache
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.exoplayer.source.DefaultMediaSourceFactory
import androidx.media3.ui.AspectRatioFrameLayout.RESIZE_MODE_FIT
import androidx.media3.ui.AspectRatioFrameLayout.RESIZE_MODE_ZOOM
import androidx.media3.ui.CaptionStyleCompat
import androidx.media3.ui.CaptionStyleCompat.EDGE_TYPE_OUTLINE
import com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_COLLAPSED
import com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_EXPANDED
import com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_HIDDEN
import com.google.android.material.slider.Slider
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.databinding.FragmentPlayerBinding
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.background
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.context
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.extensionId
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.isLiked
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.isLoaded
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.showBackground
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.ui.common.FragmentUtils.openFragment
import com.joaomagdaleno.music_hub.ui.common.UiViewModel
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyHorizontalInsets
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyInsets
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.isFinalState
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.setupPlayerMoreBehavior
import com.joaomagdaleno.music_hub.ui.media.MediaFragment
import com.joaomagdaleno.music_hub.ui.media.more.MediaMoreBottomSheet
import com.joaomagdaleno.music_hub.ui.player.PlayerColors.Companion.defaultPlayerColors
import com.joaomagdaleno.music_hub.ui.player.PlayerColors.Companion.getColorsFrom
import com.joaomagdaleno.music_hub.ui.player.PlayerTrackAdapter.Companion.configureClicking
import com.joaomagdaleno.music_hub.ui.player.quality.FormatUtils.getDetails
import com.joaomagdaleno.music_hub.ui.player.quality.QualitySelectionBottomSheet
import com.joaomagdaleno.music_hub.utils.ContextUtils.emit
import com.joaomagdaleno.music_hub.utils.ContextUtils.getSettings
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadBlurred
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.animateVisibility
import com.joaomagdaleno.music_hub.utils.ui.AutoClearedValue.Companion.autoClearedNullable
import com.joaomagdaleno.music_hub.utils.ui.CheckBoxListener
import com.joaomagdaleno.music_hub.utils.ui.SimpleItemSpan
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.dpToPx
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.hideSystemUi
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.isLandscape
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.isRTL
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.marquee
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.toTimeString
import com.joaomagdaleno.music_hub.utils.ui.ViewPager2Utils.registerOnUserPageChangeCallback
import com.joaomagdaleno.music_hub.utils.ui.ViewPager2Utils.supportBottomSheetBehavior
import kotlinx.coroutines.launch
import org.koin.androidx.viewmodel.ext.android.activityViewModel
import kotlin.math.abs
import kotlin.math.max
import kotlin.math.min

class PlayerFragment : Fragment() {
    private var binding by autoClearedNullable<FragmentPlayerBinding>()
    private val viewModel by activityViewModel<PlayerViewModel>()
    private val uiViewModel by activityViewModel<UiViewModel>()
    private val adapter by lazy {
        PlayerTrackAdapter(uiViewModel, viewModel.playerState.current, adapterListener)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?,
    ): View {
        binding = FragmentPlayerBinding.inflate(inflater, container, false)
        return binding!!.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val binding = binding!!
        binding.viewPager.supportBottomSheetBehavior()
        setupPlayerMoreBehavior(uiViewModel, binding.playerMoreContainer)
        configureOutline(binding.root)
        configureCollapsing(binding)
        configureColors()
        configurePlayerControls()
        configureBackgroundPlayerView()
    }

    private val collapseHeight by lazy {
        resources.getDimension(R.dimen.collapsed_cover_size).toInt()
    }

    private fun configureOutline(view: View) {
        val padding = 8.dpToPx(requireContext())
        var currHeight = collapseHeight
        var currRound = padding.toFloat()
        var currRight = 0
        var currLeft = 0
        view.outlineProvider = object : ViewOutlineProvider() {
            override fun getOutline(view: View, outline: Outline) {
                outline.setRoundRect(
                    currLeft, 0, currRight, currHeight, currRound
                )
            }
        }
        view.clipToOutline = true

        var leftPadding = 0
        var rightPadding = 0

        val maxElevation = 4.dpToPx(requireContext()).toFloat()
        fun updateOutline() {
            val offset = max(0f, uiViewModel.playerSheetOffset.value)
            val inv = 1 - offset
            view.elevation = maxElevation * inv
            currHeight = collapseHeight + ((view.height - collapseHeight) * offset).toInt()
            currLeft = (leftPadding * inv).toInt()
            currRight = view.width - (rightPadding * inv).toInt()
            currRound = max(padding * inv, padding * uiViewModel.playerBackProgress.value * 2)
            view.invalidateOutline()
        }
        observe(uiViewModel.combined) {
            leftPadding = (if (view.context.isRTL()) it.end else it.start) + padding
            rightPadding = (if (view.context.isRTL()) it.start else it.end) + padding
            updateOutline()
        }
        observe(uiViewModel.playerBackProgress) { updateOutline() }
        observe(uiViewModel.playerSheetOffset) { updateOutline() }
        view.doOnLayout { updateOutline() }
    }

    private fun configureCollapsing(binding: FragmentPlayerBinding) {
        binding.playerCollapsedContainer.root.clipToOutline = true

        val collapsedTopPadding = 8.dpToPx(requireContext())
        var currRound = collapsedTopPadding.toFloat()
        var currTop = 0
        var currBottom = collapseHeight
        var currRight = 0
        var currLeft = 0

        val view = binding.viewPager
        view.outlineProvider = object : ViewOutlineProvider() {
            override fun getOutline(view: View, outline: Outline) {
                outline.setRoundRect(
                    currLeft, currTop, currRight, currBottom, currRound
                )
            }
        }
        view.clipToOutline = true

        val extraEndPadding = 108.dpToPx(requireContext())
        var leftPadding = 0
        var rightPadding = 0
        val isLandscape = requireContext().isLandscape()
        fun updateCollapsed() {
            val (collapsedY, offset, collapsedOffset) = uiViewModel.run {
                if (playerSheetState.value == STATE_EXPANDED) {
                    val offset = moreSheetOffset.value
                    Triple(systemInsets.value.top, offset, if (isLandscape) 0f else offset)
                } else {
                    val offset = 1 - max(0f, playerSheetOffset.value)
                    Triple(-collapsedTopPadding, offset, offset)
                }
            }
            val collapsedInv = 1 - collapsedOffset
            binding.playerCollapsedContainer.root.run {
                translationY = collapsedY - collapseHeight * collapsedInv * 2
                alpha = collapsedOffset * 2
                translationZ = -1f * collapsedInv
            }
            binding.bgCollapsed.run {
                translationY = collapsedY - collapseHeight * collapsedInv * 2
                alpha = min(1f, collapsedOffset * 2) - 0.5f
            }
            val alphaInv = 1 - min(1f, offset * 3)
            binding.expandedToolbar.run {
                translationY = collapseHeight * offset * 2
                alpha = alphaInv
                isVisible = offset < 1
                translationZ = -1f * offset
            }
            binding.playerControls.root.run {
                translationY = collapseHeight * offset * 2
                alpha = alphaInv
                isVisible = offset < 1
            }
            currTop = uiViewModel.run {
                val top = if (playerSheetState.value != STATE_EXPANDED) 0
                else collapsedTopPadding + systemInsets.value.top
                (top * max(0f, (collapsedOffset - 0.75f) * 4)).toInt()
            }
            val bot = currTop + collapseHeight
            currBottom = bot + ((view.height - bot) * collapsedInv).toInt()
            currLeft = (leftPadding * collapsedOffset).toInt()
            currRight = view.width - (rightPadding * collapsedOffset).toInt()
            currRound = collapsedTopPadding * collapsedOffset
            view.invalidateOutline()
        }

        view.doOnLayout { updateCollapsed() }
        observe(uiViewModel.combined) {
            val system = uiViewModel.systemInsets.value
            binding.constraintLayout.applyInsets(system, 64, 0)
            binding.expandedToolbar.applyInsets(system)
            val insets = uiViewModel.run {
                if (playerSheetState.value == STATE_EXPANDED) system
                else getCombined()
            }
            binding.playerCollapsedContainer.root.applyHorizontalInsets(insets)
            binding.playerControls.root.applyHorizontalInsets(
                insets,
                requireActivity().isLandscape()
            )
            val left = if (requireContext().isRTL()) system.end + extraEndPadding else system.start
            leftPadding = collapsedTopPadding + left
            val right = if (requireContext().isRTL()) system.start else system.end + extraEndPadding
            rightPadding = collapsedTopPadding + right
            updateCollapsed()
            adapter.insetsUpdated()
        }

        observe(uiViewModel.moreSheetOffset) {
            updateCollapsed()
            adapter.moreOffsetUpdated()
        }
        observe(uiViewModel.playerSheetOffset) {
            updateCollapsed()
            adapter.playerOffsetUpdated()

            viewModel.browser.value?.volume = 1 + min(0f, it)
            if (it < 1)
                requireActivity().hideSystemUi(false)
            else if (uiViewModel.playerBgVisible.value)
                requireActivity().hideSystemUi(true)
        }

        observe(uiViewModel.playerSheetState) {
            updateCollapsed()
            if (isFinalState(it)) adapter.playerSheetStateUpdated()
            if (it == STATE_HIDDEN) viewModel.clearQueue()
            else if (it == STATE_COLLAPSED) emit(uiViewModel.playerBgVisible, false)
        }

        binding.playerControls.root.doOnLayout {
            uiViewModel.playerControlsHeight.value = it.height
            adapter.playerControlsHeightUpdated()
        }
        observe(uiViewModel.playerBgVisible) {
            binding.fgContainer.animateVisibility(!it)
            binding.playerMoreContainer.animateVisibility(!it)
            requireActivity().hideSystemUi(it)
        }
        binding.bgPanel.configureClicking(adapterListener, uiViewModel)
        binding.playerCollapsedContainer.playerClose.setOnClickListener {
            uiViewModel.changePlayerState(STATE_HIDDEN)
        }
        binding.expandedToolbar.setNavigationOnClickListener {
            uiViewModel.collapsePlayer()
        }
    }

    private val adapterListener = object : PlayerTrackAdapter.Listener {
        override fun onClick() = uiViewModel.run {
            if (playerSheetState.value != STATE_EXPANDED) changePlayerState(STATE_EXPANDED)
            else {
                if (moreSheetState.value == STATE_EXPANDED) {
                    changeMoreState(STATE_COLLAPSED)
                    return
                }
                val shouldBeVisible = !playerBgVisible.value
                if (shouldBeVisible) {
                    val binding = binding ?: return@run
                    if (binding.bgImage.drawable == null && !binding.playerView.player.hasVideo())
                        return
                    changeMoreState(STATE_COLLAPSED)
                }
                changeBgVisible(shouldBeVisible)
            }
        }

        override fun onStartDoubleClick() {
            viewModel.seekToAdd(-10000)
        }

        override fun onEndDoubleClick() {
            viewModel.seekToAdd(10000)
        }
    }

    private fun configurePlayerControls() {
        val viewPager = binding!!.viewPager
        viewPager.adapter = adapter
        viewPager.registerOnUserPageChangeCallback { pos, isUser ->
            val index = viewModel.playerState.current.value?.index
            if (index != pos && isUser) viewModel.seek(pos)
        }

        fun submit() {
            adapter.submitList(viewModel.queue) {
                val index = (viewModel.playerState.current.value?.index ?: -1).takeIf { it != -1 }
                    ?: return@submitList
                val current = binding?.viewPager?.currentItem ?: 0
                val smooth = abs(index - current) <= 1
                binding?.viewPager?.setCurrentItem(index, smooth)
            }
        }

        val binding = binding!!
        binding.playerControls.trackHeart.addOnCheckedStateChangedListener(likeListener)
        observe(viewModel.playerState.current) {
            uiViewModel.run {
                if (it == null) return@run changePlayerState(STATE_HIDDEN)
                if (!isFinalState(playerSheetState.value)) return@run
                changePlayerState(
                    if (playerSheetState.value != STATE_EXPANDED) STATE_COLLAPSED
                    else STATE_EXPANDED
                )
            }
            submit()
            it?.mediaItem ?: return@observe
            binding.applyCurrent(it.mediaItem)
        }

        observe(viewModel.queueFlow) { submit() }

        val playPauseListener = CheckBoxListener { viewModel.setPlaying(it) }
        binding.playerControls.trackPlayPause
            .addOnCheckedStateChangedListener(playPauseListener)
        binding.playerCollapsedContainer.collapsedTrackPlayPause
            .addOnCheckedStateChangedListener(playPauseListener)
        observe(viewModel.isPlaying) {
            binding.run {
                playPauseListener.enabled = false
                playerControls.trackPlayPause.isChecked = it
                playerCollapsedContainer.collapsedTrackPlayPause.isChecked = it
                playPauseListener.enabled = true
            }
        }
        observe(viewModel.buffering) {
            binding.playerControls.playingIndicator.alpha = if (it) 1f else 0f
            binding.playerCollapsedContainer.collapsedPlayingIndicator.alpha = if (it) 1f else 0f
        }

        observe(viewModel.progress) { (curr, buff) ->
            binding.playerCollapsedContainer.run {
                collapsedBuffer.progress = buff.toInt()
                collapsedSeekbar.progress = curr.toInt()
            }
            binding.playerControls.run {
                if (!seekBar.isPressed) {
                    bufferBar.progress = buff.toInt()
                    seekBar.value = max(0f, min(curr.toFloat(), seekBar.valueTo))
                    trackCurrentTime.text = curr.toTimeString()
                }
            }
        }

        observe(viewModel.totalDuration) {
            val duration = it ?: viewModel.playerState.current.value?.track?.duration ?: 0
            binding.playerCollapsedContainer.run {
                collapsedSeekbar.max = duration.toInt()
                collapsedBuffer.max = duration.toInt()
            }
            binding.playerControls.run {
                bufferBar.max = duration.toInt()
                seekBar.apply {
                    value = max(0f, min(value, duration.toFloat()))
                    valueTo = 1f + duration
                }
                trackTotalTime.text = duration.toTimeString()
            }
        }


        val repeatModes = listOf(REPEAT_MODE_OFF, REPEAT_MODE_ALL, REPEAT_MODE_ONE)
        val animatedVectorDrawables = requireContext().run {
            fun asAnimated(id: Int) =
                AppCompatResources.getDrawable(this, id) as AnimatedVectorDrawable
            listOf(
                asAnimated(R.drawable.ic_repeat_one_to_repeat_off_40dp),
                asAnimated(R.drawable.ic_repeat_off_to_repeat_40dp),
                asAnimated(R.drawable.ic_repeat_to_repeat_one_40dp)
            )
        }
        val drawables = requireContext().run {
            fun asDrawable(id: Int) = AppCompatResources.getDrawable(this, id)!!
            listOf(
                asDrawable(R.drawable.ic_repeat_off_40dp),
                asDrawable(R.drawable.ic_repeat_40dp),
                asDrawable(R.drawable.ic_repeat_one_40dp),
            )
        }

        binding.playerControls.trackRepeat.icon =
            drawables[repeatModes.indexOf(viewModel.repeatMode.value)]

        fun changeRepeatDrawable(repeatMode: Int) = binding.playerControls.trackRepeat.run {
            val index = repeatModes.indexOf(repeatMode)
            icon = animatedVectorDrawables[index]
            (icon as Animatable).start()
        }

        binding.playerControls.run {
            seekBar.apply {
                addOnChangeListener { _, value, fromUser ->
                    if (fromUser) trackCurrentTime.text = value.toLong().toTimeString()
                }
                addOnSliderTouchListener(object : Slider.OnSliderTouchListener {
                    override fun onStartTrackingTouch(slider: Slider) = Unit
                    override fun onStopTrackingTouch(slider: Slider) =
                        viewModel.seekTo(slider.value.toLong())
                })
            }

            trackNext.setOnClickListener {
                viewModel.next()
                (trackNext.icon as Animatable).start()
            }
            observe(viewModel.nextEnabled) { trackNext.isEnabled = it }

            trackPrevious.setOnClickListener {
                viewModel.previous()
                (trackPrevious.icon as Animatable).start()
            }
            observe(viewModel.previousEnabled) { trackPrevious.isEnabled = it }

            val shuffleListener = CheckBoxListener { viewModel.setShuffle(it) }
            trackShuffle.addOnCheckedStateChangedListener(shuffleListener)
            observe(viewModel.shuffleMode) {
                shuffleListener.enabled = false
                trackShuffle.isChecked = it
                shuffleListener.enabled = true
            }

            trackRepeat.setOnClickListener {
                val mode = when (viewModel.repeatMode.value) {
                    REPEAT_MODE_OFF -> REPEAT_MODE_ALL
                    REPEAT_MODE_ALL -> REPEAT_MODE_ONE
                    else -> REPEAT_MODE_OFF
                }
                changeRepeatDrawable(mode)
                viewModel.setRepeat(mode)
            }
            observe(viewModel.repeatMode) { changeRepeatDrawable(it) }

            trackSubtitle.setOnClickListener {
                QualitySelectionBottomSheet().show(parentFragmentManager, null)
            }
            observe(viewModel.serverAndTracks) { (tracks, server, index) ->
                trackSubtitle.text = tracks?.getDetails(requireContext(), server, index)
                    ?.joinToString("  ")?.takeIf { it.isNotBlank() }
            }
        }
    }

    private val likeListener = CheckBoxListener { viewModel.likeCurrent(it) }

    private fun configureColors() {
        observe(viewModel.playerState.current) { adapter.onCurrentUpdated() }
        var last: Drawable? = null
        adapter.currentDrawableListener = { drawable ->
            if (last != drawable) {
                last = drawable
                val context = requireContext()
                uiViewModel.playerDrawable.value = drawable
                val colors =
                    if (context.isDynamic()) context.getColorsFrom(drawable?.toBitmap()) else null
                uiViewModel.playerColors.value = colors
                if (context.showBackground()) binding?.bgImage?.loadBlurred(drawable, 12f)
                else binding?.bgImage?.setImageDrawable(null)
            }
        }
        val bufferView =
            binding?.playerView?.findViewById<ProgressBar>(androidx.media3.ui.R.id.exo_buffering)
        observe(uiViewModel.playerColors) {
            val context = requireContext()
            if (context.isPlayerColor() && context.isDynamic()) {
                if (uiViewModel.currentAppColor != viewModel.playerState.current.value?.track?.id) {
                    uiViewModel.currentAppColor =
                        viewModel.playerState.current.value?.track?.id
                    requireActivity().recreate()
                    return@observe
                }
            }
            val colors = it ?: context.defaultPlayerColors()
            val binding = binding!!
            adapter.onColorsUpdated()

            binding.run {
                val color = if (requireContext().isDynamic()) colors.accent
                else colors.background
                root.setBackgroundColor(color)
                val backgroundState = ColorStateList.valueOf(colors.background)
                bgGradient.imageTintList = backgroundState
                bgCollapsed.backgroundTintList = backgroundState
                bufferView?.indeterminateDrawable?.setTint(colors.accent)
                expandedToolbar.run {
                    setTitleTextColor(colors.onBackground)
                    setSubtitleTextColor(colors.onBackground)
                }
            }

            binding.playerCollapsedContainer.run {
                collapsedPlayingIndicator.setIndicatorColor(colors.accent)
                collapsedSeekbar.setIndicatorColor(colors.accent)
                collapsedBuffer.setIndicatorColor(colors.accent)
                collapsedBuffer.trackColor = colors.onBackground
            }

            binding.playerControls.run {
                seekBar.trackActiveTintList = ColorStateList.valueOf(colors.accent)
                seekBar.thumbTintList = ColorStateList.valueOf(colors.accent)
                playingIndicator.setIndicatorColor(colors.accent)
                bufferBar.setIndicatorColor(colors.accent)
                bufferBar.trackColor = colors.onBackground
                trackCurrentTime.setTextColor(colors.onBackground)
                trackTotalTime.setTextColor(colors.onBackground)
                trackTitle.setTextColor(colors.onBackground)
                trackArtist.setTextColor(colors.onBackground)
            }
        }
    }

    private fun FragmentPlayerBinding.applyCurrent(item: MediaItem) {
        val track = item.track
        val extId = item.extensionId
        expandedToolbar.run {
            val itemContext = item.context
            title = if (itemContext != null) context.getString(R.string.playing_from) else null
            subtitle = itemContext?.title
            setOnMenuItemClickListener {
                if (it.itemId != R.id.menu_more) return@setOnMenuItemClickListener false
                onMoreClicked(item)
                true
            }
        }
        playerControls.run {
            trackTitle.text = track.title
            trackTitle.marquee()
            val artists = track.artists
            val artistNames = artists.joinToString(", ") { it.name }
            val span = SpannableString(artistNames)

            artists.forEach { artist ->
                val start = artistNames.indexOf(artist.name)
                val end = start + artist.name.length
                val clickableSpan = SimpleItemSpan(trackArtist.context) {
                    openItem(extId, artist)
                }
                runCatching {
                    span.setSpan(
                        clickableSpan, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
                    )
                }
            }

            trackArtist.text = span
            trackArtist.movementMethod = LinkMovementMethod.getInstance()
            likeListener.enabled = false
            trackHeart.isChecked = item.isLiked
            likeListener.enabled = true
            lifecycleScope.launch {
                val isTrackClient = viewModel.isLikeClient(item.extensionId)
                trackHeart.isVisible = isTrackClient
            }
        }
    }

    private fun openItem(extension: String, item: EchoMediaItem) {
        requireActivity().openFragment<MediaFragment>(
            null, MediaFragment.getBundle(extension, item, false)
        )
    }

    private fun onMoreClicked(item: MediaItem) {
        MediaMoreBottomSheet.newInstance(
            R.id.navHostFragment, item.extensionId, item.track, item.isLoaded, true
        ).show(requireActivity().supportFragmentManager, null)
    }

    private fun Player?.hasVideo() =
        this?.currentTracks?.groups.orEmpty().any { it.type == C.TRACK_TYPE_VIDEO }

    private fun applyVideoVisibility(visible: Boolean) {
        binding?.playerView?.isVisible = visible
        binding?.bgImage?.isVisible = !visible
        if (requireContext().isLandscape()) return
        binding?.playerControls?.trackCoverPlaceHolder?.isVisible = visible
        adapter.updatePlayerVisibility(visible)
    }

    private var oldBg: Streamable.Media.Background? = null
    private var backgroundPlayer: Player? = null

    @OptIn(UnstableApi::class)
    private fun applyPlayer() {
        val mainPlayer = viewModel.browser.value
        val background = viewModel.playerState.current.value?.mediaItem?.background
        val visible = if (mainPlayer.hasVideo()) {
            binding?.playerView?.player = mainPlayer
            binding?.playerView?.resizeMode = RESIZE_MODE_FIT
            backgroundPlayer?.release()
            backgroundPlayer = null
            true
        } else if (background != null) {
            if (oldBg != background || backgroundPlayer == null) {
                oldBg = background
                backgroundPlayer?.release()
                backgroundPlayer = getPlayer(requireContext(), viewModel.cache, background)
            }
            binding?.playerView?.player = backgroundPlayer
            binding?.playerView?.resizeMode = RESIZE_MODE_ZOOM
            true
        } else {
            backgroundPlayer?.release()
            backgroundPlayer = null
            binding?.playerView?.player = null
            false
        }
        applyVideoVisibility(visible)
    }

    @OptIn(UnstableApi::class)
    private fun configureBackgroundPlayerView() {
        binding?.playerView?.subtitleView?.setStyle(
            CaptionStyleCompat(
                Color.WHITE, Color.TRANSPARENT, Color.TRANSPARENT,
                EDGE_TYPE_OUTLINE, Color.BLACK, null
            )
        )
        observe(viewModel.serverAndTracks) { applyPlayer() }
    }

    companion object {
        private fun Context.showBackground() = getSettings().showBackground()
        const val DYNAMIC_PLAYER = "dynamic_player"
        const val PLAYER_COLOR = "player_app_color"
        fun Context.isDynamic() =
            getSettings().getBoolean(DYNAMIC_PLAYER, true)

        private fun Context.isPlayerColor() =
            getSettings().getBoolean(PLAYER_COLOR, false)

        @OptIn(UnstableApi::class)
        fun getPlayer(
            context: Context, cache: SimpleCache, video: Streamable.Media.Background,
        ): ExoPlayer {
            val cacheFactory = CacheDataSource
                .Factory().setCache(cache)
                .setUpstreamDataSourceFactory(
                    DefaultHttpDataSource.Factory()
                        .setDefaultRequestProperties(video.request.headers)
                )
            val factory = DefaultMediaSourceFactory(context)
                .setDataSourceFactory(cacheFactory)
            val player = ExoPlayer.Builder(context).setMediaSourceFactory(factory).build()
            player.setMediaItem(MediaItem.fromUri(video.request.url.toUri()))
            player.repeatMode = REPEAT_MODE_ONE
            player.volume = 0f
            player.prepare()
            player.play()
            return player
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\PlayerTrackAdapter.kt ----------
package com.joaomagdaleno.music_hub.ui.player

import android.graphics.Outline
import android.graphics.drawable.Drawable
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.ViewOutlineProvider
import androidx.core.content.res.ResourcesCompat
import androidx.core.view.doOnLayout
import androidx.core.view.updateLayoutParams
import androidx.media3.common.MediaItem
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_EXPANDED
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.databinding.ItemClickPanelsBinding
import com.joaomagdaleno.music_hub.databinding.ItemPlayerTrackBinding
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.unloadedCover
import com.joaomagdaleno.music_hub.playback.PlayerState
import com.joaomagdaleno.music_hub.ui.common.UiViewModel
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyHorizontalInsets
import com.joaomagdaleno.music_hub.ui.common.UiViewModel.Companion.applyInsets
import com.joaomagdaleno.music_hub.ui.player.PlayerColors.Companion.defaultPlayerColors
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.getCachedDrawable
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadWithThumb
import com.joaomagdaleno.music_hub.utils.ui.GestureListener
import com.joaomagdaleno.music_hub.utils.ui.GestureListener.Companion.handleGestures
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.dpToPx
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.isLandscape
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.isRTL
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimViewHolder
import kotlinx.coroutines.flow.MutableStateFlow
import kotlin.math.max

class PlayerTrackAdapter(
    private val uiViewModel: UiViewModel,
    private val current: MutableStateFlow<PlayerState.Current?>,
    private val listener: Listener
) : ListAdapter<MediaItem, PlayerTrackAdapter.ViewHolder>(DiffCallback) {

    interface Listener {
        fun onClick()
        fun onLongClick() {}
        fun onStartDoubleClick() {}
        fun onEndDoubleClick() {}
    }

    object DiffCallback : DiffUtil.ItemCallback<MediaItem>() {
        override fun areItemsTheSame(oldItem: MediaItem, newItem: MediaItem) =
            oldItem.mediaId == newItem.mediaId

        override fun areContentsTheSame(oldItem: MediaItem, newItem: MediaItem): Boolean {
            return oldItem == newItem
        }
    }

    inner class ViewHolder(
        private val binding: ItemPlayerTrackBinding
    ) : ScrollAnimViewHolder(binding.root) {

        private val context = binding.root.context

        private val collapsedPadding = 8.dpToPx(context)
        private val targetZ = collapsedPadding.toFloat()
        private val size = binding.root.resources.getDimension(R.dimen.collapsed_cover_size).toInt()
        private var targetScale = 0f
        private var targetX = 0
        private var targetY = 0

        private val cover = binding.playerTrackCoverContainer
        private var currentCoverHeight = size
        private var currCoverRound = 0f
        private val isLandscape = context.isLandscape()
        fun updateCollapsed() = uiViewModel.run {
            val insets = if (!isLandscape) systemInsets.value else getCombined()
            val targetPosX = collapsedPadding + if (context.isRTL()) insets.end else insets.start
            val targetPosY = if (playerSheetState.value != STATE_EXPANDED) 0
            else collapsedPadding + systemInsets.value.top
            targetX = targetPosX - cover.left
            targetY = targetPosY - cover.top
            currentCoverHeight = cover.height.takeIf { it > 0 } ?: currentCoverHeight
            targetScale = size.toFloat() / currentCoverHeight

            val (collapsedY, offset) = if (playerSheetState.value == STATE_EXPANDED)
                systemInsets.value.top to if (isLandscape) 0f else moreSheetOffset.value
            else -collapsedPadding to 1 - max(0f, playerSheetOffset.value)

            val inv = 1 - offset
            binding.playerCollapsed.root.run {
                translationY = collapsedY - size * inv * 2
                alpha = offset
            }
            if (isLandscape) binding.clickPanel.root.scaleX = 0.5f + 0.5f * inv
            val extraY = if (!isPlayerVisible) 0f else {
                val toMoveY = binding.playerControlsPlaceholder.top - cover.top
                toMoveY * inv
            }
            val extraX = if (!isPlayerVisible) 0f else {
                val toMoveX = binding.playerControlsPlaceholder.left - cover.left
                toMoveX * inv
            }
            cover.run {
                scaleX = if (!isPlayerVisible) 1 + (targetScale - 1) * offset else targetScale
                scaleY = scaleX
                translationX = targetX * offset + extraX
                translationY = targetY * offset + extraY
                translationZ = targetZ * (1 - offset)
                currCoverRound = collapsedPadding / scaleX
                invalidateOutline()
            }
        }

        fun updateInsets() = uiViewModel.run {
            val (v, h) = if (!isLandscape) 64 to 0 else 0 to 24
            binding.constraintLayout.applyInsets(systemInsets.value, v, h)
            val insets = if (isLandscape) getCombined() else systemInsets.value
            binding.playerCollapsed.root.applyHorizontalInsets(insets)
            binding.playerControlsPlaceholder.run {
                updateLayoutParams {
                    height = playerControlsHeight.value
                }
                doOnLayout {
                    updateCollapsed()
                    cover.doOnLayout { updateCollapsed() }
                }
            }

            updateCollapsed()
        }

        fun updateColors() {
            binding.playerCollapsed.run {
                val colors = uiViewModel.playerColors.value ?: context.defaultPlayerColors()
                collapsedTrackTitle.setTextColor(colors.onBackground)
                collapsedTrackArtist.setTextColor(colors.onBackground)
            }
        }

        private var coverDrawable: Drawable? = null
        fun applyDrawable() {
            val index = bindingAdapterPosition.takeIf { it != RecyclerView.NO_POSITION } ?: return
            val item = getItem(index) ?: return
            val curr = current.value?.mediaItem
            if (curr != item) return
            val drawable = coverDrawable
            currentDrawableListener?.invoke(drawable)
        }

        fun bind(item: MediaItem?) {
            binding.playerCollapsed.run {
                collapsedTrackTitle.text = item?.track?.title
                collapsedTrackArtist.text = item?.track?.artists?.joinToString(", ") { it.name }
            }
            val old = item?.unloadedCover?.getCachedDrawable(binding.root.context)
            item?.track?.cover.loadWithThumb(binding.playerTrackCover, old) {
                val image = it
                    ?: ResourcesCompat.getDrawable(resources, R.drawable.art_music, context.theme)
                setImageDrawable(image)
                coverDrawable = it
                applyDrawable()
            }
            updateInsets()
            updateColors()
        }

        init {
            cover.outlineProvider = object : ViewOutlineProvider() {
                override fun getOutline(view: View, outline: Outline) {
                    outline.setRoundRect(
                        0, 0, currentCoverHeight, currentCoverHeight, currCoverRound
                    )
                }
            }
            cover.clipToOutline = true
            cover.doOnLayout { updateInsets() }
            binding.clickPanel.configureClicking(listener, uiViewModel)
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val inflater = LayoutInflater.from(parent.context)
        val binding = ItemPlayerTrackBinding.inflate(inflater, parent, false)
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }

    var recyclerView: RecyclerView? = null
    override fun onAttachedToRecyclerView(recyclerView: RecyclerView) {
        this.recyclerView = recyclerView
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        this.recyclerView = null
    }

    override fun onViewAttachedToWindow(holder: ViewHolder) {
        holder.updateInsets()
        holder.updateColors()
        holder.applyDrawable()
    }

    override fun onViewDetachedFromWindow(holder: ViewHolder) {
        holder.updateInsets()
        holder.updateColors()
        holder.applyDrawable()
    }

    private fun onEachViewHolder(block: ViewHolder.() -> Unit) {
        val recyclerView = recyclerView ?: return
        recyclerView.run {
            for (it in 0 until childCount) {
                val viewHolder = getChildViewHolder(getChildAt(it)) as? ViewHolder
                viewHolder?.block()
            }
        }
    }

    fun moreOffsetUpdated() = onEachViewHolder { updateCollapsed() }
    fun playerOffsetUpdated() = onEachViewHolder { updateCollapsed() }
    fun playerSheetStateUpdated() = onEachViewHolder { updateInsets() }
    fun insetsUpdated() = onEachViewHolder { updateInsets() }
    fun playerControlsHeightUpdated() = onEachViewHolder { updateInsets() }
    fun onColorsUpdated() = onEachViewHolder { updateColors() }
    fun onCurrentUpdated() {
        onEachViewHolder { applyDrawable() }
        if (current.value == null) currentDrawableListener?.invoke(null)
    }

    private var isPlayerVisible = false
    fun updatePlayerVisibility(visible: Boolean) {
        isPlayerVisible = visible
        onEachViewHolder { updateInsets() }
    }

    var currentDrawableListener: ((Drawable?) -> Unit)? = null

    companion object {
        fun ItemClickPanelsBinding.configureClicking(listener: Listener, uiViewModel: UiViewModel) {
            start.handleGestures(object : GestureListener {
                override val onClick = listener::onClick
                override val onLongClick = listener::onLongClick
                override val onDoubleClick: (() -> Unit)?
                    get() = if (uiViewModel.playerSheetState.value != STATE_EXPANDED) null
                    else listener::onStartDoubleClick
            })
            end.handleGestures(object : GestureListener {
                override val onClick = listener::onClick
                override val onLongClick = listener::onLongClick
                override val onDoubleClick: (() -> Unit)?
                    get() = if (uiViewModel.playerSheetState.value != STATE_EXPANDED) null
                    else listener::onEndDoubleClick
            })
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\PlayerUiListener.kt ----------
package com.joaomagdaleno.music_hub.ui.player

import android.os.Handler
import android.os.Looper
import androidx.lifecycle.viewModelScope
import androidx.media3.common.C.TIME_UNSET
import androidx.media3.common.PlaybackException
import androidx.media3.common.Player
import androidx.media3.common.Timeline
import androidx.media3.common.Tracks
import androidx.media3.exoplayer.ExoPlayer
import kotlinx.coroutines.launch

class PlayerUiListener(
    private val player: Player,
    private val viewModel: PlayerViewModel
) : Player.Listener {

    init {
        updateList()
        with(viewModel) {
            tracksFlow.value = player.currentTracks
            isPlaying.value = player.isPlaying
            buffering.value = player.playbackState == Player.STATE_BUFFERING
            shuffleMode.value = player.shuffleModeEnabled
            repeatMode.value = player.repeatMode
        }
        updateNavigation()
    }

    private fun updateList() = viewModel.run {
        updateNavigation()
        queue = (0 until player.mediaItemCount).map { player.getMediaItemAt(it) }
        viewModelScope.launch { queueFlow.emit(Unit) }
    }

    private fun updateNavigation() {
        viewModel.nextEnabled.value = player.hasNextMediaItem()
        viewModel.previousEnabled.value = player.currentMediaItemIndex >= 0
    }

    private val delay = 500L
    private val threshold = 0.2f
    private val updateProgressRunnable = Runnable { updateProgress() }
    private val handler = Handler(Looper.getMainLooper()).also {
        it.post(updateProgressRunnable)
    }

    private fun updateProgress() {
        viewModel.progress.value =
            player.currentPosition to player.bufferedPosition
        viewModel.totalDuration.value = player.duration.takeIf { it != TIME_UNSET }

        handler.removeCallbacks(updateProgressRunnable)
        val playbackState = player.playbackState
        if (playbackState != ExoPlayer.STATE_IDLE && playbackState != ExoPlayer.STATE_ENDED) {
            var delayMs: Long
            if (player.playWhenReady && playbackState == ExoPlayer.STATE_READY) {
                delayMs = delay - player.currentPosition % delay
                if (delayMs < delay * threshold) {
                    delayMs += delay
                }
            } else {
                delayMs = delay
            }
            handler.postDelayed(updateProgressRunnable, delayMs)
        }
    }

    override fun onPlaybackStateChanged(playbackState: Int) {
        when (playbackState) {
            Player.STATE_BUFFERING ->
                viewModel.buffering.value = true

            Player.STATE_READY -> {
                viewModel.buffering.value = false
            }

            else -> Unit
        }
        updateProgress()
    }

    override fun onIsPlayingChanged(isPlaying: Boolean) {
        viewModel.isPlaying.value = isPlaying
    }

    override fun onPositionDiscontinuity(
        oldPosition: Player.PositionInfo, newPosition: Player.PositionInfo, reason: Int
    ) {
        updateNavigation()
        updateProgress()
        viewModel.discontinuity.value = newPosition.positionMs
    }

    override fun onTimelineChanged(timeline: Timeline, reason: Int) {
        updateList()
    }

    override fun onShuffleModeEnabledChanged(shuffleModeEnabled: Boolean) {
        viewModel.shuffleMode.value = player.shuffleModeEnabled
        updateList()
    }

    override fun onRepeatModeChanged(repeatMode: Int) {
        viewModel.repeatMode.value = player.repeatMode
        updateList()
    }

    override fun onPlayerError(error: PlaybackException) {
        viewModel.isPlaying.value = false
        viewModel.buffering.value = false
    }

    override fun onTracksChanged(tracks: Tracks) {
        viewModel.tracksFlow.value = tracks
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\PlayerViewModel.kt ----------
package com.joaomagdaleno.music_hub.ui.player

import android.content.SharedPreferences
import android.os.Bundle
import androidx.annotation.OptIn
import androidx.core.os.bundleOf
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.media3.common.MediaItem
import androidx.media3.common.ThumbRating
import androidx.media3.common.TrackGroup
import androidx.media3.common.TrackSelectionOverride
import androidx.media3.common.Tracks
import androidx.media3.common.util.UnstableApi
import androidx.media3.datasource.cache.SimpleCache
import androidx.media3.session.MediaController
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.clients.LikeClient
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.common.models.Message
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtension
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.isClient
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.playback.MediaItemUtils
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.serverWithDownloads
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.sourceIndex
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.playback.PlayerCommands.addToNextCommand
import com.joaomagdaleno.music_hub.playback.PlayerCommands.addToQueueCommand
import com.joaomagdaleno.music_hub.playback.PlayerCommands.playCommand
import com.joaomagdaleno.music_hub.playback.PlayerCommands.radioCommand
import com.joaomagdaleno.music_hub.playback.PlayerCommands.resumeCommand
import com.joaomagdaleno.music_hub.playback.PlayerCommands.sleepTimer
import com.joaomagdaleno.music_hub.playback.PlayerService.Companion.getController
import com.joaomagdaleno.music_hub.playback.PlayerState
import com.joaomagdaleno.music_hub.utils.ContextUtils.listenFuture
import com.joaomagdaleno.music_hub.utils.Serializer.putSerialized
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlin.math.max

@OptIn(UnstableApi::class)
class PlayerViewModel(
    val app: App,
    val playerState: PlayerState,
    val settings: SharedPreferences,
    val cache: SimpleCache,
    val extensions: ExtensionLoader,
    downloader: Downloader,
) : ViewModel() {
    private val downloadFlow = downloader.flow

    val browser = MutableStateFlow<MediaController?>(null)
    private fun withBrowser(block: suspend (MediaController) -> Unit) {
        viewModelScope.launch {
            val browser = browser.first { it != null }!!
            block(browser)
        }
    }

    var queue: List<MediaItem> = emptyList()
    val queueFlow = MutableSharedFlow<Unit>()
    private val context = app.context
    val controllerFutureRelease = getController(context) { player ->
        browser.value = player
        player.addListener(PlayerUiListener(player, this))

        if (player.mediaItemCount != 0) return@getController
        if (!settings.getBoolean(KEEP_QUEUE, true)) return@getController

        player.sendCustomCommand(resumeCommand, Bundle.EMPTY)
    }

    override fun onCleared() {
        super.onCleared()
        controllerFutureRelease()
    }

    fun play(position: Int) {
        withBrowser {
            it.seekTo(position, 0)
            it.playWhenReady = true
        }
    }

    fun seek(position: Int) {
        withBrowser { it.seekTo(position, 0) }
    }

    fun removeQueueItem(position: Int) {
        withBrowser { it.removeMediaItem(position) }
    }

    fun moveQueueItems(fromPos: Int, toPos: Int) {
        withBrowser { it.moveMediaItem(fromPos, toPos) }
    }

    fun clearQueue() {
        withBrowser { it.clearMediaItems() }
    }

    fun seekTo(pos: Long) {
        withBrowser { it.seekTo(pos) }
    }

    fun seekToAdd(position: Int) {
        withBrowser { it.seekTo(max(0, it.currentPosition + position)) }
    }

    fun setPlaying(isPlaying: Boolean) {
        withBrowser {
            it.prepare()
            it.playWhenReady = isPlaying
        }
    }

    fun next() {
        withBrowser { it.seekToNextMediaItem() }
    }

    fun previous() {
        withBrowser { it.seekToPrevious() }
    }

    fun setShuffle(isShuffled: Boolean, changeCurrent: Boolean = false) {
        withBrowser {
            it.shuffleModeEnabled = isShuffled
            if (changeCurrent) it.seekTo(0, 0)
        }
    }

    fun setRepeat(repeatMode: Int) {
        withBrowser { it.repeatMode = repeatMode }
    }

    suspend fun isLikeClient(extensionId: String): Boolean = withContext(Dispatchers.IO) {
        extensions.music.getExtension(extensionId)?.isClient<LikeClient>() ?: false
    }

    private fun createException(throwable: Throwable) {
        viewModelScope.launch { app.throwFlow.emit(throwable) }
    }

    fun likeCurrent(isLiked: Boolean) = withBrowser { controller ->
        val future = controller.setRating(ThumbRating(isLiked))
        app.context.listenFuture(future) { sessionResult ->
            sessionResult.getOrElse { createException(it) }
        }
    }

    fun setSleepTimer(timer: Long) {
        withBrowser { it.sendCustomCommand(sleepTimer, bundleOf("ms" to timer)) }
    }

    fun changeTrackSelection(trackGroup: TrackGroup, index: Int) {
        withBrowser {
            it.trackSelectionParameters = it.trackSelectionParameters
                .buildUpon()
                .clearOverride(trackGroup)
                .addOverride(TrackSelectionOverride(trackGroup, index))
                .build()
        }
    }

    private fun changeCurrent(newItem: MediaItem) {
        withBrowser { player ->
            val oldPosition = player.currentPosition
            player.replaceMediaItem(player.currentMediaItemIndex, newItem)
            player.prepare()
            player.seekTo(oldPosition)
        }
    }

    fun changeServer(server: Streamable) {
        val item = playerState.current.value?.mediaItem ?: return
        val index = item.serverWithDownloads(app.context).indexOf(server).takeIf { it != -1 }
            ?: return
        changeCurrent(MediaItemUtils.buildServer(item, index))
    }

    fun changeBackground(background: Streamable?) {
        val item = playerState.current.value?.mediaItem ?: return
        val index = item.track.backgrounds.indexOf(background)
        changeCurrent(MediaItemUtils.buildBackground(item, index))
    }

    fun changeSubtitle(subtitle: Streamable?) {
        val item = playerState.current.value?.mediaItem ?: return
        val index = item.track.subtitles.indexOf(subtitle)
        changeCurrent(MediaItemUtils.buildSubtitle(item, index))
    }

    fun changeCurrentSource(index: Int) {
        val item = playerState.current.value?.mediaItem ?: return
        changeCurrent(MediaItemUtils.buildSource(item, index))
    }

    fun setQueue(id: String, list: List<Track>, index: Int, context: EchoMediaItem?) {
        withBrowser { controller ->
            val mediaItems = list.map {
                MediaItemUtils.build(
                    app,
                    downloadFlow.value,
                    MediaState.Unloaded(id, it),
                    context
                )
            }
            controller.setMediaItems(mediaItems, index, list[index].playedDuration ?: 0)
            controller.prepare()
        }
    }

    fun radio(id: String, item: EchoMediaItem, loaded: Boolean) = viewModelScope.launch {
        app.messageFlow.emit(
            Message(app.context.getString(R.string.loading_radio_for_x, item.title))
        )
        withBrowser {
            it.sendCustomCommand(radioCommand, Bundle().apply {
                putString("extId", id)
                putSerialized("item", item)
                putBoolean("loaded", loaded)
            })
        }
    }

    fun play(id: String, item: EchoMediaItem, loaded: Boolean) = viewModelScope.launch {
        if (item !is Track) app.messageFlow.emit(
            Message(app.context.getString(R.string.playing_x, item.title))
        )
        withBrowser {
            it.sendCustomCommand(playCommand, Bundle().apply {
                putString("extId", id)
                putSerialized("item", item)
                putBoolean("loaded", loaded)
                putBoolean("shuffle", false)
            })
        }
    }

    fun shuffle(id: String, item: EchoMediaItem, loaded: Boolean) = viewModelScope.launch {
        if (item !is Track) app.messageFlow.emit(
            Message(app.context.getString(R.string.shuffling_x, item.title))
        )
        withBrowser {
            it.sendCustomCommand(playCommand, Bundle().apply {
                putString("extId", id)
                putSerialized("item", item)
                putBoolean("loaded", loaded)
                putBoolean("shuffle", true)
            })
        }
    }


    fun addToQueue(id: String, item: EchoMediaItem, loaded: Boolean) = viewModelScope.launch {
        if (item !is Track) app.messageFlow.emit(
            Message(app.context.getString(R.string.adding_x_to_queue, item.title))
        )
        withBrowser {
            it.sendCustomCommand(addToQueueCommand, Bundle().apply {
                putString("extId", id)
                putSerialized("item", item)
                putBoolean("loaded", loaded)
            })
        }
    }

    fun addToNext(id: String, item: EchoMediaItem, loaded: Boolean) = viewModelScope.launch {
        if (!(browser.value?.mediaItemCount == 0 && item is Track)) app.messageFlow.emit(
            Message(app.context.getString(R.string.adding_x_to_next, item.title))
        )
        withBrowser {
            it.sendCustomCommand(addToNextCommand, Bundle().apply {
                putString("extId", id)
                putSerialized("item", item)
                putBoolean("loaded", loaded)
            })
        }
    }

    val progress = MutableStateFlow(0L to 0L)
    val discontinuity = MutableStateFlow(0L)
    val totalDuration = MutableStateFlow<Long?>(null)

    val buffering = MutableStateFlow(false)
    val isPlaying = MutableStateFlow(false)
    val nextEnabled = MutableStateFlow(false)
    val previousEnabled = MutableStateFlow(false)
    val repeatMode = MutableStateFlow(0)
    val shuffleMode = MutableStateFlow(false)

    val tracksFlow = MutableStateFlow<Tracks?>(null)
    val serverAndTracks = tracksFlow.combine(playerState.serverChanged) { tracks, _ -> tracks }
        .combine(playerState.current) { tracks, current ->
            val server = playerState.servers[current?.mediaItem?.mediaId]?.getOrNull()
            val index = current?.mediaItem?.sourceIndex
            Triple(tracks, server, index)
        }.stateIn(viewModelScope, SharingStarted.Lazily, Triple(null, null, null))

    companion object {
        const val KEEP_QUEUE = "keep_queue"
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\audiofx\AudioEffectsBottomSheet.kt ----------
package com.joaomagdaleno.music_hub.ui.player.audiofx

import android.annotation.SuppressLint
import android.content.Intent
import android.content.SharedPreferences
import android.media.audiofx.AudioEffect
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.activity.ComponentActivity
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.edit
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.viewModelScope
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.databinding.DialogPlayerAudioFxBinding
import com.joaomagdaleno.music_hub.databinding.FragmentAudioFxBinding
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener.Companion.BASS_BOOST
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener.Companion.CHANGE_PITCH
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener.Companion.CUSTOM_EFFECTS
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener.Companion.PLAYBACK_SPEED
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener.Companion.deleteFxPrefs
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener.Companion.getFxPrefs
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener.Companion.globalFx
import com.joaomagdaleno.music_hub.playback.listener.EffectsListener.Companion.speedRange
import com.joaomagdaleno.music_hub.ui.player.PlayerViewModel
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.PermsUtils.registerActivityResultLauncher
import com.joaomagdaleno.music_hub.utils.ui.AutoClearedValue.Companion.autoCleared
import com.joaomagdaleno.music_hub.utils.ui.RulerAdapter
import kotlinx.coroutines.launch
import org.koin.androidx.viewmodel.ext.android.activityViewModel

class AudioEffectsBottomSheet : BottomSheetDialogFragment() {

    var binding by autoCleared<DialogPlayerAudioFxBinding>()

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        binding = DialogPlayerAudioFxBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val viewModel by activityViewModel<PlayerViewModel>()
        var mediaId: String? = null

        fun bind() {
            val settings = requireContext().globalFx()
            settings.edit {
                val customEffects = settings.getStringSet(CUSTOM_EFFECTS, null) ?: emptySet()
                putStringSet(CUSTOM_EFFECTS, customEffects + mediaId?.hashCode()?.toString())
            }
            binding.audioFxDescription.isVisible = mediaId != null
            val mediaSettings =
                requireContext().getFxPrefs(settings, mediaId?.hashCode()) ?: settings
            binding.audioFxFragment.bind(mediaSettings) { onEqualizerClicked() }
        }
        observe(viewModel.playerState.current) {
            mediaId = it?.mediaItem?.mediaId
            bind()
        }
        binding.topAppBar.setNavigationOnClickListener { dismiss() }
        binding.topAppBar.setOnMenuItemClickListener {
            when (it.itemId) {
                R.id.menu_refresh -> {
                    val context = requireContext()
                    val id = mediaId ?: return@setOnMenuItemClickListener false
                    context.deleteFxPrefs(id.hashCode())
                    bind()
                    true
                }

                else -> false
            }
        }
    }

    companion object {
        @SuppressLint("SetTextI18n")
        fun FragmentAudioFxBinding.bind(
            settings: SharedPreferences, onEqualizerClicked: () -> Unit
        ) {
            val speed = settings.getInt(PLAYBACK_SPEED, speedRange.indexOf(1f))
            val adapter = RulerAdapter(object : RulerAdapter.Listener<Int> {
                override fun intervalText(value: Int) = "${speedRange.getOrNull(value) ?: 1f}x"
                override fun onSelectItem(value: Int) {
                    speedValue.text = "${speedRange.getOrNull(value) ?: 1f}x"
                    settings.edit { putInt(PLAYBACK_SPEED, value) }
                }
            })

            speedRecycler.adapter = adapter
            adapter.submitList(List(speedRange.size) { index -> index to (index % 2 == 0) }, speed)

            pitchSwitch.isChecked = settings.getBoolean(CHANGE_PITCH, true)
            pitch.setOnClickListener {
                pitchSwitch.isChecked = !pitchSwitch.isChecked
            }
            pitchSwitch.setOnCheckedChangeListener { _, isChecked ->
                settings.edit { putBoolean(CHANGE_PITCH, isChecked) }
            }
            bassBoostSlider.value = settings.getInt(BASS_BOOST, 0).toFloat()
            bassBoostSlider.addOnChangeListener { _, value, _ ->
                settings.edit { putInt(BASS_BOOST, value.toInt()) }
            }
            equalizer.setOnClickListener { onEqualizerClicked() }
        }

        private fun openEqualizer(activity: ComponentActivity, sessionId: Int) {
            val intent = Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL).apply {
                putExtra(AudioEffect.EXTRA_PACKAGE_NAME, activity.packageName)
                putExtra(AudioEffect.EXTRA_AUDIO_SESSION, sessionId)
                putExtra(AudioEffect.EXTRA_CONTENT_TYPE, AudioEffect.CONTENT_TYPE_MUSIC)
            }
            val contract = ActivityResultContracts.StartActivityForResult()
            activity.registerActivityResultLauncher(contract) {}.launch(intent)
        }

        fun Fragment.onEqualizerClicked() {
            val viewModel by activityViewModel<PlayerViewModel>()
            val sessionId = viewModel.playerState.session.value
            runCatching { openEqualizer(requireActivity(), sessionId) }.getOrElse {
                viewModel.run { viewModelScope.launch { app.throwFlow.emit(it) } }
            }
        }
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\more\PlayerMoreFragment.kt ----------
package com.joaomagdaleno.music_hub.ui.player.more

import android.annotation.SuppressLint
import android.content.res.ColorStateList
import android.graphics.Color
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.view.children
import androidx.core.view.updatePaddingRelative
import androidx.fragment.app.Fragment
import androidx.fragment.app.add
import androidx.fragment.app.commitNow
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.button.MaterialButton
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.databinding.FragmentPlayerMoreBinding
import com.joaomagdaleno.music_hub.ui.common.UiViewModel
import com.joaomagdaleno.music_hub.ui.player.PlayerColors.Companion.defaultPlayerColors
import com.joaomagdaleno.music_hub.ui.player.more.info.TrackInfoFragment
import com.joaomagdaleno.music_hub.ui.player.more.lyrics.LyricsFragment
import com.joaomagdaleno.music_hub.ui.player.more.upnext.QueueFragment
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.ui.AutoClearedValue.Companion.autoCleared
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.dpToPx
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.isLandscape
import org.koin.androidx.viewmodel.ext.android.activityViewModel

class PlayerMoreFragment : Fragment() {

    private var binding by autoCleared<FragmentPlayerMoreBinding>()
    private val uiViewModel by activityViewModel<UiViewModel>()
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        binding = FragmentPlayerMoreBinding.inflate(inflater, container, false)
        return binding.root
    }

    private inline fun <reified F : Fragment> Fragment.addIfNull(): String {
        val tag = F::class.java.simpleName
        childFragmentManager.run {
            if (findFragmentByTag(tag) == null) commitNow {
                add<F>(R.id.player_more_fragment_container, tag)
            }
        }
        return tag
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        var topInset = 0
        val topMargin = requireContext().run { if (isLandscape()) 0 else 72.dpToPx(this) }
        fun updateTranslateY() {
            val offset = uiViewModel.moreSheetOffset.value
            val inverted = 1 - offset
            binding.root.translationY = -topInset * inverted
            binding.playerMoreFragmentContainer.translationY =
                (1 - offset) * 2 * uiViewModel.systemInsets.value.bottom
        }

        observe(uiViewModel.systemInsets) {
            topInset = it.top + topMargin
            view.updatePaddingRelative(top = it.top)
            updateTranslateY()
        }

        observe(uiViewModel.moreSheetOffset) {
            updateTranslateY()
            binding.buttonToggleGroupBg.alpha = it
        }

        observe(uiViewModel.moreSheetState) {
            if (it == BottomSheetBehavior.STATE_COLLAPSED) binding.buttonToggleGroup.clearChecked()
            else binding.buttonToggleGroup.check(uiViewModel.lastMoreTab)
        }

        observe(uiViewModel.playerColors) { colorsNullable ->
            val colors = colorsNullable ?: requireContext().defaultPlayerColors()
            binding.buttonToggleGroupBg.children.forEach {
                it as MaterialButton
                it.backgroundTintList = ColorStateList.valueOf(colors.background)
            }

            val textColorStateList = ColorStateList(
                arrayOf(
                    intArrayOf(android.R.attr.state_checked),
                    intArrayOf(-android.R.attr.state_checked)
                ),
                intArrayOf(
                    colors.background,
                    colors.onBackground
                )
            )
            val foregroundColorStateList = ColorStateList(
                arrayOf(
                    intArrayOf(android.R.attr.state_checked),
                    intArrayOf(-android.R.attr.state_checked)
                ),
                intArrayOf(
                    colors.onBackground,
                    Color.TRANSPARENT
                )
            )
            binding.buttonToggleGroup.children.forEach {
                it as MaterialButton
                it.setTextColor(textColorStateList)
                it.backgroundTintList = foregroundColorStateList
            }
        }

        showFragment()
        binding.buttonToggleGroup.addOnButtonCheckedListener { group, _, _ ->
            uiViewModel.run {
                val current = moreSheetState.value
                if (current != BottomSheetBehavior.STATE_COLLAPSED && current != BottomSheetBehavior.STATE_EXPANDED) return@run
                changeMoreState(
                    if (group.checkedButtonId != -1) BottomSheetBehavior.STATE_EXPANDED else BottomSheetBehavior.STATE_COLLAPSED
                )
            }
            showFragment()
        }

        @SuppressLint("ClickableViewAccessibility")
        val touchListener = View.OnTouchListener { v, _ ->
            uiViewModel.lastMoreTab = v.id
            false
        }
        binding.buttonToggleGroup.children.forEach { it.setOnTouchListener(touchListener) }
    }

    private fun showFragment() {
        val checkedId = binding.buttonToggleGroup.checkedButtonId
        val toShow = when (checkedId) {
            R.id.queue -> addIfNull<QueueFragment>()
            R.id.lyrics -> addIfNull<LyricsFragment>()
            R.id.info -> addIfNull<TrackInfoFragment>()
            else -> null
        }
        childFragmentManager.commitNow {
            childFragmentManager.fragments.forEach { fragment ->
                if (fragment.tag != toShow) hide(fragment)
                else show(fragment)
            }
            setReorderingAllowed(true)
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\more\info\TrackInfoFragment.kt ----------
package com.joaomagdaleno.music_hub.ui.player.more.info

import android.os.Bundle
import android.view.View
import androidx.fragment.app.Fragment
import com.google.android.material.transition.MaterialSharedAxis
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.ui.media.MediaDetailsFragment
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.setupTransition
import org.koin.androidx.viewmodel.ext.android.viewModel

class TrackInfoFragment : Fragment(
    R.layout.fragment_player_info
), MediaDetailsFragment.Parent {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        setupTransition(view, axis = MaterialSharedAxis.Y)
    }

    override val feedId = "player"
    override val fromPlayer = true
    override val viewModel by viewModel<TrackInfoViewModel>()
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\more\info\TrackInfoViewModel.kt ----------
package com.joaomagdaleno.music_hub.ui.player.more.info

import androidx.lifecycle.viewModelScope
import com.joaomagdaleno.music_hub.common.models.EchoMediaItem
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.download.Downloader
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.MediaState
import com.joaomagdaleno.music_hub.extensions.cache.Cached.loadMedia
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.extensionId
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.isLoaded
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.playback.PlayerState
import com.joaomagdaleno.music_hub.ui.media.MediaDetailsViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.merge
import kotlinx.coroutines.launch

class TrackInfoViewModel(
    val app: App,
    extensionLoader: ExtensionLoader,
    playerState: PlayerState,
    downloader: Downloader
) : MediaDetailsViewModel(
    downloader, app, true,
    playerState.current.combine(extensionLoader.music) { current, music ->
        current?.mediaItem?.extensionId?.let { id ->
            music.find { it.id == id }
        }
    }
) {
    val currentFlow = playerState.current
    override fun getItem(): Triple<String, EchoMediaItem, Boolean>? {
        return currentFlow.value?.let { (_, item) ->
            Triple(item.extensionId, item.track, item.isLoaded)
        }
    }

    init {
        viewModelScope.launch(Dispatchers.IO) {
            listOf(playerState.current, extensionFlow, refreshFlow).merge().collectLatest {
                itemResultFlow.value = null
                val extension = extensionFlow.value ?: return@collectLatest
                val track = currentFlow.value?.mediaItem?.takeIf { it.isLoaded }?.track
                    ?: return@collectLatest
                itemResultFlow.value = loadMedia(
                    app, extension, MediaState.Unloaded(extension.id, track)
                )
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\more\lyrics\LyricAdapter.kt ----------
package com.joaomagdaleno.music_hub.ui.player.more.lyrics

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.recyclerview.widget.DiffUtil
import com.joaomagdaleno.music_hub.common.models.Lyrics
import com.joaomagdaleno.music_hub.databinding.ItemLoadingBinding
import com.joaomagdaleno.music_hub.databinding.ItemLyricBinding
import com.joaomagdaleno.music_hub.ui.common.UiViewModel
import com.joaomagdaleno.music_hub.ui.feed.FeedLoadingAdapter
import com.joaomagdaleno.music_hub.ui.player.PlayerColors.Companion.defaultPlayerColors
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.applyTranslationYAnimation
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimListAdapter
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimViewHolder

class LyricAdapter(
    val uiViewModel: UiViewModel, val listener: Listener,
) : ScrollAnimListAdapter<Lyrics.Item, LyricAdapter.ViewHolder>(DiffCallback) {
    fun interface Listener {
        fun onLyricSelected(adapter: LyricAdapter, lyric: Lyrics.Item)
    }

    object DiffCallback : DiffUtil.ItemCallback<Lyrics.Item>() {
        override fun areItemsTheSame(oldItem: Lyrics.Item, newItem: Lyrics.Item) =
            oldItem.text == newItem.text

        override fun areContentsTheSame(oldItem: Lyrics.Item, newItem: Lyrics.Item) =
            oldItem == newItem
    }

    inner class ViewHolder(val binding: ItemLyricBinding) : ScrollAnimViewHolder(binding.root) {
        init {
            binding.root.setOnClickListener {
                val lyrics = getItem(bindingAdapterPosition) ?: return@setOnClickListener
                listener.onLyricSelected(this@LyricAdapter, lyrics)
            }
        }
    }

    private fun ViewHolder.updateColors() {
        binding.root.run {
            val colors = uiViewModel.playerColors.value ?: context.defaultPlayerColors()
            val alphaStrippedColor = colors.onBackground or -0x1000000
            setTextColor(alphaStrippedColor)
        }
    }

    private fun getItemOrNull(position: Int) = runCatching { getItem(position) }.getOrNull()

    private var currentPos = -1
    private fun ViewHolder.updateCurrent() {
        val currentTime = getItemOrNull(currentPos)?.startTime ?: 0
        val time = getItemOrNull(bindingAdapterPosition)?.startTime ?: 0
        binding.root.alpha = if (currentTime >= time) 1f else 0.5f
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val inflater = LayoutInflater.from(parent.context)
        val binding = ItemLyricBinding.inflate(inflater, parent, false)
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val lyric = getItem(position) ?: return
        holder.binding.root.text = lyric.text.trim().trim('\n').ifEmpty { "" }
        holder.updateColors()
        holder.updateCurrent()
        holder.itemView.applyTranslationYAnimation(scrollY)
    }

    override fun onViewAttachedToWindow(holder: ViewHolder) {
        holder.updateColors()
    }

    fun updateColors() {
        onEachViewHolder { updateColors() }
    }

    fun updateCurrent(currentPos: Int) {
        this.currentPos = currentPos
        onEachViewHolder { updateCurrent() }
    }
    class Loading(
        parent: ViewGroup,
        val binding: ItemLoadingBinding = ItemLoadingBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        )
    ) : FeedLoadingAdapter.ViewHolder(binding.root)
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\more\lyrics\LyricsFragment.kt ----------
package com.joaomagdaleno.music_hub.ui.player.more.lyrics

import android.annotation.SuppressLint
import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.coordinatorlayout.widget.CoordinatorLayout
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat.CONSUMED
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.paging.LoadState
import androidx.paging.LoadState.Error
import androidx.paging.LoadState.NotLoading
import androidx.recyclerview.widget.ConcatAdapter
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.LinearSmoothScroller
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.behavior.HideViewOnScrollBehavior
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.transition.MaterialSharedAxis
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.clients.LyricsSearchClient
import com.joaomagdaleno.music_hub.common.models.ExtensionType
import com.joaomagdaleno.music_hub.common.models.Lyrics
import com.joaomagdaleno.music_hub.databinding.FragmentPlayerLyricsBinding
import com.joaomagdaleno.music_hub.databinding.ItemLyricsItemBinding
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.isClient
import com.joaomagdaleno.music_hub.ui.common.GridAdapter
import com.joaomagdaleno.music_hub.ui.common.UiViewModel
import com.joaomagdaleno.music_hub.ui.extensions.list.ExtensionsListBottomSheet
import com.joaomagdaleno.music_hub.ui.feed.FeedLoadingAdapter
import com.joaomagdaleno.music_hub.ui.feed.FeedLoadingAdapter.Companion.createListener
import com.joaomagdaleno.music_hub.ui.player.PlayerColors.Companion.defaultPlayerColors
import com.joaomagdaleno.music_hub.ui.player.PlayerViewModel
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadAsCircle
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.setupTransition
import com.joaomagdaleno.music_hub.utils.ui.AutoClearedValue.Companion.autoCleared
import com.joaomagdaleno.music_hub.utils.ui.FastScrollerHelper
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.koin.androidx.viewmodel.ext.android.activityViewModel


class LyricsFragment : Fragment() {

    private var binding by autoCleared<FragmentPlayerLyricsBinding>()
    private val viewModel by activityViewModel<LyricsViewModel>()
    private val playerVM by activityViewModel<PlayerViewModel>()
    private val uiViewModel by activityViewModel<UiViewModel>()

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?,
    ): View {
        binding = FragmentPlayerLyricsBinding.inflate(inflater, container, false)
        return binding.root
    }

    private var currentLyricsPos = -1
    private var currentLyrics: Lyrics.Lyric? = null
    private val lyricAdapter by lazy {
        LyricAdapter(uiViewModel) { adapter, lyric ->
            if (adapter.itemCount <= 1) return@LyricAdapter
            currentLyricsPos = -1
            playerVM.seekTo(lyric.startTime)
            updateLyrics(lyric.startTime)
        }
    }

    private val lyricsErrorAdapter by lazy {
        FeedLoadingAdapter(createListener {
            viewModel.reloadCurrent()
        }) { LyricAdapter.Loading(it) }
    }

    private var shouldAutoScroll = true
    val layoutManager by lazy {
        binding.lyricsRecyclerView.layoutManager as LinearLayoutManager
    }

    private fun updateLyrics(current: Long) {
        val lyrics = currentLyrics as? Lyrics.Timed ?: return
        val currentTime = lyrics.list.getOrNull(currentLyricsPos)?.endTime ?: -1
        if (currentTime < current || current <= 0) {
            val currentIndex = lyrics.list.indexOfLast { lyric ->
                lyric.startTime <= current
            }
            lyricAdapter.updateCurrent(currentIndex)
            if (!shouldAutoScroll) return
            binding.appBarLayout.setExpanded(false)
            slideDown()
            if (currentIndex < 0) return
            val smoothScroller = CenterSmoothScroller(requireContext())
            smoothScroller.targetPosition = currentIndex
            layoutManager.startSmoothScroll(smoothScroller)
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        setupTransition(view, false, axis = MaterialSharedAxis.Y)
        FastScrollerHelper.applyTo(binding.lyricsRecyclerView)
        ViewCompat.setOnApplyWindowInsetsListener(binding.root) { _, _ -> CONSUMED }
        observe(uiViewModel.moreSheetState) {
            binding.root.keepScreenOn = it == BottomSheetBehavior.STATE_EXPANDED
        }
        binding.searchBarText.setOnMenuItemClickListener { item ->
            when (item.itemId) {
                R.id.menu_lyrics -> ExtensionsListBottomSheet.newInstance(ExtensionType.LYRICS)
                    .show(parentFragmentManager, null)
            }
            true
        }
        val menu = binding.searchBarText.menu
        val extMenu = binding.searchBarText.findViewById<View>(R.id.menu_lyrics)
        extMenu.setOnLongClickListener {
            val ext = viewModel.currentSelectionFlow.value ?: return@setOnLongClickListener false
            val all = viewModel.extensionsFlow.value
            val index = all.indexOf(ext)
            val nextIndex = (index + 1) % all.size
            if (nextIndex == index) return@setOnLongClickListener false
            viewModel.selectExtension(nextIndex)
            true
        }
        val lyricsItemAdapter = LyricsItemAdapter { lyrics ->
            viewModel.onLyricsSelected(lyrics)
            binding.searchView.hide()
        }
        GridAdapter.configureGridLayout(
            binding.searchRecyclerView,
            lyricsItemAdapter.withLoaders(this, viewModel),
        )
        observe(viewModel.currentSelectionFlow) { current ->
            binding.searchBarText.hint = current?.name
            current?.metadata?.icon.loadAsCircle(extMenu, R.drawable.ic_extension_32dp) {
                menu.findItem(R.id.menu_lyrics).icon = it
            }
            val isSearchable = current?.isClient<LyricsSearchClient>() ?: false
            binding.searchBarText.setNavigationIcon(
                when (isSearchable) {
                    true -> R.drawable.ic_search_outline
                    false -> R.drawable.ic_queue_music
                }
            )
            binding.searchView.editText.isEnabled = isSearchable
            binding.searchView.hint = if (isSearchable)
                getString(R.string.search_x, current.name)
            else current?.name
        }

        binding.searchView.editText.setOnEditorActionListener { v, _, _ ->
            viewModel.queryFlow.value = v.text.toString().trim()
            true
        }

        observe(viewModel.queryFlow) {
            binding.searchView.editText.setText(it)
        }

        observe(viewModel.pagingFlow) {
            lyricsItemAdapter.submitData(it)
        }

        var job: Job? = null
        binding.lyricsRecyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {
            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
                if (dy > 0) return
                shouldAutoScroll = false
                job?.cancel()
                job = lifecycleScope.launch {
                    delay(3500)
                    shouldAutoScroll = true
                }
            }
        })

        observe(uiViewModel.playerColors) {
            lyricAdapter.updateColors()
            val colors = it ?: requireContext().defaultPlayerColors()
            binding.noLyrics.setTextColor(colors.onBackground)
        }

        binding.lyricsRecyclerView.adapter = ConcatAdapter(lyricsErrorAdapter, lyricAdapter)
        binding.lyricsRecyclerView.itemAnimator = null
        observe(viewModel.lyricsState) { state ->
            binding.noLyrics.isVisible = state == LyricsViewModel.State.Empty
            lyricsErrorAdapter.loadState = when (state) {
                LyricsViewModel.State.Initial -> LoadState.Loading
                LyricsViewModel.State.Empty -> NotLoading(true)
                LyricsViewModel.State.Loading -> LoadState.Loading
                is LyricsViewModel.State.Loaded -> state.result.fold({
                    NotLoading(true)
                }, {
                    Error(it)
                })

            }
            val lyricsItem = (state as? LyricsViewModel.State.Loaded)?.result?.getOrNull()
            binding.lyricsItem.bind(lyricsItem)
            currentLyricsPos = -1
            currentLyrics = lyricsItem?.lyrics
            val list = when (val lyrics = currentLyrics) {
                is Lyrics.Simple -> listOf(Lyrics.Item(lyrics.text, 0, 0))
                is Lyrics.Timed -> lyrics.list
                is Lyrics.WordByWord -> lyrics.list.flatten()
                null -> emptyList()
            }
            lyricAdapter.submitList(list)
        }

        observe(playerVM.progress) { updateLyrics(it.first) }
    }

    fun ItemLyricsItemBinding.bind(lyrics: Lyrics?) = root.run {
        if (lyrics == null) {
            isVisible = false
            return
        }
        isVisible = true
        setTitle(lyrics.title)
        setSubtitle(lyrics.subtitle)
        setBackgroundResource(R.color.amoled_bg)
    }

    class CenterSmoothScroller(context: Context) : LinearSmoothScroller(context) {
        override fun calculateDtToFit(
            viewStart: Int, viewEnd: Int, boxStart: Int, boxEnd: Int, snapPreference: Int,
        ): Int {
            val midPoint = boxEnd / 2
            val targetMidPoint = ((viewEnd - viewStart) / 2) + viewStart
            return midPoint - targetMidPoint
        }

        override fun getVerticalSnapPreference() = SNAP_TO_START
        override fun calculateTimeForDeceleration(dx: Int) = 650
    }

    @SuppressLint("WrongConstant")
    private fun slideDown() {
        val params = binding.lyricsItem.root.layoutParams as CoordinatorLayout.LayoutParams
        val behavior = params.behavior as HideViewOnScrollBehavior
        behavior.setViewEdge(1)
        behavior.slideOut(binding.lyricsItem.root)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\more\lyrics\LyricsItemAdapter.kt ----------
package com.joaomagdaleno.music_hub.ui.player.more.lyrics

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.paging.LoadState
import androidx.recyclerview.widget.DiffUtil
import com.joaomagdaleno.music_hub.common.models.Lyrics
import com.joaomagdaleno.music_hub.common.models.Tab
import com.joaomagdaleno.music_hub.databinding.ItemLoadingSmallBinding
import com.joaomagdaleno.music_hub.databinding.ItemShelfCategoryBinding
import com.joaomagdaleno.music_hub.ui.common.GridAdapter
import com.joaomagdaleno.music_hub.ui.feed.EmptyAdapter
import com.joaomagdaleno.music_hub.ui.feed.FeedAdapter.LoadingViewHolder
import com.joaomagdaleno.music_hub.ui.feed.FeedLoadingAdapter
import com.joaomagdaleno.music_hub.ui.feed.FeedLoadingAdapter.Companion.createListener
import com.joaomagdaleno.music_hub.ui.feed.TabsAdapter
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimPagingAdapter
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimViewHolder
import kotlinx.coroutines.flow.combine

class LyricsItemAdapter(
    private val listener: Listener
) : ScrollAnimPagingAdapter<Lyrics, LyricsItemAdapter.ViewHolder>(DiffCallback), GridAdapter {

    object DiffCallback : DiffUtil.ItemCallback<Lyrics>() {
        override fun areItemsTheSame(oldItem: Lyrics, newItem: Lyrics) = oldItem.id == newItem.id
        override fun areContentsTheSame(oldItem: Lyrics, newItem: Lyrics) = oldItem == newItem
    }

    fun interface Listener {
        fun onLyricsSelected(lyrics: Lyrics)
    }

    class ViewHolder(val binding: ItemShelfCategoryBinding) : ScrollAnimViewHolder(binding.root)

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val inflater = LayoutInflater.from(parent.context)
        val binding = ItemShelfCategoryBinding.inflate(inflater, parent, false)
        binding.icon.isVisible = false
        return ViewHolder(binding)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val lyrics = getItem(position) ?: return
        holder.binding.run {
            root.setOnClickListener { listener.onLyricsSelected(lyrics) }
            title.text = lyrics.title
            subtitle.text = lyrics.subtitle
            subtitle.isVisible = !lyrics.subtitle.isNullOrBlank()
        }
    }

    data class Loading(
        val parent: ViewGroup,
        val binding: ItemLoadingSmallBinding = ItemLoadingSmallBinding.inflate(
            LayoutInflater.from(parent.context), parent, false
        )
    ) : FeedLoadingAdapter.ViewHolder(binding.root)

    fun withLoaders(fragment: Fragment, viewModel: LyricsViewModel): GridAdapter {
        val tabs = TabsAdapter<Tab>({ title }) { view, index, tab ->
            viewModel.selectedTabIndexFlow.value = index
        }
        fragment.observe(viewModel.tabsFlow) { tabs.data = it }
        fragment.observe(viewModel.selectedTabIndexFlow) { tabs.selected = it }
        val loadStateListener = fragment.createListener { retry() }
        val header = FeedLoadingAdapter(loadStateListener) { LoadingViewHolder(it) }
        val footer = FeedLoadingAdapter(loadStateListener) { LoadingViewHolder(it) }
        val empty = EmptyAdapter()
        fragment.observe(
            loadStateFlow.combine(viewModel.shouldShowEmpty) { a, b -> a to b }
        ) { (loadStates, shouldShowEmpty) ->
            val isEmpty =
                shouldShowEmpty && itemCount == 0 && loadStates.append is LoadState.NotLoading
            empty.loadState = if (isEmpty) LoadState.Loading else LoadState.NotLoading(false)
        }
        addLoadStateListener { loadStates ->
            header.loadState = loadStates.refresh
            footer.loadState = loadStates.append
        }
        return GridAdapter.Concat(tabs, header, empty, this, footer)
    }

    override val adapter = this
    override fun getSpanSize(position: Int, width: Int, count: Int) = count

}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\more\lyrics\LyricsViewModel.kt ----------
package com.joaomagdaleno.music_hub.ui.player.more.lyrics

import androidx.core.content.edit
import androidx.lifecycle.viewModelScope
import androidx.media3.common.MediaItem
import androidx.paging.cachedIn
import com.joaomagdaleno.music_hub.common.Extension
import com.joaomagdaleno.music_hub.common.clients.LyricsClient
import com.joaomagdaleno.music_hub.common.models.Feed
import com.joaomagdaleno.music_hub.common.models.Lyrics
import com.joaomagdaleno.music_hub.di.App
import com.joaomagdaleno.music_hub.extensions.ExtensionLoader
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.getExtension
import com.joaomagdaleno.music_hub.extensions.ExtensionUtils.isClient
import com.joaomagdaleno.music_hub.extensions.cache.Cached
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.extensionId
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.isLoaded
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.playback.PlayerState
import com.joaomagdaleno.music_hub.ui.common.PagedSource
import com.joaomagdaleno.music_hub.ui.extensions.list.ExtensionListViewModel
import com.joaomagdaleno.music_hub.utils.CacheUtils.getFromCache
import com.joaomagdaleno.music_hub.utils.CacheUtils.saveToCache
import com.joaomagdaleno.music_hub.utils.CoroutineUtils.combineTransformLatest
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted.Companion.Eagerly
import kotlinx.coroutines.flow.SharingStarted.Companion.Lazily
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.emitAll
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.transformLatest
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class LyricsViewModel(
    private val app: App,
    extensionLoader: ExtensionLoader,
    playerState: PlayerState,
) : ExtensionListViewModel<Extension<*>>() {

    private val refreshFlow = MutableSharedFlow<Unit>()
    override val currentSelectionFlow = MutableStateFlow<Extension<*>?>(null)

    val queryFlow = MutableStateFlow("")
    val selectedTabIndexFlow = MutableStateFlow(-1)
    val lyricsState = MutableStateFlow<State>(State.Initial)

    private val mediaFlow = playerState.current.map { current ->
        current?.mediaItem?.takeIf { it.isLoaded }
    }.distinctUntilChanged().stateIn(viewModelScope, Eagerly, null)

    override val extensionsFlow = extensionLoader.lyrics.combine(mediaFlow) { lyrics, mediaItem ->
        val trackExtension = mediaItem?.extensionId?.let { id ->
            extensionLoader.music.getExtension(id)?.takeIf { it.isClient<LyricsClient>() }
        }
        listOfNotNull(trackExtension) + lyrics
    }.onEach { extensions ->
        currentSelectionFlow.value = null
        lyricsState.value = State.Initial
        queryFlow.value = ""
        val media = mediaFlow.value?.track?.id
        currentSelectionFlow.value = media?.let {
            val id = app.context.getFromCache<String>(media, "lyrics_ext")
                ?: app.settings.getString(LAST_LYRICS_KEY, null)
            extensions.find { it.id == id } ?: extensions.firstOrNull()
        }
        refreshFlow.emit(Unit)
    }.stateIn(viewModelScope, Eagerly, emptyList())

    override fun onExtensionSelected(extension: Extension<*>) {
        app.settings.edit { putString(LAST_LYRICS_KEY, extension.id) }
        val media = mediaFlow.value?.track?.id ?: return
        app.context.saveToCache<String>(media, extension.id, "lyrics_ext")
    }

    fun reloadCurrent() = viewModelScope.launch { refreshFlow.emit(Unit) }

    private val cachedFeed = combineTransformLatest(
        currentSelectionFlow, mediaFlow, queryFlow, refreshFlow
    ) {
        emit(null)
        val extension = it[0] as Extension<*>? ?: return@combineTransformLatest
        val item = it[1] as MediaItem? ?: return@combineTransformLatest
        val query = it[2] as String
        val result = Cached.getLyricsFeed(app, extension.id, item.extensionId, item.track, query)
        emit(result)
    }.stateIn(viewModelScope, Eagerly, null)

    private val loadedFeed = combineTransformLatest(
        currentSelectionFlow, mediaFlow, queryFlow, refreshFlow
    ) {
        emit(null)
        val extension = it[0] as Extension<*>? ?: return@combineTransformLatest
        val item = it[1] as MediaItem? ?: return@combineTransformLatest
        val query = it[2] as String
        val result = Cached.loadLyricsFeed(app, extension, item.extensionId, item.track, query)
        emit(result)
    }.stateIn(viewModelScope, Eagerly, null)

    private val feedFlow = loadedFeed.combine(cachedFeed) { loaded, cache ->
        cache to loaded
    }.stateIn(viewModelScope, Eagerly, null to null)

    val tabsFlow = feedFlow.map { (cached, loaded) ->
        val state = (loaded?.getOrNull() ?: cached?.getOrNull()) ?: return@map listOf()
        state.tabs
    }

    private suspend fun getData(
        feed: Result<Feed<Lyrics>>?, index: Int,
    ) = withContext(Dispatchers.IO) {
        feed?.mapCatching {
            val paged = it.getPagedData(it.tabs.run { getOrNull(index) ?: firstOrNull() }).pagedData
            paged
        }
    }

    private val cachedDataFlow =
        cachedFeed.combineTransformLatest(selectedTabIndexFlow) { feed, tab ->
            emit(null)
            if (feed == null) return@combineTransformLatest
            emit(getData(feed, tab))
        }.stateIn(viewModelScope, Lazily, null)

    private val loadedDataFlow =
        loadedFeed.combineTransformLatest(selectedTabIndexFlow) { feed, tab ->
            emit(null)
            if (feed == null) return@combineTransformLatest
            emit(getData(feed, tab))
        }.stateIn(viewModelScope, Lazily, null)

    private val dataFlow = loadedDataFlow.combine(cachedDataFlow) { loaded, cache ->
        cache to loaded
    }.stateIn(viewModelScope, Lazily, null to null)

    val shouldShowEmpty = dataFlow.map { (cached, loaded) ->
        val data = loaded?.getOrNull() ?: cached?.getOrNull()
        data != null
    }.stateIn(viewModelScope, Lazily, false)

    @OptIn(ExperimentalCoroutinesApi::class)
    val pagingFlow = dataFlow.transformLatest { (cached, loaded) ->
        emitAll(PagedSource(loaded, cached).flow)
    }.flowOn(Dispatchers.IO).cachedIn(viewModelScope)

    sealed interface State {
        data object Initial : State
        data object Loading : State
        data object Empty : State
        data class Loaded(val result: Result<Lyrics>) : State
    }

    fun onLyricsSelected(lyricsItem: Lyrics?) = viewModelScope.launch(Dispatchers.IO) {
        lyricsState.value = State.Loading
        if (lyricsItem == null) lyricsState.value = State.Empty else {
            val extension = currentSelectionFlow.value ?: return@launch
            lyricsState.value =
                State.Loaded(Cached.loadLyrics(app, extension, lyricsItem).map { it.fillGaps() })
        }
    }

    private fun Lyrics.fillGaps(): Lyrics {
        val lyrics = this.lyrics as? Lyrics.Timed
        return if (lyrics != null && lyrics.fillTimeGaps) {
            val new = mutableListOf<Lyrics.Item>()
            var last = 0L
            lyrics.list.forEach {
                if (it.startTime > last) {
                    new.add(Lyrics.Item("", last, it.startTime))
                }
                new.add(it)
                last = it.endTime
            }
            this.copy(lyrics = Lyrics.Timed(new))
        } else this
    }

    init {
        reloadCurrent()
        viewModelScope.launch(Dispatchers.IO) {
            dataFlow.collectLatest { (cached, loaded) ->
                if (lyricsState.value != State.Initial) return@collectLatest
                runCatching {
                    val cachedLyrics = cached?.getOrNull()?.loadAll()?.firstOrNull()
                    val loaded = loaded?.getOrNull()
                    if (loaded != null) {
                        lyricsState.value = State.Loading
                        onLyricsSelected(loaded.loadPage(null).data.firstOrNull())
                    } else if (cachedLyrics != null) {
                        onLyricsSelected(cachedLyrics)
                    }
                }
            }
        }
    }

    companion object {
        const val LAST_LYRICS_KEY = "last_lyrics_client"
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\more\upnext\QueueAdapter.kt ----------
package com.joaomagdaleno.music_hub.ui.player.more.upnext

import android.annotation.SuppressLint
import android.graphics.drawable.Animatable
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.ViewGroup
import androidx.core.view.isVisible
import androidx.media3.common.MediaItem
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.Track
import com.joaomagdaleno.music_hub.databinding.ItemPlaylistTrackBinding
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.isLoaded
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.ui.feed.viewholders.MediaViewHolder.Companion.subtitle
import com.joaomagdaleno.music_hub.utils.image.ImageUtils.loadInto
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.applyTranslationYAnimation
import com.joaomagdaleno.music_hub.utils.ui.UiUtils.marquee
import com.joaomagdaleno.music_hub.utils.ui.scrolling.ScrollAnimViewHolder

class QueueAdapter(
    private val listener: Listener,
    private val inactive: Boolean = false
) : ListAdapter<Pair<Boolean?, MediaItem>, QueueAdapter.ViewHolder>(DiffCallback) {

    object DiffCallback : DiffUtil.ItemCallback<Pair<Boolean?, MediaItem>>() {
        override fun areItemsTheSame(
            oldItem: Pair<Boolean?, MediaItem>,
            newItem: Pair<Boolean?, MediaItem>
        ) = oldItem.second.mediaId == newItem.second.mediaId

        override fun areContentsTheSame(
            oldItem: Pair<Boolean?, MediaItem>,
            newItem: Pair<Boolean?, MediaItem>
        ) = oldItem == newItem

    }

    open class Listener {
        open fun onItemClicked(position: Int) {}
        open fun onItemClosedClicked(position: Int) {}
        open fun onDragHandleTouched(viewHolder: RecyclerView.ViewHolder) {}
    }

    @SuppressLint("ClickableViewAccessibility")
    inner class ViewHolder(
        val binding: ItemPlaylistTrackBinding
    ) : ScrollAnimViewHolder(binding.root) {

        init {
            binding.playlistItemClose.setOnClickListener {
                val pos = bindingAdapterPosition
                if (pos == RecyclerView.NO_POSITION) return@setOnClickListener
                listener.onItemClosedClicked(pos)
            }

            binding.root.setOnClickListener {
                val pos = bindingAdapterPosition
                if (pos == RecyclerView.NO_POSITION) return@setOnClickListener
                listener.onItemClicked(pos)
            }

            binding.playlistItemDrag.setOnTouchListener { _, event ->
                val pos = bindingAdapterPosition
                if (pos == RecyclerView.NO_POSITION) return@setOnTouchListener false
                if (event.actionMasked != MotionEvent.ACTION_DOWN) return@setOnTouchListener false
                listener.onDragHandleTouched(this)
                true
            }
        }

    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val inflater = LayoutInflater.from(parent.context)
        return ViewHolder(ItemPlaylistTrackBinding.inflate(inflater, parent, false))
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.onBind(position)
        holder.itemView.applyTranslationYAnimation(scrollAmount)
    }

    private fun ViewHolder.onBind(position: Int) {
        val (current, item) = getItem(position)
        val isCurrent = current != null
        val isPlaying = current == true
        val track = item.track
        binding.bind(track)
        binding.isPlaying(isPlaying)
        binding.playlistItemClose.isVisible = !inactive
        binding.playlistItemDrag.isVisible = !inactive
        binding.playlistCurrentItem.isVisible = isCurrent
        binding.playlistProgressBar.isVisible = isCurrent && !item.isLoaded
        binding.playlistItem.alpha = if (inactive) 0.5f else 1f
    }

    private var scrollAmount: Int = 0
    private val scrollListener = object : RecyclerView.OnScrollListener() {
        override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
            scrollAmount = dy
        }
    }

    var recyclerView: RecyclerView? = null
    override fun onAttachedToRecyclerView(recyclerView: RecyclerView) {
        this.recyclerView = recyclerView
        recyclerView.addOnScrollListener(scrollListener)
    }

    override fun onDetachedFromRecyclerView(recyclerView: RecyclerView) {
        recyclerView.removeOnScrollListener(scrollListener)
        this.recyclerView = null
    }

    companion object {
        fun ItemPlaylistTrackBinding.bind(track: Track) {
            playlistItemTitle.run {
                text = track.title
                marquee()
            }

            track.cover.loadInto(playlistItemImageView, R.drawable.art_music)
            val subtitle = track.subtitle(root.context)
            playlistItemAuthor.run {
                isVisible = !subtitle.isNullOrEmpty()
                text = subtitle
                marquee()
            }
        }

        fun ItemPlaylistTrackBinding.isPlaying(isPlaying: Boolean) {
            playlistItemNowPlaying.isVisible = isPlaying
            (playlistItemNowPlaying.drawable as Animatable).start()
        }
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\more\upnext\QueueFragment.kt ----------
package com.joaomagdaleno.music_hub.ui.player.more.upnext

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import androidx.recyclerview.widget.ItemTouchHelper
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.transition.MaterialSharedAxis
import com.joaomagdaleno.music_hub.databinding.FragmentPlayerQueueBinding
import com.joaomagdaleno.music_hub.ui.player.PlayerViewModel
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.ui.AnimationUtils.setupTransition
import com.joaomagdaleno.music_hub.utils.ui.AutoClearedValue.Companion.autoClearedNullable
import org.koin.androidx.viewmodel.ext.android.activityViewModel

class QueueFragment : Fragment() {

    private var binding by autoClearedNullable<FragmentPlayerQueueBinding>()
    private val viewModel by activityViewModel<PlayerViewModel>()

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        binding = FragmentPlayerQueueBinding.inflate(inflater, container, false)
        return binding!!.root
    }

    private val queueAdapter by lazy {
        QueueAdapter(object : QueueAdapter.Listener() {
            override fun onDragHandleTouched(viewHolder: RecyclerView.ViewHolder) {
                touchHelper.startDrag(viewHolder)
            }

            override fun onItemClicked(position: Int) {
                viewModel.play(position)
            }

            override fun onItemClosedClicked(position: Int) {
                viewModel.removeQueueItem(position)
            }
        })
    }

    private val touchHelper by lazy {
        ItemTouchHelper(object : ItemTouchHelper.SimpleCallback(
            ItemTouchHelper.UP or ItemTouchHelper.DOWN,
            ItemTouchHelper.START
        ) {
            override fun onMove(
                recyclerView: RecyclerView,
                viewHolder: RecyclerView.ViewHolder,
                target: RecyclerView.ViewHolder
            ): Boolean {
                val fromPos = viewHolder.bindingAdapterPosition
                val toPos = target.bindingAdapterPosition
                viewModel.moveQueueItems(fromPos, toPos)
                return true
            }

            override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) {
                val pos = viewHolder.bindingAdapterPosition
                viewModel.removeQueueItem(pos)
            }

            override fun getMovementFlags(
                recyclerView: RecyclerView,
                viewHolder: RecyclerView.ViewHolder
            ): Int {
                return makeMovementFlags(
                    ItemTouchHelper.UP or ItemTouchHelper.DOWN,
                    ItemTouchHelper.START
                )
            }
        })
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        setupTransition(view, false, axis = MaterialSharedAxis.Y)
        val recyclerView = binding!!.root
        recyclerView.adapter = queueAdapter
        touchHelper.attachToRecyclerView(recyclerView)
        val manager = recyclerView.layoutManager as LinearLayoutManager
        val screenHeight = view.resources.displayMetrics.heightPixels / 3

        fun submit() {
            val current = viewModel.playerState.current.value
            val currentIndex = current?.index
            val it = viewModel.queue.mapIndexed { index, mediaItem ->
                if (currentIndex == index) current.isPlaying to current.mediaItem
                else null to mediaItem
            }
            queueAdapter.submitList(it) {
                currentIndex ?: return@submitList
                binding?.root?.scrollToPosition(currentIndex)
            }
        }

        observe(viewModel.playerState.current) { submit() }
        observe(viewModel.queueFlow) { submit() }

        val index = viewModel.playerState.current.value?.index ?: return
        manager.scrollToPositionWithOffset(index + 1, screenHeight)
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\quality\FormatUtils.kt ----------
package com.joaomagdaleno.music_hub.ui.player.quality

import android.content.Context
import androidx.annotation.OptIn
import androidx.media3.common.C
import androidx.media3.common.Format
import androidx.media3.common.Tracks
import androidx.media3.common.util.UnstableApi
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.Streamable

object FormatUtils {
    @OptIn(UnstableApi::class)
    private fun Format.getBitrate() =
        (bitrate / 1000).takeIf { it > 0 }?.let { "  $it kbps" } ?: ""

    private fun Format.getFrameRate() =
        frameRate.toInt().takeIf { it > 0 }?.let { "  $it fps" } ?: ""


    private fun Format.getMimeType() = when (val mime = sampleMimeType?.replace("audio/", "")) {
        "mp4a-latm" -> "AAC"
        else -> mime?.uppercase()
    }

    private fun Format.getHertz() =
        sampleRate.takeIf { it > 0 }?.let { "  $it Hz" } ?: ""

    private fun Format.getChannelCount() =
        channelCount.takeIf { it > 0 }?.let { "  ${it}ch" } ?: ""

    @OptIn(UnstableApi::class)
    fun Format.toAudioDetails() =
        "${getMimeType()}${getHertz()}${getChannelCount()}${getBitrate()}"

    fun Format.toVideoDetails() = "${height}p${getFrameRate()}${getBitrate()}"
    fun Format.toSubtitleDetails() = label ?: language ?: "Unknown"

    private fun List<Tracks.Group>.getSelectedFormat(): Format? {
        return firstNotNullOfOrNull { trackGroup ->
            val index = (0 until trackGroup.length).firstNotNullOfOrNull { i ->
                if (trackGroup.isTrackSelected(i)) i else null
            } ?: return null
            trackGroup.getTrackFormat(index)
        }
    }

    fun List<Tracks.Group>.getSelected(): Pair<List<Pair<Tracks.Group, Int>>, Int?> {
        var selected: Pair<Tracks.Group, Int>? = null
        val trackGroups = map { trackGroup ->
            (0 until trackGroup.length).map { i ->
                val pair = Pair(trackGroup, i)
                val isSelected = trackGroup.isTrackSelected(i)
                if (isSelected) selected = pair
                pair
            }
        }.flatten()
        val select = trackGroups.indexOf(selected).takeIf { it != -1 }
        return trackGroups to select
    }

    fun Tracks.getDetails(
        context: Context, server: Streamable.Media.Server?, index: Int?,
    ): List<String> {
        val audios = groups.filter { it.type == C.TRACK_TYPE_AUDIO }
        val videos = groups.filter { it.type == C.TRACK_TYPE_VIDEO }
        val subtitles = groups.filter { it.type == C.TRACK_TYPE_TEXT }
        val sourceTitle = server?.run {
            if (merged) sources.mapNotNull { it.title }
            else listOfNotNull(sources.getOrNull(index ?: -1)?.title)
        }.orEmpty()
        return sourceTitle + listOfNotNull(
            audios.getSelectedFormat()?.toAudioDetails(),
            videos.getSelectedFormat()?.toVideoDetails(),
            subtitles.getSelectedFormat()?.toSubtitleDetails()
        ).ifEmpty { listOf(context.getString(R.string.unknown_quality)) }
    }
}


---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\quality\QualitySelectionBottomSheet.kt ----------
package com.joaomagdaleno.music_hub.ui.player.quality

import android.annotation.SuppressLint
import android.os.Bundle
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.annotation.OptIn
import androidx.core.view.isVisible
import androidx.media3.common.C
import androidx.media3.common.Format
import androidx.media3.common.Tracks
import androidx.media3.common.util.UnstableApi
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.google.android.material.chip.Chip
import com.google.android.material.chip.ChipGroup
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.common.models.Streamable
import com.joaomagdaleno.music_hub.databinding.DialogPlayerQualitySelectionBinding
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.backgroundIndex
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.serverIndex
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.serverWithDownloads
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.subtitleIndex
import com.joaomagdaleno.music_hub.playback.MediaItemUtils.track
import com.joaomagdaleno.music_hub.ui.common.FragmentUtils.openFragment
import com.joaomagdaleno.music_hub.ui.player.PlayerViewModel
import com.joaomagdaleno.music_hub.ui.player.quality.FormatUtils.getDetails
import com.joaomagdaleno.music_hub.ui.player.quality.FormatUtils.getSelected
import com.joaomagdaleno.music_hub.ui.player.quality.FormatUtils.toAudioDetails
import com.joaomagdaleno.music_hub.ui.player.quality.FormatUtils.toSubtitleDetails
import com.joaomagdaleno.music_hub.ui.player.quality.FormatUtils.toVideoDetails
import com.joaomagdaleno.music_hub.ui.settings.SettingsPlayerFragment
import com.joaomagdaleno.music_hub.utils.ContextUtils.observe
import com.joaomagdaleno.music_hub.utils.ui.AutoClearedValue.Companion.autoCleared
import org.koin.androidx.viewmodel.ext.android.activityViewModel

class QualitySelectionBottomSheet : BottomSheetDialogFragment() {
    var binding by autoCleared<DialogPlayerQualitySelectionBinding>()
    private val viewModel by activityViewModel<PlayerViewModel>()

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?,
    ): View {
        binding = DialogPlayerQualitySelectionBinding.inflate(inflater, container, false)
        return binding.root
    }

    @SuppressLint("NotifyDataSetChanged")
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        binding.topAppBar.setNavigationOnClickListener { dismiss() }
        binding.topAppBar.setOnMenuItemClickListener {
            dismiss()
            requireActivity().openFragment<SettingsPlayerFragment>()
            true
        }

        observe(viewModel.buffering) {
            binding.progressIndicator.isVisible = it
        }
        observe(viewModel.playerState.current) { current ->
            val item = current?.mediaItem ?: return@observe
            val track = item.track
            binding.run {
                applyChips(
                    item.serverWithDownloads(requireContext()),
                    streamableServer, streamableServerGroup, item.serverIndex
                ) {
                    it ?: return@applyChips
                    viewModel.changeServer(it)
                }
                streamableServer.isVisible = true
                streamableServerGroup.isVisible = true

                applyChips(
                    listOf(null, *track.backgrounds.toTypedArray()), streamableBackgrounds,
                    streamableBackgroundGroup, item.backgroundIndex + 1
                ) {
                    viewModel.changeBackground(it)
                }

                applyChips(
                    listOf(null, *track.subtitles.toTypedArray()), streamableSubtitles,
                    streamableSubtitleGroup, item.subtitleIndex + 1
                ) {
                    viewModel.changeSubtitle(it)
                }
            }
        }

        observe(viewModel.serverAndTracks) { (tracks, server, index) ->
            val list = if (server != null && !server.merged) server.sources else listOf()
            binding.run {
                applyChips(
                    list, streamableSource, streamableSourceGroup, index,
                    { viewModel.changeCurrentSource(list.indexOf(it)) }) {
                    it.title ?: getString(R.string.quality_x, it.quality)
                }
            }
            val details = tracks?.getDetails(requireContext(), server, index)?.joinToString("\n")
            binding.streamableInfo.text = details
            binding.streamableInfo.isVisible = !details.isNullOrBlank()

            val audios = tracks?.groups?.filter { it.type == C.TRACK_TYPE_AUDIO }
            val videos = tracks?.groups?.filter { it.type == C.TRACK_TYPE_VIDEO }
            val subtitles = tracks?.groups?.filter { it.type == C.TRACK_TYPE_TEXT }

            val onClick: Chip.(Pair<Tracks.Group, Int>?) -> Unit = {
                val trackGroup = it!!.first.mediaTrackGroup
                viewModel.changeTrackSelection(trackGroup, it.second)
            }

            binding.run {
                applyChips(audios, trackAudios, trackAudiosGroup, onClick) {
                    it.toAudioDetails()
                }
                applyChips(videos, trackVideos, trackVideosGroup, onClick) {
                    it.toVideoDetails()
                }
                applyChips(subtitles, trackSubtitles, trackSubtitlesGroup, onClick) {
                    it.toSubtitleDetails()
                }
            }
        }
    }

    @OptIn(UnstableApi::class)
    private fun applyChips(
        groups: List<Tracks.Group>?,
        textView: TextView,
        chipGroup: ChipGroup,
        onClick: Chip.(Pair<Tracks.Group, Int>?) -> Unit,
        text: (Format) -> String,
    ) {
        val (trackGroups, select) = groups.orEmpty().getSelected()
        applyChips(trackGroups, textView, chipGroup, select, onClick) {
            val format = it.first.getTrackFormat(it.second)
            text(format)
        }
    }

    private fun applyChips(
        streamables: List<Streamable?>,
        textView: TextView,
        chipGroup: ChipGroup,
        selected: Int?,
        onClick: Chip.(Streamable?) -> Unit,
    ) {
        val context = chipGroup.context
        applyChips(streamables, textView, chipGroup, selected, onClick) {
            it?.let {
                it.title ?: when (it.type) {
                    Streamable.MediaType.Subtitle -> context.getString(R.string.unknown)
                    else -> context.getString(R.string.quality_x, it.quality)
                }
            } ?: context.getString(R.string.off)
        }
    }

    private fun <T> applyChips(
        list: List<T>,
        textView: TextView,
        chipGroup: ChipGroup,
        selected: Int?,
        onClick: Chip.(T) -> Unit,
        text: (T) -> String,
    ) {
        val visible = list.size > 1
        textView.isVisible = visible
        chipGroup.apply {
            isVisible = visible
            removeAllViews()
            list.forEachIndexed { index, t ->
                val chip = Chip(context)
                chip.text = text(t)
                chip.ellipsize = TextUtils.TruncateAt.MIDDLE
                chip.isCheckable = true
                addView(chip)
                if (index == selected) check(chip.id)
                chip.setOnCheckedChangeListener { _, isChecked ->
                    if (isChecked) onClick(chip, t)
                }
            }
        }
    }
}

---------- FILE: app\src\main\java\com\joaomagdaleno\music_hub\ui\player\sleep\SleepTimerBottomSheet.kt ----------
package com.joaomagdaleno.music_hub.ui.player.sleep

import android.annotation.SuppressLint
import android.content.Context
import android.content.DialogInterface
import android.os.Bundle
import android.text.format.DateFormat
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.edit
import androidx.media3.common.C
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.google.android.material.timepicker.MaterialTimePicker
import com.google.android.material.timepicker.TimeFormat
import com.joaomagdaleno.music_hub.R
import com.joaomagdaleno.music_hub.databinding.DialogPlayerSleepTimerBinding
import com.joaomagdaleno.music_hub.ui.common.SnackBarHandler.Companion.createSnack
import com.joaomagdaleno.music_hub.ui.player.PlayerViewModel
import com.joaomagdaleno.music_hub.utils.ui.AutoClearedValue.Companion.autoCleared
import com.joaomagdaleno.music_hub.utils.ui.RulerAdapter
import org.koin.androidx.viewmodel.ext.android.activityViewModel
import java.util.Calendar

class SleepTimerBottomSheet : BottomSheetDialogFragment() {
    var binding by autoCleared<DialogPlayerSleepTimerBinding>()
    private val viewModel by activityViewModel<PlayerViewModel>()

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        binding = DialogPlayerSleepTimerBinding.inflate(inflater, container, false)
        return binding.root
    }

    private val adapter by lazy {
        RulerAdapter(object : RulerAdapter.Listener<Int> {
            override fun intervalText(value: Int) = value.toString()
            override fun onSelectItem(value: Int) {
                rulerTime = value
                binding.sleepTimerValue.text = requireContext().createString(value * 60L * 1000)
            }
        })
    }

    @SuppressLint("NotifyDataSetChanged")
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        binding.sleepTimerRecycler.adapter = adapter
        val last = viewModel.settings.getInt("sleep_timer", 5)
        adapter.submitList(timeRangeWithIntervals, last)

        binding.okay.setOnClickListener { saveAndDismiss(rulerTime) }
        binding.endOfTrack.setOnClickListener { setTimerAndDismiss(Long.MAX_VALUE) }
        binding.min15.setOnClickListener { saveAndDismiss(15) }
        binding.min30.setOnClickListener { saveAndDismiss(30) }
        binding.min45.setOnClickListener { saveAndDismiss(45) }
        binding.hr1.setOnClickListener { saveAndDismiss(60) }
        binding.hr2.setOnClickListener { saveAndDismiss(120) }

        binding.topAppBar.setNavigationOnClickListener { setTimerAndDismiss(0) }
        binding.topAppBar.setOnMenuItemClickListener {
            when (it.itemId) {
                R.id.menu_schedule -> {
                    val is24Hour = DateFormat.is24HourFormat(context)
                    val picker = MaterialTimePicker.Builder()
                        .setTimeFormat(if (is24Hour) TimeFormat.CLOCK_24H else TimeFormat.CLOCK_12H)
                        .setTitleText(getString(R.string.sleep_on_specific_time))
                        .build()
                    picker.addOnCancelListener { picker.dismiss() }
                    picker.addOnPositiveButtonClickListener {
                        val now = Calendar.getInstance()
                        val nowMin = now.get(Calendar.HOUR_OF_DAY) * 60 + now.get(Calendar.MINUTE)
                        val pickerMin = picker.hour * 60 + picker.minute
                        val time = if (pickerMin > nowMin) pickerMin - nowMin
                        else 1440 - nowMin + pickerMin
                        setTimerAndDismiss(time * 60L * 1000)
                    }
                    picker.show(childFragmentManager, null)
                    true
                }

                else -> false
            }
        }
    }

    private var timer = 0L
    private fun setTimerAndDismiss(ms: Long) {
        timer = ms
        dismiss()
    }

    private fun saveAndDismiss(mins: Int) {
        viewModel.settings.edit { putInt("sleep_timer", mins) }
        val ms = mins * 60L * 1000
        setTimerAndDismiss(ms)
    }

    override fun onDismiss(dialog: DialogInterface) {
        super.onDismiss(dialog)
        viewModel.setSleepTimer(timer)
        val message = when (timer) {
            0L -> getString(R.string.sleep_timer_cancelled)
            Long.MAX_VALUE -> {
                val until = viewModel.browser.value?.run {
                    (duration.takeIf { it != C.TIME_UNSET } ?: 0) - currentPosition
                } ?: 0
                getString(R.string.sleep_timer_set_for, requireContext().createString(until))
            }

            else -> getString(R.string.sleep_timer_set_for, requireContext().createString(timer))
        }
        createSnack(message)
    }

    private var rulerTime = 5

    companion object {
        private const val MAX = 360
        private const val MIN = 5
        private const val STEPS = 5
        private const val INTERVAL = 15

        val timeRangeWithIntervals = 0.rangeTo((MAX - MIN) / STEPS).map {
            val value = MIN + it * STEPS
            value to (value == MIN || value % INTERVAL == 0)
        }

        private fun Context.createString(ms: Long): String {
            val minutes = ms / 1000 / 60
            val hrs = minutes / 60
            val min = minutes % 60
            val str = StringBuilder()
            if (hrs > 0) str.append(
                runCatching { resources.getQuantityString(R.plurals.number_hour, hrs.toInt(), hrs) }
                    .getOrNull() ?: getString(R.string.n_hours, hrs)
            ).append(if (min > 0) " " else "")
            if (min > 0) str.append(
                runCatching { resources.getQuantityString(R.plurals.number_min, min.toInt(), min) }
                    .getOrNull() ?: getString(R.string.n_minutes, min)
            )
            return str.toString()
        }
    }
}

